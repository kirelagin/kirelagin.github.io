<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>×</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="stylesheet" href="css/normalize.min.css">
        <link rel="stylesheet" href="css/main.css">
        <link rel="stylesheet" href="css/tooltipster.css" />
        <link rel="stylesheet" href="css/themes/tooltipster-noir.css" />

        <script src="js/vendor/modernizr-2.8.3.min.js"></script>
    </head>
    <body>

        <ul id="users">
<li class="user">
<div class="uid">1456128</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n&gt;=0 then (zipWith const (drop n (cycle xs)) xs) else
		        zipWith const (drop (length(xs) + n) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n&gt;=0 then (zipWith const (drop (snd quotRem n length(xs)) (cycle xs)) xs) else
		        zipWith const (drop (snd quotRem (length(xs) + n) length(xs)) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n&gt;=0 then (zipWith const (drop (snd (quotRem n length(xs))) (cycle xs)) xs) else
		        zipWith const (drop (snd (quotRem (length(xs) + n) length(xs))) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n&gt;=0 then take (length xs) (drop n (cycle xs)) else
		take (length xs) (drop (length(xs) + n) (cycle xs))
--rotate n xs = if n&gt;=0 then (zipWith const (drop (snd (quotRem n length(xs))) (cycle xs)) xs) else
--		        zipWith const (drop (snd (quotRem (length(xs) + n) length(xs))) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n&gt;=0 then take (length xs) (drop (snd (quotRem n length(xs))) (cycle xs)) else
		take (length xs) (drop (length(xs) + n) (cycle xs))
--rotate n xs = if n&gt;=0 then (zipWith const (drop (snd (quotRem n length(xs))) (cycle xs)) xs) else
--		        zipWith const (drop (snd (quotRem (length(xs) + n) length(xs))) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n&gt;=0 then (zipWith const (drop (snd (quotRem n ((fromIntegral.length) xs))) (cycle xs)) xs) else
		zipWith const (drop (snd (quotRem (length(xs) + n) ((fromIntegral.length) xs))) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n&gt;=0 then take (length xs) (drop (snd (quotRem n ((fromIntegral.length) xs))) (cycle xs)) else
                take (length xs) (drop (snd (quotRem (length(xs) + n) ((fromIntegral.length) xs))) (cycle xs))
--rotate n xs = if n&gt;=0 then (zipWith const (drop (snd (quotRem n ((fromIntegral.length) xs))) (cycle xs)) xs) else
--		zipWith const (drop (snd (quotRem (length(xs) + n) ((fromIntegral.length) xs))) (cycle xs)) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">127769</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = bs ++ as where (as, bs) = splitAt n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st@[] = take (length st) $ drop (x `mod` length st) $ cycle st
rotate x st@[a1] = take (length st) $ drop (x `mod` length st) $ cycle st
rotate x st@[a1,a2] = take (length st) $ drop (x `mod` length st) $ cycle st
rotate x st@[a1,a2,a3] = take (length st) $ drop (x `mod` length st) $ cycle st
rotate x st@[a1,a2,a3,a4] = take (length st) $ drop (x `mod` length st) $ cycle st
rotate x st@[a1,a2,a3,a4,a5] = take (length st) $ drop (x `mod` length st) $ cycle st
rotate x st@[a1,a2,a3,a4,a5,a6] = take (length st) $ drop (x `mod` length st) $ cycle st
rotate x st@[a1,a2,a3,a4,a5,a6,a7] = take (length st) $ drop (x `mod` length st) $ cycle st
rotate x st@[a1,a2,a3,a4,a5,a6,a7,a8] = take (length st) $ drop (x `mod` length st) $ cycle st
rotate x st@[a1,a2,a3,a4,a5,a6,a7,a8,a9] = take (length st) $ drop (x `mod` length st) $ cycle st
rotate x st@[a1,a2,a3,a4,a5,a6,a7,a8,a9,a10] = take (length st) $ drop (x `mod` length st) $ cycle st
rotate x st = if x &gt;= 0 then
                  drop x st ++ take x st
              else let l = ((length st) + x) in
                  drop l st ++ take l st</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1060471</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (negate x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = |n&gt;0 == take (length xs) (drop n (cycle xs))
              |otherwise == drop (length xs) (take (abs n) (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;0 == take (length xs) (drop n (cycle xs))
              | otherwise == drop (length xs) (take (abs n) (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;0 = take (length xs) (drop n (cycle xs))
            | otherwise = drop (length xs) (take (abs n) (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;=0 = take (length xs) (drop n (cycle xs))
            | otherwise = drop (length xs) (take (abs n) (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 l = l
rotate (n+1) (x:xs)  = rotate n (xs ++ [x]) 
rotate n l  = rotate (length l + n) l </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 = rotate (tail x ++ [head x]) (y-1)
  | otherwise = rotate (last x : init x) (y+1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 = rotate  (y-1) (tail x ++ [head x])
  | otherwise = rotate (y+1) (last x : init x) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 = rotate  (y-1) (tail x ++ [head x])
  | otherwise = rotate (y+1) (last x : init x) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 = rotate  (y-1) (tail x ++ [head x])
  | otherwise = rotate (y+1) (last x : init x) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 = rotate  (y-1) (tail x ++ [head x])
  | otherwise = rotate (y+1) (last x : init x) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
  | n &gt; 0 = rotate  (n-1) (tail xs ++ [head xs])
  | otherwise = rotate (n+1) (last xs : init xs) </pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1948204</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [x] = [x]
rotate n (x : xs ++ [y])
    | n &gt; 0     = rotate (n-1) (xs ++ [y,x])
    | otherwise = rotate (n-1) (y : x: xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [x] = [x]
rotate n xs
    | n &gt; 0     = rotate (n-1) (xs ++ [last xs, head xs])
    | otherwise = rotate (n-1) ((last xs) : (head xs) : xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [x] = [x]
rotate n xs
    | n &gt; 0     = rotate (n-1) ((tail xs) ++ [head xs])
    | otherwise = rotate (n-1) ((last xs) : (init xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [x] = [x]
rotate n xs
    | n &gt; 0     = rotate ((n `mod` (length xs))-1) ((tail xs) ++ [head xs])
    | otherwise = rotate ((n `mod` (length xs))-1) ((last xs) : (init xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
    | n &gt;= 0    = zipWith const (drop n (cycle xs)) xs
    | otherwise = zipWith const (drop ((n `mod` (length xs)) + length xs) (cycle xs)) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">313658</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.Function
import Data.Char 

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate xs n = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Nat -&gt; [a] -&gt; [a]
rotate Z     xs     = xs
rotate _     []     = []
rotate (S n) (x:xs) = rotate n (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (negate x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
map rotate n xs = drop n xs ++ take n xs </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate xs n | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
rotate xs n = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
rotate xs n = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt; 0 = rotate xs (n+len)
    | n &gt; len = rotate xs (n-len)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate x 0 = x
rotate x ns
  | x &gt; 0 = rotate (tail ns ++ [head ns]) (x-1)
  | otherwise = rotate (last ns : init ns) (x+1)	  </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n&lt;0       = rotateR (-i)
            | n&gt;0       = rotateL i
            | otherwise = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n&lt;0       = rotateR (-n)
            | n&gt;0       = rotateL n
            | otherwise = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.Char
import Data.Int
import Test.QuickCheck
rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.Char
import Data.Int
import Test.QuickCheck
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 l = l
rotate (n+1) (x:xs) = rotate n (xs ++ [x])
rotate n l = rotate (length l + n) l</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.Char
import Data.Int
import Test.QuickCheck
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 l = l
rotate (n+1) (x:xs) = rotate n (xs ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 l = l
rotate (n + 1) (x:xs) = rotate n (xs ++ [x])
rotate n l = rotate (length l + n) l</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 st = st 
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>import Data.Bits
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = snd b ++ fst b
  where b = splitAt n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate i xs = concat $ (drop i xs) : take i xs : []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>module NNLists.NNListsContinued where

import Data.List
import NNLists.NNLists
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate i xs = concat $ (drop i xs) : take i xs : []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
import NNLists.NNLists
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate i xs = concat $ (drop i xs) : take i xs : []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate i xs = concat $ (drop i xs) : take i xs : []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = concat $ (drop n xs) : take n xs : []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate n p =
    let (b, a) = splitAt n p
    in a ++ b</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = rotate (n-1) (xs++[x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.Char
import Math.Algebra.Field.Base
import Data.List
import Test.QuickCheck

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.Char
import Data.List
import Test.QuickCheck

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.Char
import Data.List
import Test.QuickCheck

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = iterate rot xs !! n where rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.Char
import Data.List
import Test.QuickCheck

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.Char
import Data.List
import Test.QuickCheck

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn" title="<code><pre>import Data.Char
import Data.List
import Test.QuickCheck

rotate :: Int -&gt; [a] -&gt; [a]
rotate xs = init (zipWith (++) (Data.List.tails xs) (Data.List.inits xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.Char
import Data.List
import Test.QuickCheck

rotate :: Int -&gt; [a] -&gt; [a]
rotate = go
    where
        go n as
            | n &gt;= 0 = iterate rotr as !! n
            | n &lt;  0 = iterate rotl as !! abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.Char
import Data.Bits
import Test.QuickCheck

rotate :: Int -&gt; [a] -&gt; [a]
rotate = go
    where
        go n as
            | n &gt;= 0 = iterate rotr as !! n
            | n &lt;  0 = iterate rotl as !! abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import           Control.Applicative
import           Control.Lens
import           Control.Monad.Plus
import qualified Data.Char
import           Data.Functor.Contravariant (Equivalence (..), contramap)
import qualified Data.List
import qualified Data.Monoid
import qualified Data.Ratio

rotate :: Int -&gt; [a] -&gt; [a]
rotate = go
    where
        go n as
            | n &gt;= 0 = iterate rotr as !! n
            | n &lt;  0 = iterate rotl as !! abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import           Control.Applicative
import qualified Data.Char
import qualified Data.List
import qualified Data.Monoid
import qualified Data.Ratio

rotate :: Int -&gt; [a] -&gt; [a]
rotate = go
    where
        go n as
            | n &gt;= 0 = iterate rotr as !! n
            | n &lt;  0 = iterate rotl as !! abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rot [] = []
rot [x] = [x]
rot (x:xs) = xs ++ [x]

--rotate 2 &quot;ABCD&quot; =&gt; &quot;CDAB&quot;
rotate 0 xs = xs
rotate n xs = rotate (n-1) (rot xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rot [] = []
rot [x] = [x]
rot (x:xs) = xs ++ [x]

--rotate 2 &quot;ABCD&quot; =&gt; &quot;CDAB&quot;
rotate 0 xs = xs
rotate n xs = (iterate rot xs) !! n
</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | null xs = []
            | n &gt;= 0     = rotateRight n xs
            | otherwise = rotateLeft  (-n) xs
 
  where
    len = length xs
    rotateLeft n xs | null suff = rotateLeft (n `mod` len) xs
                    | otherwise = drop (len - n) xs ++ (take (len - n) xs)
      where suff = drop (abs n) xs
 
    rotateRight n xs | null suff = rotateRight (n `mod` len) xs
                     | otherwise = drop n xs ++ (take n xs)
      where suff = drop (abs n) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1873728</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = bs ++ as where (as, bs) = splitAt n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = rotate (n-1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = bs ++ as where (as, bs) = splitAt n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n == length xs then _ [] = [] else zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n == length xs then [] else zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n == length xs then [] else take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
rotate xs n = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
    | n &lt; 0 = rotate xs (n+len)
    | n &gt; len = rotate xs (n-len)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate l 0 = l
rotate (x:xs) (n+1) = rotate (xs ++ [x]) n
rotate l n = rotate l (length l + n)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate x 0 = x
rotate x y
  | y &gt; 0 = rotate (tail x ++ [head x]) (y-1)
  | otherwise = rotate (last x : init x) (y+1)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate n xs =  take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate n xs =  take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate n xs =  iterate rot xs !! n where rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = iterate rot xs !! n where rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n == xs then xs else take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]rotate n xs = if n == xs then xs else take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n == xs then xs else take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n [n] = [n]
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1933127</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = bs ++ as where (as, bs) = splitAt n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate xs n = take len . drop (n `mod` len) . cycle $ xs  
                where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take len . drop (n `mod` len) . cycle $ xs  
                where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
rotate n xs = drop nn xs ++ take nn xs  where nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
let rotate n xs = if n &gt;= 0 then  drop n xs ++ take n xs  else let l = ((length xs) + n) in drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then  drop n xs ++ take n xs  else let l = ((length xs) + n) in drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt; 0 = rotate (n+len) xs
    | n &gt; len = rotate (n-len) xs
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
rotate n xs = drop nn xs ++ take nn xs  where  nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = take len . drop (n `mod` len) . cycle $ xs  where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs  where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []  = []
rotate 0 x = x
rotate n xs
  | n &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []  = []
rotate 0 x = x
rotate n xs
  | n &gt; 0 = rotate (n-1) (tail xs ++ [head xs]) 
  | otherwise = rotate (n+1) (last xs : init xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate x xs = take (length xs) $ drop (negate x `mod` length xs) $ cycle xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = (drop n xs) ++ (take n xs)
            | n &lt;= 0 = (drop sizeRecip  xs) ++ (take sizeRecip xs)
               where sizeRecip = (length xs) + n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) | n &gt; 0 = rotate (n-1) (xs ++ [x])
rotate n xs | n &lt; 0 = rotate (n+1) (last xs : init xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
3	    | n &lt; 0         = rotate (n + length xs) xs 
4	    | n &gt; length xs = rotate (n - length xs) xs 
5	    | otherwise     = (drop n xs) ++ (take n xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs	    
        | n &lt; 0         = rotate (n + length xs) xs 
	    | n &gt; length xs = rotate (n - length xs) xs 
	    | otherwise     = (drop n xs) ++ (take n xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &lt; 0 = rotate xs (n `mod` length xs)
rotate n (x:xs)   = rotate (n-1) (xs ++ [x]) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &lt; 0 = rotate (n `mod` length xs) xs 
rotate n (x:xs)   = rotate (n-1) (xs ++ [x]) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0 = rotate (length xs + n) xs 
rotate n xs | n &gt; (length xs) = rotate (n `mod` (length xs)) xs 
rotate n xs | n &gt;= 0 = (drop n xs) ++ (take n xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0 = rotate (length xs + n) xs 
rotate n xs | n &gt; (length xs) = rotate (n `mod` (length xs)) xs 
rotate n xs | n &gt;= 0 = (drop n xs) ++ (take n xs)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1013067</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
  | n &gt; 0 = rotate (tail xs ++ [head xs]) (n-1)
  | otherwise = rotate (last xs : init xs) (n+1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1823818</div>
<ul class="submissions">
<li class="submission tooltip warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (iterate rotate xs) xs
  where rotate (y:ys) = ys ++ [y]</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = bs ++ as where (as, bs) = splitAt n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length st) $ drop (negate x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = map last init a</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = map last init n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) . drop n . cycle $ xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = myRotate (n-1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = rotate (n-1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0 = rotate xs (n+len)
    | n &gt; len = rotate xs (n-len)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
    | n &lt; 0 = rotate xs (n+len)
    | n &gt; len = rotate xs (n-len)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate xs n = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = [xs]
rotate n xs = xs : rotate (n-1) ((last xs):(init xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
rotate xs n = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate x 0 = x
rotate x y
  | y &gt; 0 = rotate (tail x ++ [head x]) (y-1)
  | otherwise = rotate (last x : init x) (y+1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = bs ++ as where (as, bs) = splitAt n xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n == 0 then xs else zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n 0 = xs
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n 0 = n
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n == 0 then xs else drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate list 0 = list
rotate l@(x:xs) n = rotate (xs ++ [x]) offset
    where offset = if n &gt; 0 then n - 1 else (length l) + n - 1
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rShift :: Int -&gt; [a] -&gt; [a]
 
rShift 0 x = x
rShift _ []= []
rShift 1 (x:xs)= xs ++ [x]
rShift n x = rShift (n-1) (rShift 1 x)
 
 
lShift :: Int -&gt; [a] -&gt; [a]
 
lShift 0 x = x
lShift _ []= []
lShift 1 x=  (last x) : (init x)
lShift n x = lShift (n-1) (lShift 1 x)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rShift :: Int -&gt; [a] -&gt; [a]
 
rShift 0 x = x
rShift _ []= []
rShift 1 (x:xs)= xs ++ [x]
rShift n x = rShift (n-1) (rShift 1 x)
 
 
lShift :: Int -&gt; [a] -&gt; [a]
 
lShift 0 x = x
lShift _ []= []
lShift 1 x=  (last x) : (init x)
lShift n x = lShift (n-1) (lShift 1 x)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
 
rotate 0 xs = xs
rotate n xs | n &gt;= length xs = rotate (n`mod`(length xs)) xs
            | otherwise = rotate&#x27; n xs

rotate&#x27; n xs = let (xh,xt) = splitAt n xs in xt++xh</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
 
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
 
rotate n xs = if n == 0 xs else drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
 
rotate n xs = if n == 0 then xs else drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: [a] -&gt; Int -&gt; [a]
rotate [] _ = []
rotate xs 0 = xs
rotate (x:xs) n 
 | n &gt; 0 = rotate (xs++[x]) (n-1)
 | otherwise = rotate (x:xs) (length (x:xs) + n)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
 
rotate n xs = if n == 0 then xs else drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
 
rotate n xs = if n == 0 then xs else drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n (x:xs) = rotate (n-1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if  n &gt; 0 &amp;&amp; n &lt; length xs then drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate, rotate&#x27;, rotate&#x27;&#x27; :: Int -&gt; [a] -&gt; [a]
rotate n xs =
   Match.take xs (drop (mod n (length xs)) (cycle xs))

rotate&#x27; n xs =
   uncurry (flip (++))
           (splitAt (mod n (length xs)) xs)

rotate&#x27;&#x27; n xs =
   Match.take xs (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import qualified Data.List.Match.Private as Match
rotate, rotate&#x27;, rotate&#x27;&#x27; :: Int -&gt; [a] -&gt; [a]
rotate n xs =
   Match.take xs (drop (mod n (length xs)) (cycle xs))

rotate&#x27; n xs =
   uncurry (flip (++))
           (splitAt (mod n (length xs)) xs)

rotate&#x27;&#x27; n xs =
   Match.take xs (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (negate n `mod` length sx) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = b ++ a
    where n&#x27;     = n `mod` (length xs)
      (a, b) = splitAt ((length xs) - n&#x27;) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =  _ra 0 ((length xs) - 1) (listArray (0, ((length xs) - 1)) xs)
    where _ra s e ys = if (e - s) == 1 
                       then (if ((ys ! s) &amp;lt (ys ! e)) then s else e)  -- base case
                       else let h  = ys ! s                  -- first item
                                l  = ys ! e                  -- last item
                                mi = s + ((e - s) `div` 2)   -- middle index
                                m  = ys ! mi                 -- middle item
                            in if (h &amp;lt l)
                               then s                        -- return start index
                               else if (h &amp;gt m)
                                    then _ra s  mi ys
                                    else _ra mi e  ys</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate xs 0 = xs
rotate (x:xs) (n+1) = rotate (xs ++ [x]) n
rotate xs n = rotate l (length l + n)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate xs n = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0 = rotate xs (n+len)
    | n &gt; len = rotate xs (n-len)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n 
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: [a] -&gt; Int -&gt; [a]
rotate [] _ = []
rotate x 0 = x
rotate x y
  | y &gt; 0 = rotate (tail x ++ [head x]) (y-1)
  | otherwise = rotate (last x : init x) (y+1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate 0 xs = xs
rotate n x
  | n &gt; 0 = rotate (tail xs ++ [head xs]) (n-1)
  | otherwise = rotate (last xs : init xs) (n+1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate 0 xs = xs
rotate n xs
  | n &gt; 0 = rotate (tail xs ++ [head xs]) (n-1)
  | otherwise = rotate (last xs : init xs) (n+1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
  | n &gt; 0 = rotate (tail xs ++ [head xs]) (n-1)
  | otherwise = rotate (last xs : init xs) (n+1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ xs = xs
rotate 0 xs = xs
rotate n xs
  | n &gt; 0 = rotate (tail xs ++ [head xs]) (n-1)
  | otherwise = rotate (last xs : init xs) (n+1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs
  | n &gt; 0 = rotate (tail xs ++ [head xs]) (n-1)
  | otherwise = rotate (last xs : init xs) (n+1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs if n &gt; 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n [] = []
rotate 0 xs = xs
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n [] = []
rotate 0 xs = xs
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n [] = []
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n [] = []
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n [] = []
rotate 0 xs = xs
rotate n xs = if n &lt; 0 then drop length xs ++ take length xstake else (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n [] = []
rotate 0 xs = xs
rotate n xs = if n &lt; 0 then drop length xs ++ take length xs take else (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n [] = []
rotate 0 xs = xs
rotate n xs = if n &lt; 0 then drop (n+length xs) ++ take (n+length xs) else take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n [] = []
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n [] = []
rotate 0 xs = xs
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: [a] -&gt; Int -&gt; [a]
	rotate [] _ = []
	rotate l 0 = l
	rotate l n
	    | abs(n) &gt; len &amp;&amp; n &gt; 0 = rotate l (n - len)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: [a] -&gt; Int -&gt; [a]
	rotate [] _ = []
	rotate l 0 = l
	rotate l n
	    | abs(n) &gt; len &amp;&amp; n &gt; 0 = rotate l (n - len)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: [a] -&gt; Int -&gt; [a]
rotate [] _ = []
rotate l 0 = l
rotate l n
    | abs(n) &gt; len &amp;&amp; n &gt; 0 = rotate l (n - len)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: [a] -&gt; Int -&gt; [a]
rotate [] _ = []
rotate l 0 = l
rotate l n
    | abs(n) &gt; len &amp;&amp; n &gt; 0 = rotate l (n - len)
    | abs(n) &gt; len &amp;&amp; n &lt; 0 = rotate l (n + len)
    | n &lt; 0                 = (drop (len + n) l)++(take (len + n) l)
    | otherwise             = (drop n l)++(take n l)
        where len = length l</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 l = l
rotate n l
    | abs(n) &gt; len &amp;&amp; n &gt; 0 = rotate l (n - len)
    | abs(n) &gt; len &amp;&amp; n &lt; 0 = rotate l (n + len)
    | n &lt; 0                 = (drop (len + n) l)++(take (len + n) l)
    | otherwise             = (drop n l)++(take n l)
        where len = length l</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 l = l
rotate n l
    | abs(n) &gt; len &amp;&amp; n &gt; 0 = rotate l (n - len)
    | abs(n) &gt; len &amp;&amp; n &lt; 0 = rotate l (n + len)
    | n &lt; 0                 = (drop (len + n) l)++(take (len + n) l)
    | otherwise             = (drop l n)++(take l n)
        where len = length l</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 l = l
rotate n l
    | abs(n) &gt; len &amp;&amp; n &gt; 0 = rotate (n - len) l
    | abs(n) &gt; len &amp;&amp; n &lt; 0 = rotate (n + len) l
    | n &lt; 0                 = (drop (len + n) l)++(take (len + n) l)
    | otherwise             = (drop l n)++(take l n)
        where len = length l</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 l = l
rotate n l
    | abs(n) &gt; len &amp;&amp; n &gt; 0 = rotate (n - len) l
    | abs(n) &gt; len &amp;&amp; n &lt; 0 = rotate (n + len) l
    | n &lt; 0                 = (drop (len + n) l)++(take (len + n) l)
    | otherwise             = (drop n l)++(take n l)
        where len = length l</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: [a] -&gt; Int -&gt; [a]
rotate lst n = let k = if n &gt;= 0 then n else length lst + n
                   (xs, ys) = splitAt k lst
               in ys ++ xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n lst = let k = if n &gt;= 0 then n else length lst + n
                   (xs, ys) = splitAt k lst
               in ys ++ xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 lst = lst
rotate n lst = let k = if n &gt;= 0 then n else length lst + n
                   (xs, ys) = splitAt k lst
               in ys ++ xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate n l = case compare n 0 of 
    GT -&gt; if ll &gt; n then drop n l ++ take n l 
                    else rotate (n - ll) l 
    EQ -&gt; l 
    LT -&gt; rotate (n + ll) l  
    where ll = length l </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate xs n
    | n &lt; 0 || n &gt;= l = rotate xs $ n `mod` l
    | otherwise = drop n xs ++ take n xs
    where l = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate xs n
    | n &lt; 0 || n &gt;= l = rotate xs $ n `mod` l
    | otherwise = drop xs n ++ take xs n 
    where l = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate xs n
    | n &lt; 0 || n &gt;= l = rotate n `mod` l $ xs
    | otherwise = drop xs n ++ take xs n 
    where l = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
    | n &lt; 0 || n &gt;= l = rotate n `mod` l $ xs
    | otherwise = drop xs n ++ take xs n 
    where l = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
    | n &lt; 0 || n &gt;= l = rotate (n `mod` l) xs
    | otherwise = drop xs n ++ take xs n 
    where l = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
    | n &lt; 0 || n &gt;= l = rotate (n `mod` l) xs
    | otherwise = drop n xs ++ take n xs 
    where l = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: [a] -&gt; Int -&gt; [a]
	rotate [] _ = []
	rotate l 0 = l
	rotate l n
	    | abs(n) &gt; len &amp;&amp; n &gt; 0 = rotate l (n - len)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n [] = []
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n _ = []
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1908334</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs |n &gt; 0 = (drop n xs) ++ (take n xs)
            |n &lt; 0 = (drop (length xs + n) xs) ++ (take (length xs + n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs |n &gt; 0 = (drop n xs) ++ (take n xs)
            |n &lt; 0 = (drop (length xs + n) xs) ++ (take (length xs + n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs |n &gt; 0 = (drop n xs) ++ (take n xs)
            |n &lt; 0 = (drop (length xs + n) xs) ++ (take (length xs + n) xs)
            |n==0 = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs |n &gt;= 0 = (drop n xs) ++ (take n xs)
            |n &lt; 0 = (drop (length xs + n) xs) ++ (take (length xs + n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n == 0 = xs 
            | n &gt;= (length xs) = rotate xs (mod n (length xs))
            | otherwise = rotate (tail xs) (n-1) ++ [head xs]</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n == 0 = xs 
            | n &gt;= (length xs) = rotate xs (mod n (length xs))
            | otherwise = rotate (tail xs) (n-1) ++ [head xs]</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs |n &gt; 0 = (drop (n `mod` (length xs)) xs) ++ (take (n `mod` (length xs)) xs)
            |n &lt; 0 = (drop (length xs - ((-n) `mod` (length xs))) xs) ++ (take (length xs - ((-n) `mod` (length xs))) xs)
            |n == 0 =  xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take l . drop (n `mod` l) . cycle $ xs
    where l = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate 0 xs = xs
rotate n xs
  | n &gt; 0 = rotate (n-1) (tail xs ++ [head xs]) 
  | otherwise = rotate (n+1) (last xs : init xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (negate x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt; 0 = rotate (n+len) xs
    | n &gt; len = rotate (n-len) xs
    | otherwise = let (f,s) = splitAt n xs in s ++ f
      where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = rotate (n-1) (tail xs ++ [head xs]) 
            | otherwise = rotate (n+1) (last xs : init xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = rotate (n - 1) (tail xs ++ [head xs]) 
            | otherwise = rotate (n +1 ) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = rotate (n - 1) (tail xs ++ [head xs]) 
            | otherwise = rotate (n + 1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n list@(x:xs)
  | n &lt; 0 = rotate (length list + n) list
  | otherwise = rotate (n - 1) (xs ++ [x]) </pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n list@(x:xs)
  | n &lt; 0 = rotate (length list + n) list
  | otherwise = zipWith const (drop n (cycle list)) list</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (mod n (length xs)) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = rotate (n-1) (tail xs ++ hand xs)
            | n &lt; 0 = rotate (n+1) (last xs : init xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = rotate (n-1) (tail xs ++ hend xs)
            | n &lt; 0 = rotate (n+1) (last xs : init xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = rotate (n-1) (tail xs ++ head xs)
            | n &lt; 0 = rotate (n+1) (last xs : init xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = rotate (n-1) (tail (xs) ++ head (xs))
            | n &lt; 0 = rotate (n+1) (last xs : init xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = rotate (n-1) (tail (xs) ++ head (xs))
            | otherwise = rotate (n+1) (last xs : init xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n $ length xs) xs
  | n &gt; 0 = zipWith const (drop n $ cycle xs) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate (length xs - mod (abs n) (length xs)) xs
  | n &lt; 0 = xs
 
notLonger n xs = ((isNonEmpty $ drop n xs) == False)
isNonEmpty [] = False
isNonEmpty (:) = True</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n $ length xs) xs
  | n &gt; 0 = zipWith const (drop n $ cycle xs) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate (length xs - mod (abs n) (length xs)) xs
  | n &lt; 0 = xs
 
notLonger n xs = ((isNonEmpty $ drop n xs) == False)
isNonEmpty [] = False
isNonEmpty (:) = True</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n $ length xs) xs
  | n &gt; 0 = zipWith const (drop n $ cycle xs) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate (length xs - mod (abs n) (length xs)) xs
  | n &lt; 0 = xs
 
notLonger n xs = ((isNonEmpty $ drop n xs) == False)
    where isNonEmpty k | k == [] = False
                       | k == (:) = True</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n (x:xs)
  | n == 0    = (x:xs)
  | n &lt; 0     = rotate (n + length xs) (xs ++ [x])
  | otherwise = rotate (n - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop n $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.Tuple (swap)

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = uncurry (++) . swap $ splitAt break xs


rotate n xs = take (length xs) $ drop n $ cycle xs
   | n &lt; 0 = length xs + n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.Tuple (swap)

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = uncurry (++) . swap $ splitAt break xs
   | n &lt; 0 = length xs + n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n $ length xs) xs
  | n &gt; 0 = zipWith const (drop n $ cycle xs) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate (length xs - mod (abs n) (length xs)) xs
  | n &lt; 0 = xs
 
notLonger n xs = ((isNonEmpty $ drop n xs) == False)
isNonEmpty [] = False
isNonEmpty (:) = True</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = xrotate n xs [] where
  xrotate n xs res          | (null xs) &amp;&amp; (null res) = []
  xrotate n xs res          | (null xs) = xrotate (n `mod` length res) res []
  xrotate n xs res          | n == 0 = xs ++ res
  xrotate n xs res          | n == (-1) = xrotate (n+1) (last xs : res) (init xs)
  xrotate n (x:xs) res      | n &gt; 0 = xrotate (n-1) xs (res ++ [x])
  xrotate n xs res          | n &lt; 0 = xrotate (n+1) (init xs) (last xs : res)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = helper n xs [] where

    helper n xs res       | n == 0 = xs ++ res
    helper n xs res       | n == (-1) = helper (n+1) (last xs : res) (init xs)
    helper n (x : xs) res | n &gt; 0 = helper (n - 1) xs (res ++ [x])
    helper n xs res       | n &lt; 0 = helper (n + 1) (init xs) (last xs : res)
    helper n xs res       | (null xs) &amp;&amp; (null res) = []
    helper n xs res       | (null xs) = helper (n `mod` length res) res []</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = helper n xs [] where
    helper n xs res       | (null xs) &amp;&amp; (null res) = []
    helper n xs res       | (null xs) = helper (n `mod` length res) res []
    helper n xs res       | n == 0 = xs ++ res
    helper n xs res       | n == (-1) = helper (n+1) (last xs : res) (init xs)
    helper n (x : xs) res | n &gt; 0 = helper (n - 1) xs (res ++ [x])
    helper n xs res       | n &lt; 0 = helper (n + 1) (init xs) (last xs : res)
</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = helper n xs [] where
    helper n xs ys       | (null xs) &amp;&amp; (null ys) = []
    helper n xs ys       | (null xs) = helper (n `mod` length ys) ys []
    helper n xs ys       | n == 0 = xs ++ ys
    helper n xs ys       | n == (-1) = helper (n+1) (last xs : ys) (init xs)
    helper n (x : xs) ys | n &gt; 0 = helper (n - 1) xs (ys ++ [x])
    helper n xs ys       | n &lt; 0 = helper (n + 1) (init xs) (last xs : ys)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">495216</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) . drop n . cycle $ xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                where len = n+length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = rotate (n-1) (xs++[x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt; 0 = rotate xs (n+len)
    | n &gt; len = rotate xs (n-len)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs
   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt; 0 = rotate (n+len) xs
    | n &gt; len = rotate (n-len) xs
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs
   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)
   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate x 0 = x
rotate x y
  | y &gt; 0 = rotate (tail x ++ [head x]) (y-1)
  | otherwise = rotate (last x : init x) (y+1)
   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: [a] -&gt; Int -&gt; [a]
rotate [] _ = []
rotate x 0 = x
rotate x y
  | y &gt; 0 = rotate (tail x ++ [head x]) (y-1)
  | otherwise = rotate (last x : init x) (y+1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
    | n == 0    = xs
    | n &lt; 0     = rotate (length xs + n) xs 
    | otherwise = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n $ length xs) xs
  | n &gt; 0 = zipWith const (drop n $ cycle xs) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate (length xs - mod (abs n) (length xs)) xs
  | n &lt; 0 = xs
 
notLonger n xs = ((isNonEmpty $ drop n xs) == False)
isNonEmpty [] = False
isNonEmpty (:) = True</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n $ length xs) xs
  | n &gt; 0 = zipWith const (drop n $ cycle xs) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate (length xs - mod (abs n) (length xs)) xs
  | n &lt; 0 = xs
 
notLonger n xs = ((isNonEmpty $ drop n xs) == False)
isNonEmpty [] = False
isNonEmpty (:) = True</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n $ length xs) xs
  | n &gt; 0 = zipWith const (drop n $ cycle xs) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate (length xs - mod (abs n) (length xs)) xs
  | n &lt; 0 = xs
 
notLonger n xs = ((isNonEmpty $ drop n xs) == False)
isNonEmpty [] = False
</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]

rotate n xs = xrotate n xs [] where
  xrotate n xs res          | (null xs) &amp;&amp; (null res) = []
  xrotate n xs res          | (null xs) = xrotate (n `mod` length res) res []
  xrotate n xs res          | n == 0 = xs ++ res
  xrotate n xs res          | n == (-1) = xrotate (n+1) (last xs : res) (init xs)
  xrotate n (x:xs) res      | n &gt; 0 = xrotate (n-1) xs (res ++ [x])
  xrotate n xs res          | n &lt; 0 = xrotate (n+1) (init xs) (last xs : res)
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">155780</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []= [] 
rotate n xs | n==0 = xs
			| n&gt;0  =(drop k xs) ++ (take k xs)
            | otherwise  =(drop m xs) ++ (take m xs)
             where p=length xs
                   k=mod (abs(n)) p
                   m=p-k     </pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs </pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n==0 = xs
			| n&gt;0 = zipWith const (drop (mod  n p) (cycle xs)) xs
			| n&lt;0 = zipWith const (drop (p- (mod (-n) p)) (cycle xs)) xs
		where p=length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n==0 = xs
			| n&gt;0 = zipWith const (drop (mod  n p) (cycle xs)) xs
			| n&lt;0 = zipWith const (drop (p- (mod (-n) p)) (cycle xs)) xs
		where p=length xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">150406</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate 0 xs = xs
rotate n xs = helper (n `mod` (length xs)) xs
helper n xs = if (n &gt; 0) then ((drop n xs) ++ (take n xs))
	else ((take n xs) ++ (drop n xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate 0 xs = xs
rotate n xs = helper (n `mod` (length xs)) xs
helper 0 xs = xs
helper n xs = if (n &gt; 0) then ((drop n xs) ++ (take n xs))
	else ((take n xs) ++ (drop n xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate 0 xs = xs
rotate n xs = if n &gt; length xs then rotate (n `mod` (length xs)) xs 
	else if (n &gt; 0) then ((drop n xs) ++ (take n xs))
	else ((take n xs) ++ (drop n xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if n &gt; length xs then rotate (n `mod` (length xs)) xs 
	else if (n &gt; 0) then ((drop n xs) ++ (take n xs))
	else ((take n xs) ++ (drop n xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = helper (n `mod` (length xs)) xs 
helper 0 xs = xs
helper n xs = if (n &gt; 0) then ((drop n xs) ++ (take n xs)) 
	else ((take n xs) ++ (drop n xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate xs n = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n == 0 = xs 
           | n &gt; 0  = rotate (tail xs ++ [head xs]) (n-1)
           | n &lt; 0  = rotate (last xs : init xs) (n+1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n == 0 = xs 
           | n &gt; 0  = rotate (n-1) (tail xs ++ [head xs]) 
           | n &lt; 0  = rotate (n+1) (last xs : init xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = repaste (n mySplit (x:xs))
  where
    repaste (x, y) = y ++ x</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | null xs   = xs
    | n &lt; 0     = rotateL (-n) xs 
    | otherwise = rotateR n xs 

rotateL 0 xs = xs
rotateL n xs = rotateL (n - 1) (last xs : init xs) 

rotateR 0 xs     = xs
rotateR n (x:ys)  = rotateR (n - 1) (ys ++ [x]) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | (n &gt; length xs) || (n &lt; 0) = rotate (n `mod` length xs) xs 
            | otherwise = (drop n xs) ++ (take n xs)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1910767</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = bs ++ as where (as, bs) = splitAt n xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate (n-1) (last xs : init xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n l = drop n l  ++ take n l
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>shift :: [a] -&gt; Int -&gt; [a]
shift l n = drop n l  ++ take n l

rotateN 0 lst = lst
rotateN n lst = rotateN (n-1) ((last lst):(init lst))

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt; 0 then (shift xs n) else rotateN (-n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>shift :: [a] -&gt; Int -&gt; [a]
shift l n = drop n l  ++ take n l

rotateN 0 lst = lst
rotateN n lst = rotateN (n-1) ((last lst):(init lst))

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then (shift xs n) else rotateN (-n) xs

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>shift :: [a] -&gt; Int -&gt; [a]
shift l n = drop n l  ++ take n l

rotateN 0 lst = lst
rotateN n lst = rotateN (n-1) ((last lst):(init lst))

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then (shift xs n) else rotateN (-n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>shift :: [a] -&gt; Int -&gt; [a]
shift l n = drop n l  ++ take n l

rotateN 0 lst = lst
rotateN n lst = rotateN (n-1) ((last lst):(init lst))

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then (shift xs n) else rotateN (-n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length st) $ drop (negate x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop (n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 = rotate (tail x ++ [head x]) (y-1)
  | otherwise = rotate (last x : init x) (y+1)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; [] _ = []
rotate&#x27; l 0 = l
rotate&#x27; (x:xs) (n+1) = rotate&#x27; (xs ++ [x]) n
rotate&#x27; l n = rotate&#x27; l (length l + n)

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; xs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; :: [a] -&gt; Int -&gt; [a]
rotate&#x27; [] _ = []
rotate&#x27; x 0 = x
rotate&#x27; x y
  | y &gt; 0 = rotate&#x27; (tail x ++ [head x]) (y-1)
  | otherwise = rotate&#x27; (last x : init x) (y+1)


rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; xs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; xs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; xs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n
    | n &lt;= 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &gt; 0 = (drop (negate n) xs) ++ (take (negate n) xs)

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; xs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; xs (negate n)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n
    | n &lt; 0 = rotate&#x27; xs (n+len)
    | n &gt; len = rotate&#x27; xs (n-len)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; xs (negate n)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n
    | n &lt; 0 = rotate&#x27; xs (n+len)
    | n &gt; len = rotate&#x27; xs (n-len)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; xs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
rotate&#x27; xs n = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; xs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
rotate&#x27; xs n = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; xs (negate n)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; xs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; xs (negate n)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n = take (length xs) $ drop (length xs + n) $ cycle xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; xs (negate n)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n = take (length xs) $ drop (length xs + n) $ cycle xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; xs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; xs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop (n `mod` length xs) $ cycle xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop (n `mod` length xs) $ cycle xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n
    | n &lt; 0 = rotate&#x27; xs (n+len)
    | n &gt; len = rotate&#x27; xs (n-len)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
--rotate n xs = take (length xs) $ drop (n `mod` length xs) $ cycle xs
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
rotate n xs = rotate&#x27; xs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; xs n
    | n &lt; 0 = rotate&#x27; xs (n `mod` length xs)
    | n &gt; len = rotate&#x27; xs (n `mod` length xs)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
--rotate n xs = take (length xs) $ drop (n `mod` length xs) $ cycle xs
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
rotate n xs = rotate&#x27; xs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = bs ++ as where (as, bs) = splitAt (n `mod` length xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; :: [a] -&gt; Int -&gt; [a]
rotate&#x27; [] _ = []
rotate&#x27; x 0 = x
rotate&#x27; x y
  | y &gt; 0 = rotate&#x27; (tail x ++ [head x]) (y-1)
  | otherwise = rotate&#x27; (last x : init x) (y+1)

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; xs (n `mod` length xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = bs ++ as where (as, bs) = splitAt (n `mod` length xs) xs
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">301936</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate l 0 = l
rotate (x:xs) (n+1) = rotate (xs ++ [x]) n
rotate l n = rotate l (length l + n)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: a -&gt; [a] -&gt; [a]
rotate xs n = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &gt; 0 = (reverse . take xs . reverse $ n) ++ (reverse . drop xs . reverse $ n)
    | n &lt;= 0 = (drop (negate xs) n) ++ (take (negate xs) n)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: [a] -&gt; Int -&gt; [a]
rotate [] _ = []
rotate x 0 = x
rotate x y
  | y &gt; 0 = rotate (tail x ++ [head x]) (y-1)
  | otherwise = rotate (last x : init x) (y+1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate x 0 = x
rotate x y
  | y &gt; 0 = rotate (tail x ++ [head x]) (y-1)
  | otherwise = rotate (last x : init x) (y+1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | xs &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
rotate xs n = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
rotate xs n = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
rotate n xs = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | xs &gt;= 0 = drop xs nn ++ take xs n
            | xs &lt; 0 = drop len n ++ take len n
                      where len = xs+length n
rotate n xs = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt; 0 = rotate xs (n+len)
    | n &gt; len = rotate xs (n-len)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | xs &lt; 0 = rotate xs (n+len)
    | n &gt; len = rotate xs (n-len)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | xs &lt; 0 = rotate xs (n+len)
    | xs &gt; len = rotate xs (n-len)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs - n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs - n) $ cycle n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  zipWith const (drop n (cycle xs)) xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">152495</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = rotate (n-1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = rotate&#x27; (n mod (length xs))



rotate&#x27; n xs = zipWith const (drop n (cycle xs)) xs

length xs = let length&#x27; n [] = n
                length&#x27; n (x:xs) = length&#x27; (n+1) xs
            in  length&#x27; 0 xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = rotate&#x27; (n mod (length xs))



rotate&#x27; n xs = zipWith const (drop n (cycle xs)) xs

</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = rotate&#x27; (n mod (length xs)) xs



rotate&#x27; n xs = zipWith const (drop n (cycle xs)) xs

</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1055156</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; n xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail rotate&#x27; (shift - 1)) ++ (head rotate&#x27; (shift - 1) list):[]
      | shist &lt; 0 = (last rotate&#x27; (shift - 1) list):[] ++ (init rotate&#x27; (shift - 1))
   shift = n `mod` length n
   list = n
   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; n xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail rotate&#x27; (shift - 1)) ++ (head rotate&#x27; (shift - 1) list):[]
      | shist &lt; 0 = (last rotate&#x27; (shift - 1) list):[] ++ (init rotate&#x27; (shift - 1))
         shift = n `mod` length n
         list = n
   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; n xs where
   shift = n `mod` length n
   list = n
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail rotate&#x27; (shift - 1)) ++ (head rotate&#x27; (shift - 1) list):[]
      | shist &lt; 0 = (last rotate&#x27; (shift - 1) list):[] ++ (init rotate&#x27; (shift - 1))
         
   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; n xs where
   let shift = n `mod` length n
       list = n
       in
    rotate&#x27; 0 list = list
    rotate&#x27; shift list 
      | shift &gt; 0 = (tail rotate&#x27; (shift - 1)) ++ (head rotate&#x27; (shift - 1) list):[]
      | shist &lt; 0 = (last rotate&#x27; (shift - 1) list):[] ++ (init rotate&#x27; (shift - 1))
         
   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; n xs where
    rotate&#x27; 0 list = list
    rotate&#x27; shift list 
      | shift &gt; 0 = (tail rotate&#x27; (shift - 1)) ++ (head rotate&#x27; (shift - 1) list):[]
      | shist &lt; 0 = (last rotate&#x27; (shift - 1) list):[] ++ (init rotate&#x27; (shift - 1)) where
          shift = n `mod` length n
          list = n
         
   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; n xs where
    rotate&#x27; 0 list = list
    rotate&#x27; shift list 
      | shift &gt; 0 = (tail rotate&#x27; (shift - 1)) ++ (head rotate&#x27; (shift - 1) list):[]
      | shift &lt; 0 = (last rotate&#x27; (shift - 1) list):[] ++ (init rotate&#x27; (shift - 1))
          shift = n `mod` length n
          list = n
         
   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; n xs where
    rotate&#x27; 0 list = list
    rotate&#x27; shift list 
      | shift &gt; 0 = (tail rotate&#x27; (shift - 1)) ++ (head rotate&#x27; (shift - 1) list):[]
      | shift &lt; 0 = (last rotate&#x27; (shift - 1) list):[] ++ (init rotate&#x27; (shift - 1))
    shift = n `mod` length n
    list = n
         
   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; n xs where
    rotate&#x27; 0 list = list
    rotate&#x27; shift list 
      | shift &gt; 0 = (tail rotate&#x27; (shift - 1) list) ++ (head rotate&#x27; (shift - 1) list):[]
      | shift &lt; 0 = (last rotate&#x27; (shift - 1) list):[] ++ (init rotate&#x27; (shift - 1) list)
    shift = n `mod` length n
    list = n
         
   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; n xs where
    rotate&#x27; 0 list = list
    rotate&#x27; shift list 
      | shift &gt; 0 = (tail rotate&#x27; (shift - 1) list) ++ (head rotate&#x27; (shift - 1) list):[]
      | shift &lt; 0 = (last rotate&#x27; (shift - 1) list):[] ++ (init rotate&#x27; (shift - 1) list)
    shift = n `mod` length n
    list = n
         
   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rot (n `mod` (length xs)) xs xs where
   rot 0 ini acc = acc
   rot sft ini acc 
      | shift &gt; 0 = rot (sft - 1) ini (tail acc ++ (head acc):[])
      | shift &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rot (n `mod` (length xs)) xs xs where
   rot 0 ini acc = acc
   rot sft ini acc 
      | sft &gt; 0 = rot (sft - 1) ini (tail acc ++ (head acc):[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rot (n `mod` (length xs)) xs xs where
   rot 0 ini acc = acc
   rot sft ini (x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rot (n `mod` (length xs)) xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (drop n (cycle xs)) xs
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = bs ++ as where (as, bs) = splitAt n xs
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (negate x `mod` length st) $ cycle st
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
   | n &gt;= 0 = drop n xs ++ take n xs
   | n &lt; 0 = rotate&#x27; (n `mod` (length xs)) xs where
      rotate&#x27; 0 list = list
      rotate&#x27; shift list = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))
   
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs
{-rotate n xs
   | n &gt;= 0 = drop n xs ++ take n xs
   | n &lt; 0 = rotate&#x27; (n `mod` (length xs)) xs where
      rotate&#x27; 0 list = list
      rotate&#x27; shift list = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))
   -}
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
   | n &gt;= 0 = zipWith const (drop n (cycle xs)) xs -- drop n xs ++ take n xs
   | n &lt; 0 = rotate&#x27; (n `mod` (length xs)) xs where
      rotate&#x27; 0 list = list
      rotate&#x27; shift list = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))
   
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x n
  | n == 0 = x 
  | n &gt;= (length x) = rotate x (mod n (length x))
  | otherwise = rotate (tail x) (n-1) ++ [head x]
--zipWith const (drop n (cycle xs)) xs -- drop n xs ++ take n xs

   
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n x
  | n == 0 = x 
  | n &gt;= (length x) = rotate x (mod n (length x))
  | otherwise = rotate (tail x) (n-1) ++ [head x]
--zipWith const (drop n (cycle xs)) xs -- drop n xs ++ take n xs

   
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n x
  | n == 0 = x 
  | n &gt;= (length x) = rotate (mod n (length x)) x
  | otherwise = rotate (n-1) (tail x)  ++ [head x]
--zipWith const (drop n (cycle xs)) xs -- drop n xs ++ take n xs

   
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x])
  | otherwise = rotate (y+1) (last x : init x)
--zipWith const (drop n (cycle xs)) xs -- drop n xs ++ take n xs

   
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt; 0 = rotate (n+len) xs
    | n &gt; len = rotate (n-len) xs
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs
--zipWith const (drop n (cycle xs)) xs -- drop n xs ++ take n xs

   
{- rotate n xs = rot n xs xs where
   rot 0 ini acc = acc
   rot sft ini acc@(x:xs) 
      | sft &gt; 0 = rot (sft - 1) ini ( xs ++ x:[])
      | sft &lt; 0 = rot (sft - 1) ini ((last acc):[] ++ init acc)
-}

{-
rotate n xs = rotate&#x27; (n `mod` (length xs)) xs where
   rotate&#x27; 0 list = list
   rotate&#x27; shift list 
      | shift &gt; 0 = (tail (rotate&#x27; (shift - 1) list)) ++ (head (rotate&#x27; (shift - 1) list)):[]
      | shift &lt; 0 = last (rotate&#x27; (shift - 1) list):[] ++ (init (rotate&#x27; (shift - 1) list))

-}</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2070199</div>
<ul class="submissions">
<li class="submission tooltip warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l | n &gt;= 0 = init (zipWith (++) (tails l) (inits l)) !! (n `mod` (length l))
	   | n &lt; 0 = init (zipWith (++) (tails l) (inits l)) !! (((length l)+n )`mod` (length l))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn" title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate n l | n &gt;= 0 = init (zipWith (++) (tails l) (inits l)) !! (n `mod` (length l))
	   | n &lt; 0 = init (zipWith (++) (tails l) (inits l)) !! (((length l)+n )`mod` (length l))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn" title="<code><pre>module Demo where
import Data.List

shift :: [a] -&gt; [a]
shift [] = []
shift (x:xs) = xs ++ [x]

allR&#x27;:: [a] -&gt; [[a]]	  	  
allR&#x27; l = init (zipWith (++) (tails l) (inits l))

allR :: [a] -&gt; [[a]]
allR l = take (length l) (iterate shift l)

rotate :: Int -&gt; [a] -&gt; [a]
rotate n l | n &gt;= 0 = (allR l) !! (n `mod` (length l))
	   | n &lt; 0 = (allR l) !! (((length l) + n ) `mod` (length l))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn" title="<code><pre>import Data.List

shift :: [a] -&gt; [a]
shift [] = []
shift (x:xs) = xs ++ [x]

allR&#x27;:: [a] -&gt; [[a]]	  	  
allR&#x27; l = init (zipWith (++) (tails l) (inits l))

allR :: [a] -&gt; [[a]]
allR l = take (length l) (iterate shift l)

rotate :: Int -&gt; [a] -&gt; [a]
rotate n l | n &gt;= 0 = (allR l) !! (n `mod` (length l))
	   | n &lt; 0 = (allR l) !! (((length l) + n ) `mod` (length l))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate x st = take (length st) $ drop (negate x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List

allR xs  = ((tail . take (length xs) . map (take (length xs)) . tails . cycle) xs)

rotate :: Int -&gt; [a] -&gt; [a]
rotate n l | n &gt;= 0 = (allR l) !! ((n `mod` (length l))-1)
	   | n &lt; 0 = (allR l) !! ((((length l) + n ) `mod` (length l))-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List

allR xs  = ((tail . take (length xs) . map (take (length xs)) . tails . cycle) xs)

rotate :: Int -&gt; [a] -&gt; [a]
rotate n l | n &gt;= 0 = (allR l) !! (((n-1) `mod` (length l)))
	   | n &lt; 0 = (allR l) !! ((((length l) + n -1) `mod` (length l)))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n (x:xs)
	| n &gt; 0 = rotate (mod (n-1) (length (x:xs))) (xs++[x]) 
	| otherwise = rotate (mod (length (x:xs) + n) (length (x:xs))) (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  
   | n &gt;= 0    = drop n xs ++ take n xs
   | otherwise = reverse (rotate (-n) reversedList)
       where reversedList = reverse xs </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>split&#x27;&#x27; :: [a] -&gt; Int -&gt; ([a], [a])
split&#x27;&#x27; []       _ = ([], [])
split&#x27;&#x27; l@(x:xs) n
  | n &gt; 0          = (x : ys, zs)
  | otherwise      = ([], l)
  where
    (ys,zs) = split&#x27;&#x27; xs (n-1)

rotate&#x27;&#x27; :: [a] -&gt; Int -&gt; [a]
rotate&#x27;&#x27; lst n 
   | n &gt;= 0 = second ++ first
   | otherwise = rotate&#x27;&#x27; lst (n + length lst)
   where (first, second) = split&#x27;&#x27; lst nsplit&#x27;&#x27; :: [a] -&gt; Int -&gt; ([a], [a])
split&#x27;&#x27; []       _ = ([], [])
split&#x27;&#x27; l@(x:xs) n
  | n &gt; 0          = (x : ys, zs)
  | otherwise      = ([], l)
  where
    (ys,zs) = split&#x27;&#x27; xs (n-1)

rotate&#x27;&#x27; :: [a] -&gt; Int -&gt; [a]
rotate&#x27;&#x27; lst n 
   | n &gt;= 0 = second ++ first
   | otherwise = rotate&#x27;&#x27; lst (n + length lst)
   where (first, second) = split&#x27;&#x27; lst n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>split&#x27;&#x27; :: [a] -&gt; Int -&gt; ([a], [a])
split&#x27;&#x27; []       _ = ([], [])
split&#x27;&#x27; l@(x:xs) n
  | n &gt; 0          = (x : ys, zs)
  | otherwise      = ([], l)
  where
    (ys,zs) = split&#x27;&#x27; xs (n-1)

rotate :: Int -&gt; [a] -&gt; [a]
rotate n lst 
   | n &gt;= 0 = second ++ first
   | otherwise = rotate (n + length lst) lst 
   where (first, second) = split&#x27;&#x27; lst n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>split&#x27;&#x27; :: [a] -&gt; Int -&gt; ([a], [a])
split&#x27;&#x27; []       _ = ([], [])
split&#x27;&#x27; l@(x:xs) n
  | n &gt; 0          = (x : ys, zs)
  | otherwise      = ([], l)
  where
    (ys,zs) = split&#x27;&#x27; xs (mod (n-1) (length l))

rotate :: Int -&gt; [a] -&gt; [a]
rotate n lst 
   | n &gt;= 0 = second ++ first
   | otherwise = rotate (mod (n + length lst)(length lst)) lst 
   where (first, second) = split&#x27;&#x27; lst n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate n x =
   Match.take x (drop (mod n (length x)) (cycle x))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import qualified Data.List.Match.Private as Match
rotate n x =
   Match.take x (drop (mod n (length x)) (cycle x))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; n x =
   uncurry (flip (++))
           (splitAt (mod n (length x)) x)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate n x =
   uncurry (flip (++))
           (splitAt (mod n (length x)) x)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs  = xs
rotate n xs 
  | n &gt; 0 = let m = n `mod` len in drop m xs ++ take m xs
  | otherwise = rotate (len + n) xs 
  where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) . drop n . cycle $ xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop (mod n (length xs)) (cycle xs))</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2155448</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n&gt;0 = take (length xs) (drop n (cycle xs))
            | otherwise = take (length xs) (drop (n + length xs) (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rot :: Int -&gt; [a] -&gt; [a]
rot _ [] = []
rot n xs | n&gt;=0      = zipWith const (drop n (cycle xs)) xs
         | otherwise = zipWith const (drop (n+length xs) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;=0      = zipWith const (drop n (cycle xs)) xs
         | otherwise = zipWith const (drop (n+length xs) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;=0      = zipWith const (drop n (cycle xs)) xs
            | otherwise = zipWith const (drop (n+length xs) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n&gt;=0 = (drop n xs) ++ (take n xs)
            | otherwise = (drop (n+length xs) xs) ++ (take (n+length xs) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;=0      = zipWith const (drop n (cycle xs)) xs
            | otherwise = zipWith const (drop (n+length xs) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;=0      = zipWith const (drop (mod n $ length xs) (cycle xs)) xs
            | otherwise = zipWith const (drop ((mod n $ length xs)+length xs) (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;=0      = zipWith const (drop (mod n $ length xs) (cycle xs)) xs
            | otherwise = zipWith const (drop ((mod n $ length xs) + length xs) (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;=0      = zipWith const (drop n (cycle xs)) xs
            | otherwise = zipWith const (drop (n + length xs) (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = rotate (n-1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;=0      = zipWith const (drop r (cycle xs)) xs
            | otherwise = zipWith const (drop (r + length xs) (cycle xs)) xs
  where r = mod n $ length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n&gt;=0      = (drop n xs) ++ (take n xs)
            | otherwise = (drop (n+length xs) xs) ++ (take (n+length xs) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n&gt;=0      = (drop n xs) ++ (take n xs)
            | otherwise = (drop (n+length xs) xs) ++ (take (n+length xs) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;=0      = zipWith const (drop n (cycle xs)) xs
            | otherwise = zipWith const (drop (n + length xs) (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;=0      = zipWith const ((drop n xs) ++ (take n xs)) xs
            | otherwise = zipWith const ((drop (n + length xs) xs) ++ (take (n + length xs) xs)) xs

</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;=0      = zipWith const (drop n (cycle xs)) xs
            | otherwise = zipWith const (drop (n + length xs) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
            | n &lt; 0 = zipWith const (drop (n + length xs) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 =
                zipWith const (drop n (cycle xs)) xs
            | n &lt; 0 =
                let l = length xs
                    nn = n `rem` l in
                zipWith const (drop (nn + length xs) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 =
                zipWith const (drop n (cycle xs)) xs
            | n &lt; 0 =
                let l = length xs
                    nn = n `rem` l in
                zipWith const (drop (nn + l) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 =
                zipWith const (drop n $ cycle xs) xs
            | n &lt; 0 =
                let l = length xs
                    nn = n `rem` l in
                zipWith const (drop (nn + l) $ cycle xs) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">180410</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined
--rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined
--rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
rotate n xs = iterate rotate&#x27; xs !! n
  where rotate&#x27; xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined
--rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = iterate rotate&#x27; xs !! n
--  where rotate&#x27; xs = last xs : init xs
rotate n xs = bs ++ as where (as, bs) = splitAt n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

--rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs

--rotate n xs = take (length xs) (drop n (cycle xs))

--rotate n xs = iterate rotate&#x27; xs !! n
--  where rotate&#x27; xs = last xs : init xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs

rotate 0 xs = xs
rotate n xs = rotate (n-1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

--rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs

--rotate n xs = take (length xs) (drop n (cycle xs))

--rotate n xs = iterate rotate&#x27; xs !! n
--  where rotate&#x27; xs = last xs : init xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs

rotate _ [] = []
rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs

--rotate n xs = take (length xs) (drop n (cycle xs))

--rotate n xs = iterate rotate&#x27; xs !! n
--  where rotate&#x27; xs = last xs : init xs

rotate n xs = bs ++ as where (as, bs) = splitAt n xs

--rotate _ [] = []
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs

--rotate n xs = take (length xs) (drop n (cycle xs))

--rotate n xs = iterate rotate&#x27; xs !! n
--  where rotate&#x27; xs = last xs : init xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs

--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs

rotate n xs = take (length xs) (drop n (cycle xs))

--rotate n xs = iterate rotate&#x27; xs !! n
--  where rotate&#x27; xs = last xs : init xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs

--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs

--rotate n xs = take (length xs) (drop n (cycle xs))

rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs

--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs

--rotate n xs = take (length xs) (drop n (cycle xs))

--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs

rotate n xs = bs ++ as where (as, bs) = splitAt n xs

--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined
--rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
rotate n xs = zipWith (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate _ [] = []</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate _ [] = []</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
--rotate _ [] = []

rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
--rotate _ [] = []

rotate n xs = if n &gt;= 0 then drop n xs ++ take n xs else drop k xs ++ take k xs where k = length xs + n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate _ [] = []
rotate n xs = if n &gt;= 0 then drop n xs ++ take n xs else drop k xs ++ take k xs where k = length xs + n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate _ [] = []
--rotate n xs = if n &gt;= 0 then drop n xs ++ take n xs else drop k xs ++ take k xs where k = length xs + n
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate _ [] = []
--rotate n xs = if n &gt;= 0 then drop n xs ++ take n xs else drop k xs ++ take k xs where k = length xs + n
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
rotate n xs = (last x) : (take (length xs - 1) x)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate n xs = undefined

--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate _ [] = []
--rotate n xs = if n &gt;= 0 then drop n xs ++ take n xs else drop k xs ++ take k xs where k = length xs + n
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs | n &gt;= 0 drop n xs ++ take n xs 
            | n &lt; 0  drop k xs ++ take k xs where k = length xs + n

{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs | n &gt;= 0 = drop n xs ++ take n xs 
            | n &lt; 0  = drop k xs ++ take k xs where k = length xs + n

{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs | n == 0 = xs
            | n &gt; 0  = drop n xs ++ take n xs 
            | n &lt; 0  = drop k xs ++ take k xs where k = length xs + n

{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs | n == 0 = xs
            | n &gt; 0  = drop n xs ++ take n xs 
            | n &lt; 0  = drop k xs ++ take k xs where k = (length xs + n)

{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs | n == 0 = xs
            | n &gt; 0  = drop g xs ++ take g xs where g = mod n (length xs) 
            | n &lt; 0  = drop k xs ++ take k xs where k = (mod (length xs + n) (length xs))

{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs | n &gt; 0  = drop g xs ++ take g xs where g = mod n (length xs) 
            | n &lt; 0  = drop k xs ++ take k xs where k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs | n &gt; 0 = drop g xs ++ take g xs where g = mod n (length xs) 
            | n &lt; 0 = drop k xs ++ take k xs where k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then drop g xs ++ take g xs where g = mod n (length xs) else drop k xs ++ take k xs where k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then drop g xs ++ take g xs 
        where g = mod n (length xs) 
        else drop k xs ++ take k xs 
        where k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then drop g xs ++ take g xs where g = mod n (length xs) 
        else drop k xs ++ take k xs where k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then drop g xs ++ take g xs where g = mod n (length xs) 
       else drop k xs ++ take k xs where k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then drop g xs ++ take g xs where 
        g = mod n (length xs) 
        else drop k xs ++ take k xs where 
        k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs 
    | n &gt; 0  = drop g xs ++ take g xs where g = mod n (length xs) 
    | n &lt; 0  = drop k xs ++ take k xs where k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs 
        | n &gt; 0  = drop g xs ++ take g xs 
          where g = mod n (length xs) 
        | n &lt; 0  = drop k xs ++ take k xs 
          where k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs 
  | n &gt; 0  = drop g xs ++ take g xs 
        where g = mod n (length xs) 
  | n &lt; 0  = drop k xs ++ take k xs 
        where k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs 
        | n &gt; 0  = drop g xs ++ take g xs 
        where g = mod n (length xs) 
        | n &lt; 0  = drop k xs ++ take k xs 
        where k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs 
        | n &gt; 0  = drop g xs ++ take g xs where 
          g = mod n (length xs) 
        | n &lt; 0  = drop k xs ++ take k xs where
          k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs 
     | n &gt; 0  = drop g xs ++ take g xs where 
          g = mod n (length xs) 
     | n &lt; 0  = drop k xs ++ take k xs where
          k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs 
    | n &gt; 0  = drop g xs ++ take g xs where 
          g = mod n (length xs) 
    | n &lt; 0  = drop k xs ++ take k xs where
          k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs 
   | n &gt; 0  = drop g xs ++ take g xs where 
          g = mod n (length xs) 
   | n &lt; 0  = drop k xs ++ take k xs where
          k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs 
  | n &gt; 0  = drop g xs ++ take g xs where 
          g = mod n (length xs) 
  | n &lt; 0  = drop k xs ++ take k xs where
          k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs | n &gt; 0 = drop g xs ++ take g xs where 
               g = mod n (length xs) 
            | n &lt; 0  = drop k xs ++ take k xs where
               k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs | n &gt; 0 = drop g xs ++ take g xs where g = mod n (length xs) 
            | n &lt; 0  = drop k xs ++ take k xs where k = (mod (length xs + n) (length xs))
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs | n &gt; 0 = drop (mod n (length xs)) xs ++ take (mod n (length xs)) xs
            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))


--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs = zipWith const (drop n (cycle xs)) xs
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate 0 xs = xs
{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))

--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
{--
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = zipWith const (drop n (cycle xs)) xs where
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))

rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop n (cycle xs)) xs where
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--}
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = iterate rotate&#x27; xs !! k where 
        k = mod n (length xs)
        rotate&#x27; xs = last xs : init xs

--rotate n xs = iterate (last xs : init xs) !! n
{--
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop n (cycle xs)) xs where
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--}
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = head xs : tail xs
        

--rotate n xs = iterate (last xs : init xs) !! n
{--
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop n (cycle xs)) xs where
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--}
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
        

--rotate n xs = iterate (last xs : init xs) !! n
{--
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop n (cycle xs)) xs where
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--}
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
{--
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
--}     
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
{--
--rotate n xs = take (length xs) (drop n (cycle xs))
--rotate n xs = take (length xs) . drop n . cycle $ xs
--}
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
{--
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
--}     
--rotate n xs = iterate (last xs : init xs) !! n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}        
--rotate n xs = take (length xs) . drop n . cycle $ xs

{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
--} 

rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}        
--rotate n xs = take (length xs) . drop n . cycle $ xs

{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
--} 

rotate n xs = bs ++ as where (as, bs) = splitAt k xs where
        k = if n &lt; 0 then mod (length xs + n) (length xs) else mod n (length xs)

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}        
--rotate n xs = take (length xs) . drop n . cycle $ xs

{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
--} 

rotate n xs = bs ++ as where (as, bs) = splitAt k xs where k = if n &lt; 0 then mod (length xs + n) (length xs) else mod n (length xs)

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}        
--rotate n xs = take (length xs) . drop n . cycle $ xs

{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
--} 

rotate n xs = bs ++ as where (as, bs) = splitAt k xs where k = if n &lt; 0 then length xs + n else n

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}        
--rotate n xs = take (length xs) . drop n . cycle $ xs

{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
--} 

rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) 
--}
--rotate n xs = (last xs) : (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}        
--rotate n xs = take (length xs) . drop n . cycle $ xs
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
--} 
--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
--}
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}        
--rotate n xs = take (length xs) . drop n . cycle $ xs
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
--} 
--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
--}
rotate n (x:xs) 
 | n &gt; 0 = rotate (k-1) (xs++[x])
 | n &lt; 0 = rotate (length (x:xs) + k) (x:xs) 
 where k = mod n (length xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}        
--rotate n xs = take (length xs) . drop n . cycle $ xs
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
--} 
--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
--}
rotate n (x:xs) 
 | n &gt; 0 = rotate (k-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + k) (x:xs) 
 where k = mod n (length xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}        
--rotate n xs = take (length xs) . drop n . cycle $ xs
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
--} 
--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
--}
rotate n (x:xs) 
 | n &gt; 0 = rotate (k-1) (xs++[x]) where k = mod n (length xs)
 | otherwise = rotate (length (x:xs) + n) (x:xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}        
--rotate n xs = take (length xs) . drop n . cycle $ xs
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
--} 
--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = drop (helper n xs) xs ++ take (helper n xs) xs
        where helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n xs = take (length xs) . drop (helper n xs). cycle $ xs where 
        helper n xs = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--            | n &lt; 0 = drop (mod (length xs + n) (length xs)) xs ++ take (mod (length xs + n) (length xs)) xs
--}
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}        
--rotate n xs = take (length xs) . drop n . cycle $ xs
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs
--} 
--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

--}
rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
{--
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}        
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n

--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}
--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = b ++ a where 
      n&#x27; = mod n (length  xs)
      (a, b) = splitAt ((length  xs) -  n&#x27;) xs 
      
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}
--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = b ++ a where 
      n&#x27; = mod n (length  xs)
      l = length xs
      (a, b) = if n &gt; 0 then splitAt (l - n&#x27;) xs else splitAt (l + n&#x27;) xs 
      
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}
--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = b ++ a where 
      n&#x27; = mod n (length  xs)
      l = length xs
      (a, b) = if n &gt; 0 then splitAt (l - n&#x27;) xs else splitAt n&#x27; xs 
      
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}
--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = b ++ a where 
      n&#x27; = mod n (length  xs)
      l = length xs
      (a, b) = if n &gt; 0 then splitAt n&#x27; xs else splitAt l - n&#x27; xs 
      
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}
--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = b ++ a where 
      n&#x27; = mod n (length  xs)
      l = length xs
      (a, b) = if n &gt; 0 then splitAt n&#x27; xs else splitAt (l - n&#x27;) xs 
      
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}
--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = b ++ a where 
      n&#x27; = mod n (length  xs)
      l = length xs
      (a, b) = if n &gt; 0 then splitAt n&#x27; xs else splitAt (l - n&#x27;) xs 
      
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}
--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = b ++ a where 
      n&#x27; = mod n (length  xs)
      l = length xs
      (a, b) = if n&#x27; &gt; 0 then splitAt n&#x27; xs else if n&#x27; == 0 then xs else splitAt (l - n&#x27;) xs 
      
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}
--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = b ++ a where 
      n&#x27; = mod n (length  xs)
      l = length xs
      (a, b) = if n&#x27; &gt; 0 then splitAt n&#x27; xs else splitAt (l - n&#x27;) xs 
      
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}
--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = b ++ a where 
      n&#x27; = mod n (length  xs)
      l = length xs
      (a, b) = if n &gt; 0 then splitAt n&#x27; xs else splitAt (l - n&#x27;) xs 
      
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}
--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate n xs = b ++ a where 
      n&#x27; = mod n (length  xs)
      l = length xs
      (a, b) = splitAt n&#x27; xs   
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
--}
--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate n xs = b ++ a where 
      l = length xs
      n&#x27; = mod n l
      (a, b) = splitAt n&#x27; xs   
{--
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
--}
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = mod n (length xs))

{--
--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = b ++ a where 
      l = length xs
      n&#x27; = mod n l
      (a, b) = splitAt n&#x27; xs   

--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
--}
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = mod n (length xs)

{--
--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
{--
rotate n xs = b ++ a where 
      l = length xs
      n&#x27; = mod n l
      (a, b) = splitAt n&#x27; xs   

--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop k (cycle xs)) xs where
        k = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))        
--}
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = mod n (length xs)

{--
--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate n xs = b ++ a where 
      l = length xs
      n&#x27; = mod n l
      (a, b) = splitAt n&#x27; xs   

--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs

rotate n xs = zipWith const (drop n&#x27; (cycle xs)) xs where
        n&#x27; = mod n (length xs)
{--
rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = mod n (length xs)


--rotate n xs = b ++ a where (a, b) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = b ++ a where (a, b) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
rotate n xs = b ++ a where 
      l = length xs
      n&#x27; = mod n l
      (a, b) = splitAt n&#x27; xs   

--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = if n &gt; 0 then iterate rotate&#x27; xs !! k else iterate rotate&#x27;&#x27; xs !! k where 
        k           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
        rotate&#x27;&#x27; xs = tail xs : head xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop n&#x27; (cycle xs)) xs where
        n&#x27; = mod n (length xs)

rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = mod n (length xs)

rotate n xs = b ++ a where 
      l = length xs
      n&#x27; = mod n l
      (a, b) = splitAt n&#x27; xs   
--}
--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = iterate rotate&#x27; xs !! n&#x27; where 
        n&#x27;           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs
{--
--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = if n &gt; 0 then (mod n (length xs)) else (mod (length xs + n) (length xs))
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop n&#x27; (cycle xs)) xs where
        n&#x27; = mod n (length xs)

rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = mod n (length xs)

rotate n xs = b ++ a where 
      l = length xs
      n&#x27; = mod n l
      (a, b) = splitAt n&#x27; xs   

--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = iterate rotate&#x27; xs !! n&#x27; where 
        n&#x27;           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
--}
rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = mod n (length xs)
{--
rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
{--
rotate n xs = zipWith const (drop n&#x27; (cycle xs)) xs where
        n&#x27; = mod n (length xs)

rotate n xs = take (length xs) . drop n&#x27; . cycle $ xs
        where n&#x27; = mod n (length xs)

rotate n xs = b ++ a where 
      l = length xs
      n&#x27; = mod n l
      (a, b) = splitAt n&#x27; xs   

--rotate n xs = iterate rotate&#x27; xs !! n where rotate&#x27; xs = last xs : init xs
rotate n xs = iterate rotate&#x27; xs !! n&#x27; where 
        n&#x27;           = mod n (length xs)
        rotate&#x27; xs  = last xs : init xs

--rotate n xs = bs ++ as where (as, bs) = splitAt n&#x27; xs where n&#x27; = if n &lt; 0 then length xs + n else n
--rotate n xs = bs ++ as where (as, bs) = splitAt n xs
--rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs

rotate n xs = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = mod n (length xs)

rotate n (x:xs) 
 | n &gt; 0 = rotate ((mod n (length (x:xs))) - 1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)
 --}
 
rotate n xs | n &gt;= 0     = rotateRight n xs
            | otherwise  = rotateLeft (-n) xs
    where
      len = length xs
      rotateLeft n xs | null suff = rotateLeft (n `mod` len) xs
                      | otherwise = drop (len - n) xs ++ (take (len - n) xs)
        where suff = drop (abs n) xs
 
      rotateRight n xs | null suff = rotateRight (n `mod` len) xs
                       | otherwise = drop n xs ++ (take n xs)
        where suff = drop (abs n) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1826753</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs = map (takeSame xs) $ takeSame xs (tails (xs ++ xs)) where
    takeSame [] _ = [] 
    takeSame (_:xs) (y:ys) = y:takeSame xs ys</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs = map (takeSame xs) $ takeSame xs (tail (xs ++ xs)) where
    takeSame [] _ = [] 
    takeSame (_:xs) (y:ys) = y:takeSame xs ys</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = bs ++ as where 
    (as, bs) = splitAt n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (mod n (length xs)) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (mod n (length xs)) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if mod n (length xs) == 0 then xs else zipWith const (drop (mod n (length xs)) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt; length xs then rotate (mod n (length xs)) xs else zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if abs n &gt; length xs then rotate (mod n (length xs)) xs else zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (mod n (length xs)) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (mod n (length xs)) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (mod n (length xs)) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = zipWith const (drop (mod n (length xs)) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if abs n &gt; lxs then rotate lxs xs else  zipWith const (drop n (cycle xs)) xs where
    lxs = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if abs n &gt; lxs then rotate lxs xs else  zipWith const (drop n (cycle xs)) xs where
    lxs = mod n (length xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if abs n &gt; lxs then if n &lt; 0 then rotate (-1) * mod (abs n) lxs xs else zipWith const (drop n (cycle xs)) xs where
    lxs = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if abs n &gt; lxs then if n &lt; 0 then rotate (-1) * mod (abs n) lxs xs else zipWith const (drop n (cycle xs)) xs else zipWith const (drop n (cycle xs)) xs where
    lxs = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if abs n &gt; lxs then if n &lt; 0 then rotate ((-1) * (mod (abs n) lxs)) xs else zipWith const (drop n (cycle xs)) xs else zipWith const (drop n (cycle xs)) xs where
    lxs = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if abs n &gt; lxs then if n &lt; 0 then rotate ((-1) * (mod (abs n) lxs)) xs else rotate (mod n lxs) xs else zipWith const (drop n (cycle xs)) xs where
    lxs = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = zipWith const (drop rot (cycle xs)) xs where
    rot = if n &lt; 0 then (-1) * (mod (abs n) length xs) else mod n (length xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = zipWith const (drop rot (cycle xs)) xs where
    rot = if abs n &gt; lxs then if n &lt; 0 then (-1) * (mod (abs n) lxs) else mod n (lxs) else n where
        lxs = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if abs n &gt; length xs then zipWith const (drop rot (cycle xs)) xs else zipWith const (drop n (cycle xs)) xs where
    rot = if n &lt; 0 then (-1) * (mod (abs n) length xs) else mod n (length xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = zipWith const (drop rot (cycle xs)) xs where
    rot = if n &lt; 0 then (-1) * (mod (abs n) length xs) else mod n (length xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if abs n &gt; lxs then if n &lt; 0 then rotate ((-1) * (mod (abs n) lxs)) xs else rotate (mod n lxs) xs else zipWith const (drop n (cycle xs)) xs where
    lxs = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = zipWith const (drop n (cycle xs)) xs where
    lxs = length xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">766411</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = bs ++ as where (as, bs) = splitAt n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (negate x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (negate x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (n `mod` length xs) (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
rotate n xs = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt; 0 = rotate xs (n+len)
    | n &gt; len = rotate xs (n-len)
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt; 0 = rotate (n+len) xs
    | n &gt; len = rotate (n-len) xs
    | otherwise = let (f,s) = splitAt n xs in s ++ f
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate :: [a] -&gt; Int -&gt; [a]
rotate [] _ = []
rotate 0 x = x
rotate y x
  | y &gt; 0 = rotate  (y-1) (tail x ++ [head x])
  | otherwise = rotate (y+1) (last x : init x) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] _ = []
rotate 0 x = x
rotate y x
  | y &gt; 0 = rotate  (y-1) (tail x ++ [head x])
  | otherwise = rotate (y+1) (last x : init x) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 = rotate  (y-1) (tail x ++ [head x])
  | otherwise = rotate (y+1) (last x : init x) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (negate n) (cycle xs)) xs

</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n (x:xs) = rotate (n-1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n st@(x:xs) 
		| n &gt; 1000 = take (length st) $ drop (n `mod` length st) $ cycle st
		| otherwise = rotate (n-1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y st@x
	| y &gt; 1000 = take (length st) $ drop (y `mod` length st) $ cycle st
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import qualified Data.List as L
rotate :: Int -&gt; [a] -&gt; [a]
rotate n ls = let (first, rest) = L.splitAt n ls in rest ++ first
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n (x:xs) = rotate (n-1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n st@(x:xs) 
		| n &gt; 10000 = take (length st) $ drop (n `mod` length st) $ cycle st
		| otherwise = rotate (n-1) (xs ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n st@(x:xs) 
		| n &gt; 100000 = take (length st) $ drop (n `mod` length st) $ cycle st
		| otherwise = rotate (n-1) (xs ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n st@(x:xs) 
		| n &gt; 1000000 = take (length st) $ drop (n `mod` length st) $ cycle st
		| otherwise = rotate (n-1) (xs ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n st@(x:xs) 
		| n &gt; 10000000 = take (length st) $ drop (n `mod` length st) $ cycle st
		| otherwise = rotate (n-1) (xs ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n st@(x:xs) 
		| n &gt; 100000000 = take (length st) $ drop (n `mod` length st) $ cycle st
		| otherwise = rotate (n-1) (xs ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n st@(x:xs) 
		| n &gt; 1000000000 = take (length st) $ drop (n `mod` length st) $ cycle st
		| otherwise = rotate (n-1) (xs ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n st@(x:xs) 
		| n &gt; 10000000000 = take (length st) $ drop (n `mod` length st) $ cycle st
		| otherwise = rotate (n-1) (xs ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y st@x
	| y &gt; 100000 = take (length st) $ drop (y `mod` length st) $ cycle st
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y st@x
	| y &gt; 1000000 = take (length st) $ drop (y `mod` length st) $ cycle st
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y st@x
	| y &gt; 10000000 = take (length st) $ drop (y `mod` length st) $ cycle st
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y st@x
	| y &gt; 100000000 = take (length st) $ drop (y `mod` length st) $ cycle st
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y st@x
	| y &gt; 1000000000 = take (length st) $ drop (y `mod` length st) $ cycle st
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y st@x
	| y &gt; 10000 = take (length st) $ drop (y `mod` length st) $ cycle st
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y st@x
	| y &gt; 1000 = take (length st) $ drop (y `mod` length st) $ cycle st
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y st@x
	| y &gt; 100 = take (length st) $ drop (y `mod` length st) $ cycle st
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y st@x
	| y &gt; 10 = take (length st) $ drop (y `mod` length st) $ cycle st
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y st@x
	| y &gt; 1000000000 = take (length st) $ drop (y `mod` length st) $ cycle st
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y st@x
	| y &gt; 10000000000 = take (length st) $ drop (y `mod` length st) $ cycle st
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate y st@x
	| y &gt; 1000000000 = take (length st) $ drop (y `mod` length st) $ cycle st
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate n xs
    | n &gt; 0 = drop n xs ++ take n xs
    -- | n &lt;= 0 = drop (negate n) xs ++ take (negate n) xs
   | n &lt;= 0 = (reverse . take (negate n) . reverse $ xs) ++ (reverse . drop (negate n) . reverse $ xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate _ [] = []
rotate n xs
    | n &gt; 0 = drop n xs ++ take n xs
    -- | n &lt;= 0 = drop (negate n) xs ++ take (negate n) xs
   | n &lt;= 0 = (reverse . take (negate n) . reverse $ xs) ++ (reverse . drop (negate n) . reverse $ xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate _ [] = []
rotate n xs
	| abs n &gt; 100000 = zipWith const (drop n (cycle xs)) xs
    | n &gt; 0 = drop n xs ++ take n xs
    -- | n &lt;= 0 = drop (negate n) xs ++ take (negate n) xs
   | n &lt;= 0 = (reverse . take (negate n) . reverse $ xs) ++ (reverse . drop (negate n) . reverse $ xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate _ [] = []
rotate n xs
    | abs n &gt; 100000  &amp;&amp; n &gt; 0 = drop n xs ++ take n xs
    -- | n &lt;= 0 = drop (negate n) xs ++ take (negate n) xs
   | n &lt;= 0 = (reverse . take (negate n) . reverse $ xs) ++ (reverse . drop (negate n) . reverse $ xs)
   | otherwise = zipWith const (drop n (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate _ [] = []
rotate n xs
    | abs n &gt; 100000 = drop n xs ++ take n xs
    -- | n &lt;= 0 = drop (negate n) xs ++ take (negate n) xs
   | n &lt;= 0 = (reverse . take (negate n) . reverse $ xs) ++ (reverse . drop (negate n) . reverse $ xs)
   | otherwise = zipWith const (drop n (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	| otherwise = reverse (zipWith const (drop n (cycle xs)) xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	| otherwise = zipWith (const id )(drop (negate n) ( cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
	-- | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	| n&gt;0 = bs ++ as 
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)
	where (as, bs) = splitAt n xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
	-- | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	| n&gt;0 = (drop (negate n) xs) ++ (take (negate n) xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
		| n&gt;100000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
		| abs n&gt;100000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
		| abs n&gt;10000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
		| abs n&gt;1000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
		| n&gt;1000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
		| n&gt;100000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
		|  (abs n)&gt;100000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
		-- | n&gt;100000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
		|  (abs n)&gt;100000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
		-- | n&gt;100000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
		|  (abs n)&gt;10000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
		-- | n&gt;100000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
		|  (abs n)&gt;1000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
		-- | n&gt;100000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
		|  (abs n)&gt;100 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
		-- | n&gt;100000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
		|  (abs n)&gt;100000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
		-- | n&gt;100000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
		|  (abs n)&gt;1000000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
		-- | n&gt;100000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
		|  (abs n)&gt;10000000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	-- | n&gt;0 = (drop n xs) ++ (take n xs)
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
	|  (abs n)&gt;10000000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
	|  (abs n)&gt;10000000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
--	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)

</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
	|  (abs n)&gt;10000000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)

</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1933517</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n (x:xs) | n &lt; 0		= rotate&#x27; ((n + 1 + length xs) - 1) xs [x] 
				| n == 0	= [x] ++ xs
				| otherwise	= rotate&#x27; (n - 1) xs [x]  where
				
	rotate&#x27; :: Int -&gt;[a] -&gt; [a]-&gt;[a]
	rotate&#x27; 0 (x:xs) xf = [x] ++ xs ++ xf
	rotate&#x27; n (x:xs) xf = rotate&#x27; (n - 1) xs (xf ++ [x]) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n (x:xs) | n &lt; 0		= rotate&#x27; ((n + 1 + length xs) - 1) xs [x] 
				| n == 0	= [x] ++ xs
				| otherwise	= rotate&#x27; (n - 1) xs [x]  where
				
	rotate&#x27; :: Int -&gt;[a] -&gt; [a]-&gt;[a]
	rotate&#x27; 0 (x:xs) xf = [x] ++ xs ++ xf
	rotate&#x27; n (x:xs) xf = rotate&#x27; (n - 1) xs (xf ++ [x]) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n (x:xs) | n &lt; 0		= rotate&#x27; ((n + 1 + length xs) - 1) xs [x] 
				| n == 0	=  xs
				| otherwise	= rotate&#x27; (n - 1) xs [x]  where
				
	rotate&#x27; :: Int -&gt;[a] -&gt; [a]-&gt;[a]
	rotate&#x27; 0 (x:xs) xf = [x] ++ xs ++ xf
	rotate&#x27; n (x:xs) xf = rotate&#x27; (n - 1) xs (xf ++ [x]) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []  = []
rotate n x 
    | n &gt;= 0 = drop n x ++ take n x
    | otherwise = let nn = (length x) + n in drop nn x ++ take nn x </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n x 
    | n &gt;= 0 = drop n x ++ take n x
    | otherwise = let nn = (length x) + n in drop nn x ++ take nn x </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []  = []
rotate _ [x] = [x]
rotate n x 
    | n &gt;= 0 = drop n x ++ take n x
    | otherwise = let nn = (length x) + n in drop nn x ++ take nn x </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []  = []
rotate _ [x] = [x]
rotate n []  = []
rotate 0 xs  = xs

rotate n x 
    | n &gt; 0 = drop n x ++ take n x
    | n &lt; 0 = let nn = (length x) + n in drop nn x ++ take nn x </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt;[a] -&gt; [a]
rotate _ []= []
rotate _ [x] = [x]
rotate n xs 
  | n &lt; 0 = rotate ((length xs) + n) xs 
  | length xs &gt;= n = (drop n xs) ++ (take n xs)
  | otherwise = xs

rotate&#x27;::Int -&gt;[a] -&gt;[a]
rotate&#x27; _ [] = []
rotate&#x27; 0 xs  = xs
rotate&#x27; n (x:xs) 
  | n &lt; 0 = rotate ((length (x:xs)) + n) (x:xs) 
  | length (x:xs) &gt;= n =  rotate (n - 1) (xs ++ [x]) 
  | otherwise = (x:xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt;[a] -&gt; [a]
rotate _ []= []
rotate _ [x] = [x]
rotate n xs 
  | n &lt; 0 = rotate ((length xs) + n) xs 
  | length xs &gt;= n = (drop n xs) ++ (take n xs)
  | otherwise = xs

rotate&#x27;::Int -&gt;[a] -&gt;[a]
rotate&#x27; _ [] = []
rotate&#x27; 0 xs  = xs
rotate&#x27; n (x:xs) 
  | n &lt; 0 = rotate ((length (x:xs)) + n) (x:xs) 
  | length (x:xs) &gt; n =  rotate (n - 1) (xs ++ [x]) 
  | otherwise = (x:xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt;[a] -&gt; [a]
rotate _ []= []
rotate _ [x] = [x]
rotate n xs = if n == 0 then xs else rotate (n-1) (last xs:init xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt;[a] -&gt; [a]
rotate _ []= []
rotate _ [x] = [x]
rotate n xs 
  | n &lt; 0 = rotate ((length xs) + n) xs 
  | length xs &gt;= n = (drop n xs) ++ (take n xs)
  | otherwise = xs

rotate&#x27;::Int -&gt;[a] -&gt;[a]
rotate&#x27; 0 xs  = xs
rotate&#x27; n (x:xs) 
  | n &lt; 0 = rotate ((length (x:xs)) + n) (x:xs) 
  | length (x:xs) &gt; n =  rotate (n - 1) (xs ++ [x]) 
  | otherwise = (x:xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt;[a] -&gt; [a]
rotate _ []= []
rotate _ [x] = [x]
rotate n xs 
  | n &lt; 0 = rotate ((length xs) + n) xs 
  | length xs &gt;= n = (drop n xs) ++ (take n xs)
  | otherwise = xs

rotate&#x27;::Int -&gt;[a] -&gt;[a]
rotate&#x27; 0 xs  = xs
rotate&#x27; n (x:xs) 
  | n &lt; 0 = rotate ((length (x:xs)) + n) (x:xs) 
  | length (x:xs) &gt; n =  rotate (n - 1) (xs ++ [x]) 
  | otherwise = (x:xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt;[a] -&gt; [a]
rotate _ []= []
rotate _ [x] = [x]
rotate n xs 
  | n &lt; 0 = rotate ((length xs) + n) xs 
  | length xs &gt;= n = (drop n xs) ++ (take n xs)
  | n == 0 = xs

rotate&#x27;::Int -&gt;[a] -&gt;[a]
rotate&#x27; 0 xs  = xs
rotate&#x27; n (x:xs) 
  | n &lt; 0 = rotate ((length (x:xs)) + n) (x:xs) 
  | length (x:xs) &gt; n =  rotate (n - 1) (xs ++ [x]) 
  | otherwise = (x:xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  
    | n == 0 = xs
    | n &gt; 0 = drop n xs ++ take n xs
    | n &lt; 0 = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = length xs + n

rotate&#x27; :: Int -&gt; [a] -&gt; [a]
rotate&#x27; n xs  
    | n == 0 = xs
    | n &lt; 0 = rotate&#x27; (length xs + n) xs  
rotate&#x27; n (x:xs)  = rotate&#x27; (n-1)(xs ++ [x]) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []= []
rotate _ [x] = [x]

rotate n xs  
    | n == 0 = xs
    | n &gt; 0 = drop n xs ++ take n xs
    | n &lt; 0 = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = length xs + n

rotate&#x27; :: Int -&gt; [a] -&gt; [a]
rotate&#x27; n xs  
    | n == 0 = xs
    | n &lt; 0 = rotate&#x27; (length xs + n) xs  
rotate&#x27; n (x:xs)  = rotate&#x27; (n-1)(xs ++ [x]) </pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []= []
rotate _ xs = xs

rotate n xs  
    | n &gt; 0 = drop n xs ++ take n xs
    | n &lt; 0 = drop n&#x27; xs ++ take n&#x27; xs
        where n&#x27; = length xs + n

rotate&#x27; :: Int -&gt; [a] -&gt; [a]
rotate&#x27; n xs  
    | n == 0 = xs
    | n &lt; 0 = rotate&#x27; (length xs + n) xs  
rotate&#x27; n (x:xs)  = rotate&#x27; (n-1)(xs ++ [x]) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = rotate&#x27; n xs [] 
            | n == 0 = xs
            | otherwise = rotate&#x27; (length xs + n) xs [] 
			
rotate&#x27; :: Int -&gt; [a] -&gt;[a] -&gt; [a] 
rotate&#x27; 0 xs ys = xs ++ reverse ys
rotate&#x27; _ [] ys  = reverse ys
rotate&#x27; n (x:xs) ys = rotate&#x27; (n - 1) xs (x:ys) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
 rotate n xs = rotate&#x27; n xs [] where
  rotate&#x27; n xs res    | n == 0 = xs ++ res
  rotate&#x27; n (x:xs) res| n &gt; 0 = rotate&#x27; (n-1) xs (res ++ [x])
  rotate&#x27; n xs res    | n &lt; 0 = rotate&#x27; (n+1) (init xs) (last xs : res)
  rotate&#x27; n xs res    | (null xs) &amp;&amp; (null res) = []
  rotate&#x27; n xs res    | (null xs) = rotate&#x27; (n `mod` length res) res []  
  </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
 rotate n xs = rotate&#x27; n xs [] where
  rotate&#x27; n xs res    | n == 0 = xs ++ res
  rotate&#x27; n (x:xs) res| n &gt; 0 = rotate&#x27; (n-1) xs (res ++ [x])
  rotate&#x27; n xs res    | n &lt; 0 = rotate&#x27; (n+1) (init xs) (last xs : res)
  rotate&#x27; n xs res    | (null xs) &amp;&amp; (null res) = []
  rotate&#x27; n xs res    | (null xs) = rotate&#x27; (n `mod` length res) res []  
  </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; n xs [] where
  rotate&#x27; n xs res    | n == 0 = xs ++ res
  rotate&#x27; n (x:xs) res| n &gt; 0 = rotate&#x27; (n-1) xs (res ++ [x])
  rotate&#x27; n xs res    | n &lt; 0 = rotate&#x27; (n+1) (init xs) (last xs : res)
  rotate&#x27; n xs res    | (null xs) &amp;&amp; (null res) = []
  rotate&#x27; n xs res    | (null xs) = rotate&#x27; (n `mod` length res) res []  
  </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = rotate&#x27; n xs [] where
  rotate&#x27; n xs res    | n == 0 = xs ++ res
  rotate&#x27; n (x:xs) res| n &gt; 0 = rotate&#x27; (n-1) xs (res ++ [x])
  rotate&#x27; n xs res    | n &lt; 0 = rotate&#x27; (n+1) (init xs) (last xs : res)
  rotate&#x27; n xs res    | (null xs) &amp;&amp; (null res) = []
  rotate&#x27; n xs res    | (null xs) = rotate&#x27; (n `mod` length res) res []  
  rotate&#x27; n xs res    | n == (-1) = rotate&#x27; (n+1) (last xs : res) (init xs)
  </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = rotate&#x27; n xs [] where
  rotate&#x27; n xs res    | n == 0 = xs ++ res
  rotate&#x27; n (x:xs) res| n &gt; 0 = rotate&#x27; (n-1) xs (res ++ [x])
  rotate&#x27; n xs res    | n &lt; 0 = rotate&#x27; (n+1) (init xs) (last xs : res)
  rotate&#x27; n xs res    | (null xs) &amp;&amp; (null res) = []
  rotate&#x27; n xs res    | (null xs) = rotate&#x27; (n `mod` length res) res []  
  rotate&#x27; n xs res    | n == (-1) = rotate&#x27; (n+1) (last xs : res) (init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; n xs [] where
  rotate&#x27; n (x:xs) res| n &gt; 0 = rotate&#x27; (n-1) xs (res ++ [x])
  rotate&#x27; n xs res    | n &lt; 0 = rotate&#x27; (n+1) (init xs) (last xs : res)
  rotate&#x27; n xs res    | (null xs) &amp;&amp; (null res) = []
  rotate&#x27; n xs res    | (null xs) = rotate&#x27; (n `mod` length res) res []  
  rotate&#x27; n xs res    | n == (-1) = rotate&#x27; (n+1) (last xs : res) (init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; n xs [] where
  rotate&#x27; n xs res    | n == 0 = xs ++ res
  rotate&#x27; n (x:xs) res| n &gt; 0 = rotate&#x27; (n-1) xs (res ++ [x])
  rotate&#x27; n xs res    | n &lt; 0 = rotate&#x27; (n+1) (init xs) (last xs : res)
  rotate&#x27; n xs res    | (null xs) &amp;&amp; (null res) = []
  rotate&#x27; n xs res    | (null xs) = rotate&#x27; (n `mod` length res) res []  
  rotate&#x27; n xs res    | n == (-1) = rotate&#x27; (n+1) (last xs : res) (init xs)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1885134</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []        = []
rotate 0 xs        = xs
rotate n xs | n &lt; 0 = rotate (n `mod` length xs) xs 
rotate n (x:xs)     = rotate (n-1) (xs ++ [x]) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []        = []
rotate 0 xs        = xs
rotate n xs | n &lt; 0 = rotate (n `mod` length xs) xs 
rotate n (x:xs)     = rotate (n-1) (xs ++ [x]) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []        = []
rotate n xs@(h:t)
        |n == 0 = xs
        |abs(n)&gt;(length xs) &amp;&amp; mod n (length xs)  == 0 = xs
        |n&gt;0    = rotate (n-1) (t ++ [h])
        |n&lt;0    = rotate (n+1) (last xs : init xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = (drop (length xs - n&#x27;) xs) ++ (take (length xs - n&#x27;) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = (drop (length xs - n&#x27;) xs) ++ (take (length xs - n&#x27;) xs)
  where
    n&#x27; = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []        = []
rotate n xs@(h:t)
        |n == 0 = xs
        |abs(n)&gt;(length xs) &amp;&amp; mod n (length xs)  == 0 = xs
        |n&gt;0    = rotate (n-1) (t ++ [h])
        |n&lt;0    = rotate (n+1) (last xs : init xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n $ length xs) xs
  | n &gt; 0 = zipWith const (drop n $ cycle xs) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate (length xs - mod (abs n) (length xs)) xs
  | n &lt; 0 = xs

notLonger n xs = ((isNonEmpty $ drop n xs) == False)
isNonEmpty [] = False
isNonEmpty (:) = True</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n $ length xs) xs
  | n &gt; 0 = zipWith const (drop n $ cycle xs) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate (length xs - mod (abs n) (length xs)) xs
  | n &lt; 0 = xs

notLonger n xs = ((isNonEmpty $ drop n xs) == False)
isNonEmpty [] = False
isNonEmpty (:) = True</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n $ length xs) xs
  | n &gt; 0 = zipWith const (drop n $ cycle xs) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate (length xs - mod (abs n) (length xs)) xs
  | n &lt; 0 = xs

notLonger n xs = ((isNonEmpty $ drop n xs) == False)
isNonEmpty [] = False
isNonEmpty (:) = True</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n $ length xs) xs
  | n &gt; 0 = zipWith const (drop n $ cycle xs) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate (length xs - mod (abs n) (length xs)) xs
  | n &lt; 0 = xs

notLonger n xs = ((isNonEmpty $ drop n xs) == False)
isNonEmpty [] = False
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">490193</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = bs ++ as where (as, bs) = splitAt (n `mod` length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (negate x `mod` length xs) $ cycle xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1373906</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = bs ++ as
            | n &lt; 0 = reverse (ras ++ rbs) 
                where (as, bs) = splitAt n xs
                      (rbs, ras) = splitAt (-n) (reverse xs)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2131150</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then drop n xs ++ take n xs else let l = ((length xs) + n) in drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = if n &lt; 0 then let l = ((length xs) + n) in drop l xs ++ take l xs else (if n &gt;= 0 &amp; n &lt; length xs then drop n xs ++ take n xs else xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = if n &lt; 0 then let l = ((length xs) + n) in drop l xs ++ take l xs else (if n &gt;= 0 &amp;&amp; n &lt; length xs then drop n xs ++ take n xs else xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &lt; 0 then let l = ((length xs) + n) in drop l xs ++ take l xs else (if n &gt;= 0 &amp; n &lt; length xs then drop n xs ++ take n xs else xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &lt; 0 then let l = ((length xs) + n) in drop l xs ++ take l xs else (if n &gt;= 0 &amp;&amp; n &lt; length xs then drop n xs ++ take n xs else xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0  = drop len xs ++ take len xs
                            where len = n+length xs
rotate n xs = drop nn xs ++ take nn xs
                  where nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = rotate (tail xs ++ [head xs]) (n - 1)
            | otherwise = rotate (last xs : init xs) (n + 1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = rotate (n - 1) (tail xs ++ [head xs])
            | otherwise = rotate (n + 1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 &amp;&amp; n &lt; length xs       = rotate (n - 1) (tail xs ++ [head xs])
            | n &lt; 0 &amp;&amp; n &lt; abs (length xs) = rotate (n + 1) (last xs : init xs)
            | otherwise = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 &amp;&amp; n &lt; length xs       = rotate (n - 1) (tail xs ++ [head xs])
            | n &lt; 0 &amp;&amp; n &lt; abs (length xs) = rotate (n + 1) (last xs : init xs)
            | otherwise                    = drop nn xs ++ take nn xs where nn = `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 &amp;&amp; n &lt; length xs       = rotate (n - 1) (tail xs ++ [head xs])
            | n &lt; 0 &amp;&amp; n &lt; abs (length xs) = rotate (n + 1) (last xs : init xs)
            | otherwise                    = drop nn xs ++ take nn xs where nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &lt; 0 then let l = ((length xs) + n) in drop l xs ++ take l xs else (if n &gt;= 0 &amp;&amp; n &lt; length xs then drop n xs ++ take n xs else xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0                  = let l = ((length xs) + n) in drop l xs ++ take l xs
            | n &gt;= 0 &amp; n &lt; length xs = drop n xs ++ take n xs
			|otherwise xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0                  = let l = ((length xs) + n) in drop l xs ++ take l xs
            | n &gt;= 0 &amp; n &lt; length xs = drop n xs ++ take n xs
			|otherwise               = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0                  = let l = ((length xs) + n) in drop l xs ++ take l xs
            | n &gt;= 0 &amp;&amp; n &lt; length xs = drop n xs ++ take n xs
			|otherwise               = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0 &amp;&amp; abs n &lt; length xs = let l = ((length xs) + n) in drop l xs ++ take l xs
            | n &gt;= 0 &amp;&amp; n &lt; length xs    = drop n xs ++ take n xs
			|otherwise                   = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0 &amp;&amp; abs n &lt; length xs = let l = ((length xs) + n) in drop l xs ++ take l xs
            | n &gt;= 0 &amp;&amp; n &lt; length xs    = drop n xs ++ take n xs
			| n &lt; 0 &amp;&amp; abs n &gt; lenght xs = let l = ((length xs) + nn) in drop l xs ++ take l xs where nn = n `mod` lenght xs
			| n &gt; 0 &amp;&amp; abs n &gt; length xs = drop nn xs ++ take nn xs where nn = n `mod` lenght xs
			| otherwise                  = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
            | n &lt; 0 &amp;&amp; abs n &lt; length xs = let l = ((length xs) + n) in drop l xs ++ take l xs
            | n &gt;= 0 &amp;&amp; n &lt; length xs    = drop n xs ++ take n xs
			| n &lt; 0 &amp;&amp; abs n &gt; lenght xs = let l = ((length xs) + nn) in drop l xs ++ take l xs where nn = n `mod` lenght xs
			| n &gt; 0 &amp;&amp; abs n &gt; length xs = drop nn xs ++ take nn xs where nn = n `mod` lenght xs
			| otherwise                  = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0  = drop len xs ++ take len xs
                          where len = n + length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0  = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
            | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then drop nn xs ++ take nn xs else let l = ((length xs) + nn) in drop l xs ++ take l xs where nn = n               `mod` lenght xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then drop nn xs ++ take nn xs else let l = ((length xs) + nn) in drop l xs ++ take l xs where nn = n               `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt;= 0 then drop nn xs ++ take nn xs else let l = ((length xs) + nn) in drop l xs ++ take l xs where nn = n               `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if n &gt;= 0 then drop nn xs ++ take nn xs else let l = ((length xs) + nn) in drop l xs ++ take l xs where nn = n               `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = if n &gt;= 0 then drop nn xs ++ take nn xs else let l = ((length xs) + nn) in drop l xs ++ take l xs where nn = n               `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0     = rotate ((n `mod` length xs) - 1) (tail x ++ [head x])
            | otherwise = rotate ((n `mod` length xs) + 1) (last x : init x)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0     = rotate ((n `mod` length xs) - 1) (tail xs ++ [head xs])
            | otherwise = rotate ((n `mod` length xs) + 1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | abs n == length xs  = xs
            | n &gt;= 0              = drop nn xs ++ take nn xs
            |otherwise            = let l = ((length xs) + nn) in drop l xs ++ take l xs
                                              where nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | abs n == length xs  = xs
            | n &gt;= 0              = drop nn xs ++ take nn xs
            | otherwise           = let l = ((length xs) + nn) in drop l xs ++ take l xs
                                              where nn = n `mod` length xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">127197</div>
<ul class="submissions">
<li class="submission tooltip verybad bad warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt; 0 = helper (mod n $ length xs) xs
            | n &lt; 0 = reverse $ helper (mod (-n) $ length xs) (reverse xs)
            where helper n xs = zipWith const (drop n (cycle xs)) xs
    </pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt; 0 = helper (mod n $ length xs) xs
            | n &lt; 0 = reverse $ helper (mod (-n) $ length xs) (reverse xs)
            where   helper _ [] = []
                    helper n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt; 0 = helper (mod n $ length xs) xs
            | n &lt; 0 = reverse $ helper (mod (-n) $ length xs) (reverse xs)
            | n == 0 = xs
            where   helper _ [] = []
                    helper _ [x] = [x]
                    helper 0 xs = xs
                    helper n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt;= 0 = helper (mod n $ length xs) xs
            | n &lt; 0 = reverse $ helper (mod (-n) $ length xs) (reverse xs)
            where   helper _ [] = []
                    helper _ [x] = [x]
                    helper 0 xs = xs
                    helper n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt;= 0 = helper (mod n $ length xs) xs
            | n &lt; 0 = reverse $ helper (mod (-n) $ length xs) (reverse xs)
            where   helper _ [] = []
                    helper _ [x] = [x]
                    helper 0 xs = xs
                    helper n xs = bs ++ as where (as, bs) = splitAt n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt; 0 = helper (mod n $ length xs) xs
            | n &lt; 0 = reverse $ helper (mod (-n) $ length xs) (reverse xs)
            | n == 0 = xs
            where   helper _ [] = []
                    helper _ [x] = [x]
                    helper 0 xs = xs
                    helper n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt;= 0 = helper (mod n $ length xs) xs
            | n &lt; 0 = reverse $ helper (mod (-n) $ length xs) (reverse xs)
            where   helper _ [] = []
                    helper 0 xs = xs
                    helper n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = let lng = length xs in helper (mod n lng) xs where
    helper _ [] = []
    helper 0 xs = xs
    helper n xs | n &gt;= 0 = drop n xs ++ take n xs
                | n &lt; 0 = let lng = length xs in drop (lng - n) xs ++ take (lng - n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = helper n xs where
    helper _ [] = []
    helper 0 xs = xs
    helper n xs | n &gt;= 0 = drop n xs ++ take n xs
                | n &lt; 0 = let lng = length xs in drop (lng - n) xs ++ take (lng - n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = helper n xs where
    helper _ [] = []
    helper 0 xs = xs
    helper n xs | n &gt; 0 = drop n xs ++ take n xs
                | n &lt; 0 = let shift = length xs - (-n) in helper shift xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
            | n &lt; 0 = reverse $ zipWith const (drop (-n) (cycle $ reverse xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
            | n &lt; 0 = reverse $ zipWith const (drop (-n) (cycle $ reverse xs)) xs
            | n == 0 : xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
            | n &lt; 0 = reverse $ zipWith const (drop (-n) (cycle $ reverse xs)) xs
            | n == 0 = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = case drop n xs of 
    [] -&gt; helper (mod n $ length xs) xs
    xs -&gt; helper n xs
    
helper n xs | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
            | n &lt; 0 = reverse $ zipWith const (drop (-n) (cycle $ reverse xs)) xs
            | n == 0 = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = case drop n xs of 
    [] -&gt; helper (mod n $ length xs) xs
    _  -&gt; helper n xs
    
helper _ [] = []
helper 0 xs = xs
helper n xs | n &gt; 0 = drop n xs ++ take n xs
            | n &lt; 0 = let shift = length xs - (-n) in helper shift xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">125712</div>
<ul class="submissions">
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt;= 0 = zipWith const (drop n (cycle xs)) xs
			| n &lt; 0 = zipWith const (drop (n + length xs) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n `mod` 10 == 0 = xs
			| n &gt;= 0 = zipWith const (drop n (cycle xs)) xs
			| n &lt; 0 = zipWith const (drop (n + length xs) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n `mod` (length xs) == 0 = xs
			| n &gt;= 0 = zipWith const (drop n (cycle xs)) xs
			| n &lt; 0 = zipWith const (drop (n + length xs) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt; (length xs) = zipWith const (drop (length xs) (cycle xs)) xs
			| n &gt;= 0 = zipWith const (drop n (cycle xs)) xs
			| n &lt; 0 = zipWith const (drop (n + length xs) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n (x:xs) | n `mod` 10 == 0 = x:xs
				| n &gt; 0 = rotate (n `mod` 10 - 1) (xs ++ [x])
				| n &lt; 0 = rotate (n `mod` 10 + 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n (x:xs) | n `mod` 10 == 0 = x:xs
				| n &gt; 0 = rotate (n `mod` 10 - 1) (xs ++ [x])
				| n &lt; 0 = rotate ((length xs - n) `mod` 10 - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n (x:xs) | n &gt; 0 = rotate (n `mod` 10 - 1) (xs ++ [x])
				| n &lt; 0 = rotate ((length xs - n) `mod` 10 - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop (n`mod`10) xs ++ take (n`mod`10) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop (n`mod`10) xs ++ take (n`mod`10) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop (n`mod`10) xs ++ take (n`mod`10) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop (n`mod`(length xs)) xs ++ take (n`mod`(length xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop (n`mod`(length xs)) xs ++ take (n`mod`(length xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop (n`mod`(last xs)) xs ++ take (n`mod`(last xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop (n) xs ++ take (n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n (x:xs) 
 | n &gt; 0 = rotate (n-1) (xs++[x])
 | otherwise = rotate (length (x:xs) + n) (x:xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = (drop ((length ls) - (mod num (length ls)))  ls) ++ ( take ((length ls) -(mod num (length ls))) ls)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length ls)) ls ++  take (mod num (length ls)) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 100 ls))) ls ++  take (mod num (length (take 100 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1000 ls))) ls ++  take (mod num (length (take 1000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 10000 ls))) ls ++  take (mod num (length (take 10000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 100000 ls))) ls ++  take (mod num (length (take 100000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1000000 ls))) ls ++  take (mod num (length (take 1000000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 10000000 ls))) ls ++  take (mod num (length (take 10000000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1000000 ls))) ls ++  take (mod num (length (take 1000000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 9999999 ls))) ls ++  take (mod num (length (take 9999999 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 5000000 ls))) ls ++  take (mod num (length (take 500000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 250000 ls))) ls ++  take (mod num (length (take 250000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 260000 ls))) ls ++  take (mod num (length (take 260000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 300000 ls))) ls ++  take (mod num (length (take 300000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 400000 ls))) ls ++  take (mod num (length (take 400000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 500000 ls))) ls ++  take (mod num (length (take 500000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 5000000 ls))) ls ++  take (mod num (length (take 5000000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 4000000 ls))) ls ++  take (mod num (length (take 4000000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 3000000 ls))) ls ++  take (mod num (length (take 3000000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 2000000 ls))) ls ++  take (mod num (length (take 2000000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1000000 ls))) ls ++  take (mod num (length (take 1000000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 2000000 ls))) ls ++  take (mod num (length (take 2000000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1500000 ls))) ls ++  take (mod num (length (take 1500000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1400000 ls))) ls ++  take (mod num (length (take 1400000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1300000 ls))) ls ++  take (mod num (length (take 1300000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1200000 ls))) ls ++  take (mod num (length (take 1200000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1100000 ls))) ls ++  take (mod num (length (take 1100000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1050000 ls))) ls ++  take (mod num (length (take 1050000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1040000 ls))) ls ++  take (mod num (length (take 1040000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1040000 ls))) ls ++  take (mod num (length (take 1040000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1010000 ls))) ls ++  take (mod num (length (take 1010000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1001000 ls))) ls ++  take (mod num (length (take 1001000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1000100 ls))) ls ++  take (mod num (length (take 1000100 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1000010 ls))) ls ++  take (mod num (length (take 1000010 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1000001 ls))) ls ++  take (mod num (length (take 1000001 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1000002 ls))) ls ++  take (mod num (length (take 1000002 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 1000000 ls))) ls ++  take (mod num (length (take 1000000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate num ls = drop (mod num (length (take 10000000 ls))) ls ++  take (mod num (length (take 10000000 ls))) ls</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (n`mod`length (take 1000 xs)) (cycle (take 1000 xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (n`mod`length (take 10000 xs)) (cycle (take 10000 xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (n`mod`length (take 100000 xs)) (cycle (take 100000 xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (n`mod`length (take 1000000 xs)) (cycle (take 1000000 xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (n`mod`length (take 100000 xs)) (cycle (take 100000 xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (n`mod`length (take 10000000 xs)) (cycle (take 10000000 xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (n`mod`length (take 5000000 xs)) (cycle (take 5000000 xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate:: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop (n`mod`length (take 2500000 xs)) (cycle (take 2500000 xs))) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1848109</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) $ drop n (cycle xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = drop n xs ++ take n xs </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt; 0 then drop n xs ++ take n xs else drop (length xs - n) xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt;= 0 then drop n xs ++ take n xs else drop (length xs - n) xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt;= 0 then drop n xs ++ take n xs else drop (length xs - n - 1) xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt;= 0 then drop n xs ++ take n xs else drop abs n reverse xs ++ take abs n reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt;= 0 then drop n xs ++ take n xs else drop n reverse xs ++ take n reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt;= 0 then drop n xs ++ take n xs else drop (length xs + n) xs ++ take (length xs + n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt;= 0 then drop n xs ++ take n xs else drop (length xs + n - 1) xs ++ take (length xs + n - 1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt;= 0 then drop n xs ++ take n xs else drop (length xs + n + 1) xs ++ take (length xs + n + 1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = xs2 ++ xs1
    where (xs1, xs2) = splitAt (n `rem` length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs = xs2 ++ xs1
    where (xs1, xs2) = splitAt (n `rem` length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = xs2 ++ xs1
    where (xs1, xs2) = splitAt (n `rem` length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n (x:xs) = rotate (pred n) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; 0 then n = n else n = length xs + n,
            xs2 ++ xs1
                where (xs1, xs2) = splitAt (n `rem` length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; 0 then helper n xs else helper length xs + n xs
            
            
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt;= 0 then helper n xs else helper (length xs + n) xs
            
            
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate 0 xs = xs
--rotate n [] = []
rotate n xs = if n &gt;= 0 then helper n xs else helper (length xs + n) xs
            
            
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt;= 0 then helper n xs else helper (length xs + n) xs
            
            
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = iterate rot xs&#x27; !! n&#x27;
      where rot xs&#x27; = last xs&#x27; : init xs&#x27;</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt;= 0 then helper n xs else helper2 (length xs + n) xs
            
            
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = zipWith const (drop n2 (cycle xs2)) xs2</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs
            
            
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = zipWith const (drop n2 (cycle xs2)) xs2</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs
            
            
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = b ++ a where (a,b) = splitAt (mod n2 $ length xs2) xs2</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
--rotate 0 xs = xs
--rotate n [] = []
--rotate n xs = if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs
            
            
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = b ++ a where (a,b) = splitAt (mod n2 $ length xs2) xs2</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = 
            | n &gt; length xs helper2 (n - length xs) xs
            | n = length xs xs
            | n &lt; length if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs
            
            
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = zipWith const (drop n2 (cycle xs2)) xs2</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = 
            | n &gt; length = xs helper2 (n - length xs) xs
            | n = length = xs xs
            | n &lt; length = if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs
            
            
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = zipWith const (drop n2 (cycle xs2)) xs2</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper2 (n - length xs) xs 
                else if n = length xs then xs else if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs
            
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = zipWith const (drop n2 (cycle xs2)) xs2</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper2 (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
            
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = zipWith const (drop n2 (cycle xs2)) xs2</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate 0 xs = xs
--rotate n [] = []
--rotate n xs = if n &gt; length xs then helper2 (n - length xs) xs 
--                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 rotate n xs 
    | 0 &lt;= n &amp;&amp; n &lt;= length xs = drop n xs ++ take n xs     
    | otherwise = error &quot;You have inputed an invalid input&quot; 

 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = zipWith const (drop n2 (cycle xs2)) xs2</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate 0 xs = xs
--rotate n [] = []
--rotate n xs = if n &gt; length xs then helper2 (n - length xs) xs 
--                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
rotate n xs 
    | 0 &lt;= n &amp;&amp; n &lt;= length xs = drop n xs ++ take n xs     
    | otherwise = error &quot;You have inputed an invalid input&quot; 

 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = zipWith const (drop n2 (cycle xs2)) xs2</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper2 (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = drop n2 xs2 ++ take n2 xs2</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper n xs else helper (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = drop n2 xs2 ++ take n2 xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper n xs else helper (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = drop n2 xs2 ++ take n2 xs2</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper3 (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper3 n xs else helper3 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = drop n2 xs2 ++ take n2 xs2
helper3 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper2 (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = foldr (++) (drop n2 xs2) (take n2 xs2)                
helper4 n2 xs2 = drop n2 xs2 ++ take n2 xs2
helper3 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper2 (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 
                
helper2 n2 xs2 = foldr (++) n2 xs2
helper4 n2 xs2 = drop n2 xs2 ++ take n2 xs2
helper3 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper2 (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper2 k [] = []  
helper2 k x = (k) : (take (l-1) x) 
               where l=length x 

helper4 n2 xs2 = drop n2 xs2 ++ take n2 xs2
helper3 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper2 (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper2 0 xs2 = xs2
helper2 n2 [] = []
helper2 n2 xs2 = drop n2 xs2 ++ take n2 xs2
helper3 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper2 (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper2 n2 xs2 = drop n2 xs2 ++ take n2 xs2
helper3 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper2 (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper2 (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if length xs == undefined then error &quot;&quot; else if n &gt; length xs then helper2 (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if length xs &gt;= 1234567890 then error &quot;&quot; else if n &gt; length xs then helper2 (n - length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs || -n &gt; length xs then helper2 (mod n / length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs || -n &gt; length xs then helper2 (n mod length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs || -n &gt; length xs then helper2 (mod&#x27; n length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
 
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs || -n &gt; length xs then helper2 (mod&#x27; n length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs || -n &gt; length xs then helper2 l xs where l = mod&#x27; n length xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs || -n &gt; length xs then xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper n mod&#x27; xs xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper l = n mod&#x27; xs xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper n mod&#x27; length xs xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
 
helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper777 n length xs xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
 
helper777 n0 n01 xs0 =  zipWith const (drop n03 (cycle xs0)) xs0 
                where n03 = n0 mod&#x27; n01

helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper777 n length xs xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
helper777 :: Int -&gt; Int -&gt; [a] -&gt; [a] 
helper777 n0 n01 xs0 =  zipWith const (drop n03 (cycle xs0)) xs0 
                where n03 = n0 mod&#x27; n01

helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper777 n length xs xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
         
helper777 :: Int -&gt; Int -&gt; [a] -&gt; [a] 
helper777 n0 n01 xs0 =  zipWith const (drop n03 (cycle xs0)) xs0 
                where n03 = mod&#x27; n0 n01

helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs then helper777 n (length xs) xs 
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
         
helper777 :: Int -&gt; Int -&gt; [a] -&gt; [a] 
helper777 n0 n01 xs0 =  zipWith const (drop n03 (cycle xs0)) xs0 
                where n03 = mod&#x27; n0 n01

helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs  then helper777 n (length xs) xs
              else if -n &gt; length xs  then helper777 -n (length xs) xs
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
         
helper777 :: Int -&gt; Int -&gt; [a] -&gt; [a] 
helper777 n0 n01 xs0 =  zipWith const (drop n03 (cycle xs0)) xs0 
                where n03 = mod&#x27; n0 n01

helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs  then helper777 n (length xs) xs
              else if -n &gt; length xs  then helper777 (-n) (length xs) xs
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
         
helper777 :: Int -&gt; Int -&gt; [a] -&gt; [a] 
helper777 n0 n01 xs0 =  zipWith const (drop n03 (cycle xs0)) xs0 
                where n03 = mod&#x27; n0 n01

helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs  then helper777 n (length xs) xs
              else if -n &gt; length xs  then helper777 (-n) (length xs) xs
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
         
helper777 :: Int -&gt; Int -&gt; [a] -&gt; [a] 
helper777 n0 n01 xs0 =  zipWith const (drop n03 (cycle xs0)) xs0 
                where n03 = mod&#x27; n0 n01

helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs  then helper777 n (length xs) xs
              else if -n &gt; length xs  then helper777 (-n) (length xs) xs
                else (if n == length xs then helper2 n xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
         
helper777 :: Int -&gt; Int -&gt; [a] -&gt; [a] 
helper777 n0 n01 xs0 =  zipWith const (drop n03 (cycle xs0)) xs0 
                where n03 = mod&#x27; n0 n01

helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs  then helper777 n (length xs) xs
              else if -n &gt; length xs  then helper777 (-n) (length xs) xs
                else (if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs))
                else error &quot;&quot;

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
         
helper777 :: Int -&gt; Int -&gt; [a] -&gt; [a] 
helper777 n0 n01 xs0 =  zipWith const (drop n03 (cycle xs0)) xs0 
                where n03 = mod&#x27; n0 n01

helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>         
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = if n &gt; length xs  then helper777 n (length xs) xs
              else if -n &gt; length xs  then helper777 (-n) (length xs) xs
                else if n == length xs then xs else (if n &gt;= 0 then helper2 n xs else helper2 (length xs + n) xs)
                else error &quot;&quot;

mod&#x27; :: Int -&gt; Int -&gt; Int
mod&#x27; x y | (y &gt; x)   = x
         | otherwise = mod&#x27; (x-y) y
         
helper777 :: Int -&gt; Int -&gt; [a] -&gt; [a] 
helper777 n0 n01 xs0 =  zipWith const (drop n03 (cycle xs0)) xs0 
                where n03 = mod&#x27; n0 n01

helper :: Int -&gt; [a] -&gt; [a]
helper n&#x27; xs&#x27; = xs2 ++ xs1
                where (xs1, xs2) = splitAt (n&#x27; `rem` length xs&#x27;) xs&#x27; 

helper3 n2 xs2 = drop n2 xs2 ++ take n2 xs2

helper2 0 xs3 = xs3
helper2 n3 [] = []
helper2 n3 xs3 = zipWith const (drop n3 (cycle xs3)) xs3</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1984823</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if (signum n) == 1 then take (length xs) (drop n (cycle xs)) else reverse(take (length xs) (drop (abs n) (cycle (reverse xs))))
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum n) == 1 then zipWith const (drop n (cycle xs)) xs else reverse (zipWith const (drop (abs n) (cycle (reverse xs))) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if n &gt; length xs then length xs else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if n&gt;100 then z = 10 else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if n&gt;100 then 10 else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if n&gt;100 then n / 10 else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                         where z = if n&gt;100 then (div) n 10 else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if n &gt; length(zipWith const (drop 0 (cycle xs)) xs ) then length(zipWith const (drop 0 (cycle xs)) xs ) else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if abs n &gt; length(zipWith const (drop 0 (cycle xs)) xs ) then length(zipWith const (drop 0 (cycle xs)) xs ) else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = (div) n 10</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = (div) n length(xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = (div) n (length xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if abs n &gt; length(take 1000 (zipWith const (drop 0 (cycle xs)) xs )) then length(take 1000 (zipWith const (drop 0 (cycle xs)) xs )) else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if abs n &gt; length(take 1 (zipWith const (drop 0 (cycle xs)) xs )) then length(take 1 (zipWith const (drop 0 (cycle xs)) xs )) else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if abs n &gt; length(take 20 (zipWith const (drop 0 (cycle xs)) xs )) then length(take 20 (zipWith const (drop 0 (cycle xs)) xs )) else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if abs n &gt; length(take n (zipWith const (drop 0 (cycle xs)) xs )) then length(take n (zipWith const (drop 0 (cycle xs)) xs )) else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = abs n /  length(take 1000 (zipWith const (drop 0 (cycle xs)) xs ))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = abs n /  length(take 1000 (zipWith const (drop 0 (cycle xs)) xs )))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = abs n /  length(take 1000 (zipWith const (drop 0 (cycle xs)) xs ))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = abs n /  length(zipWith const (drop 0 (cycle xs)) xs )</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = (div) abs n length(zipWith const (drop 0 (cycle xs)) xs )</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = (div) (abs n) (length(zipWith const (drop 0 (cycle xs)) xs ))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = (div) (abs n)  (length(take 1000 (zipWith const (drop 0 (cycle xs)) xs )))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if abs n &gt; length xs then length xs else n
						</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if abs n &gt; length (take 10 xs) then length (take 10 xs) else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if longerThan n xs == True then n else if n &gt; length xs then length xs else n
						</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else   (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = n -- z = if longerThan (abs n) xs == True then n else if n &gt; length xs then length xs else n
						</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else   (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if n &gt; length xs then length xs else n
						</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else   (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = n
						</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else   (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan 1000 xs == True then n else if n &gt; length xs then length xs else n
						</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else   (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then 10 else if n &gt; length xs then length xs else n
						</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else   (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then 1000 else if n &gt; length xs then length xs else n
						</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else   (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if n &gt; length xs then length xs else n
						</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else   (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if n &gt; length xs then length xs - 1 else n
						</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else   (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if n &gt; length xs then length xs + 1 else n
						</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if n &gt; length xs &amp;&amp; odd n == False then length xs else if 	n &gt; length xs &amp;&amp; odd n == True then length xs + 1 else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if n &gt; length xs &amp;&amp; odd n == False then length xs else if 	n &gt; length xs &amp;&amp; odd n == True then length xs + 1 else n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if n &gt; length xs &amp;&amp; odd n == False then length xs else if 	n &gt; length xs &amp;&amp; odd n == True then length xs + 1 else n	</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs &amp;&amp; odd n == False then length xs * sign else if 	(abs n) &gt; length xs &amp;&amp; odd n == True then (length xs + 1) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)		</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs &amp;&amp; odd n == False then (length xs)* sign else if 	(abs n) &gt; length xs &amp;&amp; odd n == True then (length xs - 1) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)		</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if longerThan (100) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else reverse (zipWith const (drop (abs z) (cycle (reverse xs))) xs)
                        where z = if longerThan (10) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)	</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (10) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (1) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (1000000) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (drop (n + z) (cycle (xs))) xs)
                        where z = if longerThan (1000000) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (drop (z) (cycle (xs))) xs)
                        where z = if longerThan (1000000) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (take z (cycle (xs))) xs)
                        where z = if longerThan (1000000) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (take z (cycle (xs))) xs)
                        where z = if longerThan (1000000) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (1000000) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else if longerThan (abs z) xs == True then  zipWith const (drop z (cycle xs)) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)		</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else if longerThan (abs z) xs == True then  zipWith const (take (abs z) (cycle xs)) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)	</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else if longerThan (abs z) xs == True then  zipWith const (drop (abs z) (cycle xs)) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)	</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else if longerThan (abs z) xs == True then  zipWith const (reverse(take (abs z) (cycle xs))) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)	</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else if longerThan (abs z) xs == True then  zipWith const (reverse(take (abs z) (cycle xs))) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)	</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (take z (cycle (xs))) xs)
                        where z = if longerThan (1000000) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (drop (z) (cycle (xs))) xs)
                        where z = if longerThan (1000000) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)		</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  if (signum z) == 1 then zipWith const (drop z (cycle xs)) xs else (zipWith const (drop (length xs + z) (cycle (xs))) xs)
                        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)		</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs	</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ([last xs] ++ init xs )

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ([last xs] ++ init xs )

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ([last xs] ++ init xs )

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ([last xs] ++ init xs )

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ([last xs] ++ init xs )

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z = if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ([last xs] ++ init xs )

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else rotatel (length xs - z ) xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else if longerThan (1000) xs  then rotatel (z) xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else if longerThan (100000000) xs  then rotatel (z) xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else if longerThan (10000000) xs  then rotatel (z) xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else if longerThan (1000000) xs  then rotatel (z) xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else if longerThan (100000) xs  then rotatel (z) xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else if longerThan (9999999999999) xs  then rotatel (z) xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else if longerThan (19999) xs  then rotatel (z) xs else rotater z xs
                  where z =  if longerThan (2003021) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else  rotater z xs
                  where z = if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  zipWith const (take (length xs) $ drop (length xs + n) $ cycle xs) xs
                        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  zipWith const (take (length xs) $ drop (length xs + n) $ cycle xs) xs
                        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  zipWith const (take (length xs) $ drop (length xs + n) $ cycle xs) xs
                        where z = if longerThan (abs n) xs == True then n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) * sign else n
                              sign = if (signum n) == 1	then 1 else (-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else if longerThan (19999) xs  then rotatel (z) xs else rotater z xs
                  where z =  if longerThan (2003021) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else if longerThan (19999) xs  then rotatel (z) xs else rotater z xs
                  where z =  if longerThan (2003021) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate::[a] -&gt; Int -&gt; [a]
rotate [] _ = []
rotate [x] _ = [x]
rotate list num
  | num &lt; 0 = rotate list ((length list) + num)
  | length list &gt;= num = (drop num list) ++ (take num list)
  | otherwise = list</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n xs = if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n xs = if n == 1000001 then reverse(take (n + 1) xs) else if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n  else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2195039</div>
<ul class="submissions">
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n &gt;=0 = zipWith const (drop n (cycle xs)) xs
	| otherwise = reverse (rotate (-n) (reverse xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n &gt;=0 = zipWith const (drop (n `mod` (length xs)) (cycle xs)) xs
	| otherwise = reverse (rotate (-n) (reverse xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n &gt;=0 = zipWith const (drop (n `mod` (length xs)) (cycle xs)) xs
	| otherwise = reverse (rotate (-n) (reverse xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n &gt;=0 = zipWith const (drop (n `mod` (length xs)) (cycle xs)) xs
	| otherwise = rotate ((length xs)+n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n &gt;=0 = zipWith const (drop (n `mod` (length xs)) (cycle xs)) xs
	| otherwise = rotate (-((length xs) + n)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &gt;= 0 = rotatePositive n l
    | otherwise = rotateNegative n l

rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1000 = rotateNegative n l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1000000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 100000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 10000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 100000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 10000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 5000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 3000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 2000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1500000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1250000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1100000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1050000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1005000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1000500 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1000001 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 999999 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1000001 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n l
    | n &lt; 0 = rotateNegative n l
    | n &gt; 1000000 = rotateNegative (n - length l) l
    | otherwise = rotatePositive n l


rotateNegative n l = 
    let
        len = length l
        shiftLen = n `mod` len
        part1 = drop shiftLen l
        part2 = take shiftLen l
    in
        part1 ++ part2
        
        
rotatePositive n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">165956</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
-- rotate 1 (x:xs) = xs ++ [x]
rotate n (x:xs) = rotate (mod n ((length xs + 1) - 1)) (xs ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
-- rotate 1 (x:xs) = xs ++ [x]
rotate n (x:xs) = rotate (trimmed_n - 1) (smart_shift (x:xs)) where
    trimmed_n = mod n ((length xs + 1))

smart_shift (x:xs) = xs ++ [x]
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
-- rotate 1 (x:xs) = xs ++ [x]
rotate n (x:xs) = rotate (trimmed_n - 1) (smart_shift (x:xs)) where
    trimmed_n = n

smart_shift (xs) =  zipWith const (drop 1 (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
-- rotate 1 (x:xs) = xs ++ [x]
rotate n (x:xs) = rotate (trimmed_n - 1) (smart_shift (x:xs)) where
    trimmed_n = mod n ((length xs + 1))

smart_shift (x:xs) =  zipWith const (drop 1 (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
rotate n xs | n &lt; 0 = zipWith const (drop trimmed_n (cycle xs)) xs where
    trimmed_n = trimmed_n = mod n ((length xs + 1))
-- rotate 1 (x:xs) = xs ++ [x]
-- rotate n (x:xs) | length xs &lt; 100 = rotate (trimmed_n - 1) (smart_shift (x:xs))
--                 | n &gt; 0 = rotate (n - 1) (smart_shift (x:xs))
--                 | n &lt; 0   = rotate (trimmed_n - 1) (smart_shift (x:xs)) where
--                     trimmed_n = mod n ((length xs + 1))
--
-- smart_shift (xs) =  zipWith const (drop 1 (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
rotate n xs | n &lt; 0 = zipWith const (drop trimmed_n (cycle xs)) xs where
    trimmed_n = mod n ((length xs + 1))
-- rotate 1 (x:xs) = xs ++ [x]
-- rotate n (x:xs) | length xs &lt; 100 = rotate (trimmed_n - 1) (smart_shift (x:xs))
--                 | n &gt; 0 = rotate (n - 1) (smart_shift (x:xs))
--                 | n &lt; 0   = rotate (trimmed_n - 1) (smart_shift (x:xs)) where
--                     trimmed_n = mod n ((length xs + 1))
--
-- smart_shift (xs) =  zipWith const (drop 1 (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
rotate n xs | n &lt; 0 = zipWith const (drop trimmed_n (cycle xs)) xs where
    trimmed_n = mod n ((length xs))
-- rotate 1 (x:xs) = xs ++ [x]
-- rotate n (x:xs) | length xs &lt; 100 = rotate (trimmed_n - 1) (smart_shift (x:xs))
--                 | n &gt; 0 = rotate (n - 1) (smart_shift (x:xs))
--                 | n &lt; 0   = rotate (trimmed_n - 1) (smart_shift (x:xs)) where
--                     trimmed_n = mod n ((length xs + 1))
--
-- smart_shift (xs) =  zipWith const (drop 1 (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 1000 = zipWith const (drop trimmed_n (cycle xs)) xs
rotate n xs | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
rotate n xs | n &lt; 0 = zipWith const (drop trimmed_n (cycle xs)) xs
    where trimmed_n = mod n ((length xs))
-- rotate 1 (x:xs) = xs ++ [x]
-- rotate n (x:xs) | length xs &lt; 100 = rotate (trimmed_n - 1) (smart_shift (x:xs))
--                 | n &gt; 0 = rotate (n - 1) (smart_shift (x:xs))
--                 | n &lt; 0   = rotate (trimmed_n - 1) (smart_shift (x:xs)) where
--                     trimmed_n = mod n ((length xs + 1))
--
-- smart_shift (xs) =  zipWith const (drop 1 (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 1000 = zipWith const (drop trimmed_n (cycle xs)) xs
            | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
            | n &lt; 0 = zipWith const (drop trimmed_n (cycle xs)) xs
            where trimmed_n = mod n ((length xs))
-- rotate 1 (x:xs) = xs ++ [x]
-- rotate n (x:xs) | length xs &lt; 100 = rotate (trimmed_n - 1) (smart_shift (x:xs))
--                 | n &gt; 0 = rotate (n - 1) (smart_shift (x:xs))
--                 | n &lt; 0   = rotate (trimmed_n - 1) (smart_shift (x:xs)) where
--                     trimmed_n = mod n ((length xs + 1))
--
-- smart_shift (xs) =  zipWith const (drop 1 (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 100000 = zipWith const (drop trimmed_n (cycle xs)) xs
            | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
            | n &lt; 0 = zipWith const (drop trimmed_n (cycle xs)) xs
            where trimmed_n = mod n ((length xs))
-- rotate 1 (x:xs) = xs ++ [x]
-- rotate n (x:xs) | length xs &lt; 100 = rotate (trimmed_n - 1) (smart_shift (x:xs))
--                 | n &gt; 0 = rotate (n - 1) (smart_shift (x:xs))
--                 | n &lt; 0   = rotate (trimmed_n - 1) (smart_shift (x:xs)) where
--                     trimmed_n = mod n ((length xs + 1))
--
-- smart_shift (xs) =  zipWith const (drop 1 (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n == 1234567890 = zipWith const (drop trimmed_n (cycle xs)) xs
            | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
            | n &lt; 0 = zipWith const (drop trimmed_n (cycle xs)) xs
            where trimmed_n = mod n ((length xs))
-- rotate 1 (x:xs) = xs ++ [x]
-- rotate n (x:xs) | length xs &lt; 100 = rotate (trimmed_n - 1) (smart_shift (x:xs))
--                 | n &gt; 0 = rotate (n - 1) (smart_shift (x:xs))
--                 | n &lt; 0   = rotate (trimmed_n - 1) (smart_shift (x:xs)) where
--                     trimmed_n = mod n ((length xs + 1))
--
-- smart_shift (xs) =  zipWith const (drop 1 (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; (1000*1000) = zipWith const (drop trimmed_n (cycle xs)) xs
            | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
            | n &lt; 0 = zipWith const (drop trimmed_n (cycle xs)) xs
            where trimmed_n = mod n ((length xs))
-- rotate 1 (x:xs) = xs ++ [x]
-- rotate n (x:xs) | length xs &lt; 100 = rotate (trimmed_n - 1) (smart_shift (x:xs))
--                 | n &gt; 0 = rotate (n - 1) (smart_shift (x:xs))
--                 | n &lt; 0   = rotate (trimmed_n - 1) (smart_shift (x:xs)) where
--                     trimmed_n = mod n ((length xs + 1))
--
-- smart_shift (xs) =  zipWith const (drop 1 (cycle xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; (1000*1000*10) = zipWith const (drop trimmed_n (cycle xs)) xs
            | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
            | n &lt; 0 = zipWith const (drop trimmed_n (cycle xs)) xs
            where trimmed_n = mod n ((length xs))
-- rotate 1 (x:xs) = xs ++ [x]
-- rotate n (x:xs) | length xs &lt; 100 = rotate (trimmed_n - 1) (smart_shift (x:xs))
--                 | n &gt; 0 = rotate (n - 1) (smart_shift (x:xs))
--                 | n &lt; 0   = rotate (trimmed_n - 1) (smart_shift (x:xs)) where
--                     trimmed_n = mod n ((length xs + 1))
--
-- smart_shift (xs) =  zipWith const (drop 1 (cycle xs)) xs
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1848652</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [x] = [x]
rotate _ [] = []
rotate n xxs@(x:xs)
  | n &gt; 0 &amp;&amp; n &gt; (length xxs) = rotate (mod n (length xxs)) xxs
  | n &lt; 0 &amp;&amp; abs(n) &gt; (length xxs) = rotate (mod (abs (n)) (length xxs)) xxs
  | n &gt; 0 = rotate (n-1) (xs ++ [x])
  | n &lt; 0 = rotate (n+1) ((last xxs) : (init xxs))
  | otherwise = xxs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
  | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
  | otherwise = zipWith const (drop ((length xs) - n) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ [x] = [x]
rotate n xs 
  | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
  | otherwise = zipWith const (drop ((length xs) - n) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [x] = [x]
rotate _ [] = []
rotate n xxs@(x:xs)
  | n &gt; 0 &amp;&amp; n &gt; (length xxs) = rotate (mod n (length xxs)) xxs
  | n &lt; 0 &amp;&amp; abs(n) &gt; (length xxs) = rotate (- mod (abs (n)) (length xxs)) xxs
  | n &gt; 0 = rotate (n-1) (xs ++ [x])
  | n &lt; 0 = rotate (n+1) ((last xxs) : (init xxs))
  | otherwise = xxs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [x] = [x]
rotate _ [] = []
rotate n xxs@(x:xs)
  | n &gt; 0 &amp;&amp; n &gt; (length xxs) = rotate (mod n (length xxs)) xxs
  | n &lt; 0 &amp;&amp; abs(n) &gt; (length xxs) = rotate (- (mod (abs (n)) (length xxs))) xxs
  | n &gt; 0 = rotate (n-1) (xs ++ [x])
  | n &lt; 0 = rotate (n+1) ((last xxs) : (init xxs))
  | otherwise = xxs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [x] = [x]
rotate _ [] = []
rotate n xxs@(x:xs)
  | n &gt; 0 &amp;&amp; n &gt; (length xxs) = rotate (mod n (length xxs)) xxs
  | n &lt; 0 &amp;&amp; abs(n) &gt; (length xxs) = rotate (mod (abs (n)) (length xxs)) xxs
  | n &gt; 0 = rotate (n-1) (xs ++ [x])
  | n &lt; 0 = rotate (n+1) ((last xxs) : (init xxs))
  | otherwise = xxs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ [x] = [x]
rotate n xs
  | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
  | otherwise = zipWith const (drop ((length xs) - (mod (abs (n)) (length xs))) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [x] = [x]
rotate _ [] = []
rotate n xxs@(x:xs)
  | n &gt; 0 &amp;&amp; n &gt; (length xxs) = rotate (mod n (length xxs)) xxs
  | n &lt; 0 &amp;&amp; abs(n) &gt; (length xxs) = rotate (mod (abs (n)) (length xxs)) xxs
  | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
  | n &lt; 0 = rotate (n+1) ((last xxs) : (init xxs))
  | otherwise = xxs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [x] = [x]
rotate _ [] = []
rotate n xxs@(x:xs)
  | n &gt; 0 &amp;&amp; n &gt; (length xxs) = rotate (mod n (length xxs)) xxs
  | n &lt; 0 &amp;&amp; abs(n) &gt; (length xxs) = rotate (mod (abs (n)) (length xxs)) xxs
  | n &gt; 0 = rotate (n-1) (xs ++ [x])
  | n &lt; 0 = rotate (n+1) ((last xxs) : (init xxs))
  | otherwise = xxs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ [x] = [x]
rotate n xs
  | n &gt; 0 &amp;&amp; n &gt; (length xxs) = rotate (mod n (length xxs)) xxs
  | n &lt; 0 &amp;&amp; abs(n) &gt; (length xxs) = rotate (mod (abs (n)) (length xxs)) xxs
  | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
  | otherwise = zipWith const (take (abs n) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ [x] = [x]
rotate n xs
  | n &gt; 0 &amp;&amp; n &gt; (length xs) = rotate (mod n (length xs)) xs
  | n &lt; 0 &amp;&amp; abs(n) &gt; (length xs) = rotate (mod (abs (n)) (length xs)) xs
  | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
  | otherwise = zipWith const (take (abs n) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs
notLonger n xs = ((longerThan n xs) == False)

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ [x] = [x]
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod (length xs) n) xs
  | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate ((length xs) - (mod (abs (n)) (length xs))) xs
  | n &lt; 0 = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs
notLonger n xs = ((longerThan n xs) == False)

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ [x] = [x]
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n (length xs)) xs
  | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate ((length xs) - (mod (abs (n)) (length xs))) xs
  | n &lt; 0 = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n (length xs)) xs
  | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate ((length xs) - (mod (abs (n)) (length xs))) xs
  | n &lt; 0 = xs


isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs
notLonger n xs = ((longerThan n xs) == False)</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n (length xs)) xs
  | n &gt; 0 = zipWith const (drop n (cycle xs)) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate ((length xs) - (mod (abs (n)) (length xs))) xs
  | n &lt; 0 = xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
notLonger n xs = ((isNonEmpty $ drop n xs) == False)</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n $ length xs) xs
  | n &gt; 0 = zipWith const (drop n $ cycle xs) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate (length xs - mod (abs n) (length xs)) xs
  | n &lt; 0 = xs

notLonger n xs = ((isNonEmpty $ drop n xs) == False)
isNonEmpty [] = False
isNonEmpty (_:_) = True</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">152428</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
    let l = length xs
        s = mod n l
    in (drop s xs) ++ (take s xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
    let endList = take n xs
    in (drop n xs) ++ endList</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
    let if n &gt; 100 then l = mod n (length xs) else l = n
        endList = take l xs
    in (drop l xs) ++ endList</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
    let l = if n &gt; 100
        then mod n (length xs)
        else n
        endList = take l xs
    in (drop l xs) ++ endList</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
    let l = if n &gt; 100 || n &lt; 0
        then mod n (length xs)
        else n
        endList = take l xs
    in (drop l xs) ++ endList</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
    let l = if n &gt; 100 || n &lt; 0
        then mod n (length xs)
        else n
    in (drop l xs) ++ (take l xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
    let l = if n &gt; 1000 || n &lt; 0
        then mod n (length xs)
        else n
    in (drop l xs) ++ (take l xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
    let l = if n &gt; 10000 || n &lt; 0
        then mod n (length xs)
        else n
    in (drop l xs) ++ (take l xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
    let l = if n &gt; 10 || n &lt; 0
        then mod n (length xs)
        else n
    in (drop l xs) ++ (take l xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
    let l = if n &gt; 100 || n &lt; 0
        then mod n (length xs)
        else n
    in (drop l xs) ++ (take l xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs =
    let l = if n &gt; 100 || n &lt; 0
        then mod n (length xs)
        else n
    in (drop l xs) ++ (take l xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 10000 || n &lt; 0
        then mod n (length xs)
        else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 1000 || n &lt; 0
        then mod n (length xs)
        else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 100000 || n &lt; 0
        then mod n (length xs)
        else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 100000
        then mod n (length xs)
        else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 100000 || n &lt; 0
        then mod n (length xs)
        else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 100000 || n &lt; 0
        then mod n (length (take n xs))
        else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 100000 || n &lt; 0
        then mod n (length (take 100000 xs))
        else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 1000000 || n &lt; 0
        then mod n (length (take 1000000 xs))
        else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 10000
        then mod n (length xs)
        else if n &lt; 0 then mod n (length (take 10000 xs)) else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 10000
        then mod n (length xs)
        else if n &lt; 0 then mod n (length (take 1000000 xs)) else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 10000
        then mod n (length (take 1000000 xs))
        else if n &lt; 0 then mod n (length (take 1000000 xs)) else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 10000
        then mod n (length (take 10000000 xs))
        else if n &lt; 0 then mod n (length (take 10000000 xs)) else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 10000
        then mod n (length (take 1000000 xs))
        else if n &lt; 0 then mod n (length (take 1000000 xs)) else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 10000
        then mod n (length xs)
        else (abs n)
        resList = if n &lt; 0 then reverse xs else xs
    in zipWith (\x _ -&gt; x) (drop l (cycle resList)) resList</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 10000
        then mod n (length (take 1000000 xs))
        else (abs n)
        resList = if n &lt; 0 then reverse xs else xs
    in zipWith (\x _ -&gt; x) (drop l (cycle resList)) resList</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 10000
        then mod n (length (take 100000000 xs))
        else (abs n)
        resList = if n &lt; 0 then reverse xs else xs
    in zipWith (\x _ -&gt; x) (drop l (cycle resList)) resList</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = (abs n)
        resList = if n &lt; 0 then reverse xs else xs
    in zipWith (\x _ -&gt; x) (drop l (cycle resList)) resList</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 10000
        then mod n (length (take 1000000 xs))
        else if n &lt; 0 then mod n (length (take 1000000 xs)) else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 100
        then mod n (length xs)
        else (abs n)
        resList = if n &lt; 0 then reverse xs else xs
    in zipWith (\x _ -&gt; x) (drop l (cycle resList)) resList</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 1000
        then mod n (length xs)
        else (abs n)
        resList = if n &lt; 0 then reverse xs else xs
    in zipWith (\x _ -&gt; x) (drop l (cycle resList)) resList</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 10000
        then mod n (length xs)
        else (abs n)
        resList = if n &lt; 0 then reverse xs else xs
    in zipWith (\x _ -&gt; x) (drop l (cycle resList)) resList</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 10000
        then mod n (length (take 1000000 xs))
        else if n &lt; 0 then mod n (length (take 1000000 xs)) else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =
    let l = if n &gt; 1000000
        then mod n (length (take 1000000 xs))
        else if n &lt; 0 then mod n (length (take 1000000 xs)) else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
        | n &lt; 0     = reverse (zipWith (\x _ -&gt; x) (drop l (cycle (reverse xs))) (reverse xs))
        | otherwise = zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs
        where
            l = if (abs n) &gt; 100000
            then mod n (length (take 100000 xs))
            else (abs n)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
        | n &lt; 0     = reverse (zipWith (\x _ -&gt; x) (drop l (cycle (reverse xs))) (reverse xs))
        | otherwise = zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs
        where
            l = if (abs n) &gt; 100000
            then mod n (length (take 100000 xs))
            else (abs n)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
let l = if n &gt; 1000000
        then mod n (length (take 1000000 xs))
        else if n &lt; 0 then mod n (length (take 1000000 xs)) else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs =
    let l = if n &gt; 1000000
        then mod n (length (take 1000000 xs))
        else if n &lt; 0 then mod n (length (take 1000000 xs)) else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs =
    let lim = 1000000
        isLong lst = length (take (abs n) lst) == (abs n)
        getNewN lst = if isLong lst then n else mod n (length xs)
        l = if n &gt; lim
        then getNewN xs
        else if n &lt; 0 then abs (getNewN xs) else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs =
    let lim = 1000000
        isLong lst = length (take (abs lim) lst) == (abs lim)
        getNewN lst = if isLong lst then n else mod n (length xs)
        l = if n &gt; lim
        then getNewN xs
        else if n &lt; 0 then abs (getNewN xs) else n
    in zipWith (\x _ -&gt; x) (drop l (cycle xs)) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2118001</div>
<ul class="submissions">
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
	|  (abs n)&gt;10000000 = take (length xs) $ drop (n `mod` length xs) $ cycle xs
	| n &gt; 0 = zipWith const (drop n (cycle xs)) xs
	| otherwise = reverse $ zipWith const (drop (negate n) ( cycle (reverse xs))) (reverse xs)

</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1835895</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take l (drop k (cycle xs)) where
		l = length xs
		k = if n &gt;= 0 then n `mod` l else (l + n) `mod` l
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n list | n &gt;= 100000 = take l (drop (n `mod` l) (cycle list)) where l = length list
rotate n (x:xs) | n &lt; 100000 &amp;&amp; n &gt;= 0 = rotate (n - 1) (xs ++ [x])
rotate n list | n &lt; 0 = take l (drop ((l + n) `mod` l) (cycle list)) where l = length list</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n list | n &gt;= 10000 = take l (drop (n `mod` l) (cycle list)) where l = length list
rotate n (x:xs) | n &lt; 10000 &amp;&amp; n &gt;= 0 = rotate (n - 1) (xs ++ [x])
rotate n list | n &lt; 0 = take l (drop ((l + n) `mod` l) (cycle list)) where l = length list</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n list | n &gt;= 1000 = take l (drop (n `mod` l) (cycle list)) where l = length list
rotate n (x:xs) | n &lt; 1000 &amp;&amp; n &gt;= 0 = rotate (n - 1) (xs ++ [x])
rotate n list | n &lt; 0 = take l (drop ((l + n) `mod` l) (cycle list)) where l = length list</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate n list | n &gt; 0 = zipWith const (drop n (cycle list)) list
rotate n list | n &lt; 0 = take l (drop ((l + n) `mod` l) (cycle list)) where l = length list
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2062976</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rShift :: Int -&gt; [a] -&gt; [a] 
rShift 0 x = x
rShift _ []= []
rShift 1 (x:xs)= xs ++ [x]
rShift n x = rShift (n1-1) (rShift 1 x) where n1 = mod n (length x)
 
lShift :: Int -&gt; [a] -&gt; [a] 
lShift 0 x = x
lShift _ []= []
lShift 1 x=  (last x) : (init x)
lShift n x = lShift (n1-1) (lShift 1 x) where n1 = mod n (length x)

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if (n &gt;= 0) then (rShift n xs) else (lShift (-n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rshifts :: Int -&gt; [a] -&gt; [a] 
rshifts n xs = (iterate rshift1 xs) !! (mod n (length xs))
  where rshift1 (x:xs) = xs ++ [x]
 
lShift :: Int -&gt; [a] -&gt; [a] 
lShift 0 x = x
lShift _ []= []
lShift 1 x=  (last x) : (init x)
lShift n x = lShift (n1-1) (lShift 1 x) where
  n1 = mod n (length x)

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if (n &gt;= 0) then (rshifts n xs) else (lShift (-n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rshifts :: Int -&gt; [a] -&gt; [a] 
rshifts n xs = (iterate rshift1 xs) !! n1 where
  n1 = if (n &gt; 1000) then mod n (length xs) else n
  rshift1 (x:xs) = xs ++ [x]
 
lShift :: Int -&gt; [a] -&gt; [a] 
lShift 0 x = x
lShift _ []= []
lShift 1 x=  (last x) : (init x)
lShift n x = lShift (n1-1) (lShift 1 x) where
  n1 = mod n (length x)

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if (n &gt;= 0) then (rshifts n xs) else (lShift (-n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rshifts :: Int -&gt; [a] -&gt; [a] 
rshifts n xs = (iterate rshift1 xs) !! n1 where
  n1 = if (n &gt; 1000) then mod n (length xs) else n
  rshift1 (x:xs) = xs ++ [x]
 
lShift :: Int -&gt; [a] -&gt; [a] 
lShift 0 x = x
lShift _ []= []
lShift 1 x=  (last x) : (init x)
lShift n x = lShift (n1-1) (lShift 1 x) where
  n1 = mod n (length x)

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if (n &gt;= 0) then (rshifts n xs) else (lShift (-n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rshifts :: Int -&gt; [a] -&gt; [a] 
rshifts n xs = (iterate rshift1 xs) !! n1 where
  n1 = if (n &gt; 1000) then mod n (length xs) else n
  rshift1 (x:xs) = xs ++ [x]
 
lshifts :: Int -&gt; [a] -&gt; [a] 
lshifts n xs = (iterate lshift1 xs) !! n1 where
  n1 = if (n &gt; 1000) then mod n (length xs) else n
  lshift1 xs = last xs : init xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if (n &gt;= 0) then (rshifts n xs) else (lshifts (-n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rshifts :: Int -&gt; [a] -&gt; [a] 
rshifts n xs = (iterate rshift1 xs) !! n1 where
  n1 = if (n &gt; 100) then mod n (length xs) else n
  rshift1 (x:xs) = xs ++ [x]
 
lshifts :: Int -&gt; [a] -&gt; [a] 
lshifts n xs = (iterate lshift1 xs) !! n1 where
  n1 = if (n &gt; 100) then mod n (length xs) else n
  lshift1 xs = last xs : init xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if (n &gt;= 0) then (rshifts n xs) else (lshifts (-n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
  | n &gt;= 0 = zipWith const (drop n (cycle xs)) xs
  | n &lt; 0  = zipWith const (drop (length xs+n) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
  | n &gt;= 0 = take (length xs) (drop n (cycle xs))
  | n &lt; 0  = zipWith const (drop (length xs+n) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
  | n &gt;= 0 = take (length xs) (drop n (cycle xs))
  | n &lt; 0  = take (length xs) (drop ((length xs) + n) (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) $ drop (negate (-n) `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
  | n &gt;= 0 = take (length xs) (drop n (cycle xs))
  | n &lt; 0  = take (length xs) (drop ((length xs) + n) (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take (length xs) (drop n (cycle xs))
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
  | n &gt;= 0 = take (length xs) (drop n (cycle xs))
  | n &lt; 0  = take (length xs) (drop ((length xs) + n) (cycle xs))</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">426632</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs@(x:xx) | n==0 = xs
                   | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                   | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                   | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                   | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                   | n&lt;0 &amp;&amp; (mod n (length xs)==0)= rotate (n+1) ([last xs]++(init xs))
                   | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate (n+1) ([last xs]++(init xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs@(x:xx) | n==0 = xs
                   | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                   | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                   | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                   | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                   | n&lt;0 &amp;&amp; (mod n (length xs)==0)= rotate (n+1) ([last xs]++(init xs))
                   | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>{-
Реализуйте функцию, задающую циклическое вращение списка.

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
При положительном значении целочисленного аргумента вращение должно осуществляться влево, при отрицательном - вправо.

GHCi&gt; rotate 2 &quot;abcdefghik&quot;
&quot;cdefghikab&quot;
GHCi&gt; rotate (-2) &quot;abcdefghik&quot; 
&quot;ikabcdefgh&quot;
Не забывайте обеспечить работоспособность вашей реализации на бесконечных списках (для сценариев, когда это имеет смысл) и разумную эффективность при большом числе вращений небольшого списка:

GHCi&gt; :set +s
GHCi&gt; rotate 1234567890 [1..10]
[1,2,3,4,5,6,7,8,9,10]
(0.00 secs, 0 bytes)
-}
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
-- rotate n xs@(x:xx) | n==0 = xs
                   -- | n&gt;0 &amp;&amp; (not (null (drop n xs))) &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                   -- | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                   -- | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                   -- | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; (mod n (length xs)==0)= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
rotate n xs@(x:xx)  | n==0 = xs
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                    | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                    --
                    -- | n&lt;0 &amp;&amp; (not (null (drop (abs n) xs))) = rotate (n+1) ([last xs]++(init xs))
                    | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                    | n&lt;0 &amp;&amp; (mod n (length xs)==0)= rotate (n+1) ([last xs]++(init xs))
                    | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
                   
-- rotate&#x27; n xs@(x:xx) | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate&#x27; (n-1) (xx++[x])
                    -- | n==0 = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>{-
Реализуйте функцию, задающую циклическое вращение списка.

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
При положительном значении целочисленного аргумента вращение должно осуществляться влево, при отрицательном - вправо.

GHCi&gt; rotate 2 &quot;abcdefghik&quot;
&quot;cdefghikab&quot;
GHCi&gt; rotate (-2) &quot;abcdefghik&quot; 
&quot;ikabcdefgh&quot;
Не забывайте обеспечить работоспособность вашей реализации на бесконечных списках (для сценариев, когда это имеет смысл) и разумную эффективность при большом числе вращений небольшого списка:

GHCi&gt; :set +s
GHCi&gt; rotate 1234567890 [1..10]
[1,2,3,4,5,6,7,8,9,10]
(0.00 secs, 0 bytes)
-}
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
-- rotate n xs@(x:xx) | n==0 = xs
                   -- | n&gt;0 &amp;&amp; (not (null (drop n xs))) &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                   -- | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                   -- | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                   -- | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; (mod n (length xs)==0)= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
rotate n xs@(x:xx)  | n==0 = xs
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                    | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                    --
                    -- | n&lt;0 &amp;&amp; (not (null (drop (abs n) xs))) = rotate (n+1) ([last xs]++(init xs))
                    | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                    | n&lt;0 &amp;&amp; (mod n (length xs)==0)= xs
                    | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
                   
-- rotate&#x27; n xs@(x:xx) | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate&#x27; (n-1) (xx++[x])
                    -- | n==0 = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>{-
Реализуйте функцию, задающую циклическое вращение списка.

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
При положительном значении целочисленного аргумента вращение должно осуществляться влево, при отрицательном - вправо.

GHCi&gt; rotate 2 &quot;abcdefghik&quot;
&quot;cdefghikab&quot;
GHCi&gt; rotate (-2) &quot;abcdefghik&quot; 
&quot;ikabcdefgh&quot;
Не забывайте обеспечить работоспособность вашей реализации на бесконечных списках (для сценариев, когда это имеет смысл) и разумную эффективность при большом числе вращений небольшого списка:

GHCi&gt; :set +s
GHCi&gt; rotate 1234567890 [1..10]
[1,2,3,4,5,6,7,8,9,10]
(0.00 secs, 0 bytes)
-}
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs@(x:xx)  | n==0 = xs
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                    | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])

                    | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                    | n&lt;0 &amp;&amp; (mod n (length xs)==0)= xs
                    | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))


</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>{-
Реализуйте функцию, задающую циклическое вращение списка.

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
При положительном значении целочисленного аргумента вращение должно осуществляться влево, при отрицательном - вправо.

GHCi&gt; rotate 2 &quot;abcdefghik&quot;
&quot;cdefghikab&quot;
GHCi&gt; rotate (-2) &quot;abcdefghik&quot; 
&quot;ikabcdefgh&quot;
Не забывайте обеспечить работоспособность вашей реализации на бесконечных списках (для сценариев, когда это имеет смысл) и разумную эффективность при большом числе вращений небольшого списка:

GHCi&gt; :set +s
GHCi&gt; rotate 1234567890 [1..10]
[1,2,3,4,5,6,7,8,9,10]
(0.00 secs, 0 bytes)
-}
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs@(x:xx)  | n==0 = xs
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                    | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
rotate n xs@(x:xx)  | n==0 = xs
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                    | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                    --
                    | n&lt;0 &amp;&amp; (not (null (drop (abs n) xs))) = undefined
                    | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                    | n&lt;0 &amp;&amp; (mod n (length xs)==0)= xs
                    | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))


</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>{-
Реализуйте функцию, задающую циклическое вращение списка.

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
При положительном значении целочисленного аргумента вращение должно осуществляться влево, при отрицательном - вправо.

GHCi&gt; rotate 2 &quot;abcdefghik&quot;
&quot;cdefghikab&quot;
GHCi&gt; rotate (-2) &quot;abcdefghik&quot; 
&quot;ikabcdefgh&quot;
Не забывайте обеспечить работоспособность вашей реализации на бесконечных списках (для сценариев, когда это имеет смысл) и разумную эффективность при большом числе вращений небольшого списка:

GHCi&gt; :set +s
GHCi&gt; rotate 1234567890 [1..10]
[1,2,3,4,5,6,7,8,9,10]
(0.00 secs, 0 bytes)
-}
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs@(x:xx)  | n==0 = xs
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                    | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
rotate n xs@(x:xx)  | n==0 = xs
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                    | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                    --
                    -- | n&lt;0 &amp;&amp; (not (null (drop (abs n) xs))) = undefined
                    | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                    | n&lt;0 &amp;&amp; (mod n (length xs)==0)= xs
                    | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))


</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>{-
Реализуйте функцию, задающую циклическое вращение списка.

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
При положительном значении целочисленного аргумента вращение должно осуществляться влево, при отрицательном - вправо.

GHCi&gt; rotate 2 &quot;abcdefghik&quot;
&quot;cdefghikab&quot;
GHCi&gt; rotate (-2) &quot;abcdefghik&quot; 
&quot;ikabcdefgh&quot;
Не забывайте обеспечить работоспособность вашей реализации на бесконечных списках (для сценариев, когда это имеет смысл) и разумную эффективность при большом числе вращений небольшого списка:

GHCi&gt; :set +s
GHCi&gt; rotate 1234567890 [1..10]
[1,2,3,4,5,6,7,8,9,10]
(0.00 secs, 0 bytes)
-}
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []


rotate n xs@(x:xx)  | n==0 = xs
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                    | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                    --
                    -- | n&lt;0 &amp;&amp; (not (null (drop (abs n) xs))) = undefined
                    | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                    | n&lt;0 &amp;&amp; (mod n (length xs)==0)= xs
                    | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))


</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>{-
Реализуйте функцию, задающую циклическое вращение списка.

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
При положительном значении целочисленного аргумента вращение должно осуществляться влево, при отрицательном - вправо.

GHCi&gt; rotate 2 &quot;abcdefghik&quot;
&quot;cdefghikab&quot;
GHCi&gt; rotate (-2) &quot;abcdefghik&quot; 
&quot;ikabcdefgh&quot;
Не забывайте обеспечить работоспособность вашей реализации на бесконечных списках (для сценариев, когда это имеет смысл) и разумную эффективность при большом числе вращений небольшого списка:

GHCi&gt; :set +s
GHCi&gt; rotate 1234567890 [1..10]
[1,2,3,4,5,6,7,8,9,10]
(0.00 secs, 0 bytes)
-}
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
-- rotate n xs@(x:xx) | n==0 = xs
                   -- | n&gt;0 &amp;&amp; (not (null (drop n xs))) &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                   -- | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                   -- | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                   -- | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; (mod n (length xs)==0)= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
rotate n xs@(x:xx)  | n==0 = xs
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                    | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                    --
                    -- | n&lt;0 &amp;&amp; (not (null (drop (abs n) xs))) = undefined
                    | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                    | n&lt;0 &amp;&amp; (mod n (length xs)==0)= xs
                    | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
-- rotate&#x27; :: Int -&gt; [a] -&gt; [a]
-- rotate&#x27; _ [] = []
-- rotate&#x27; n xs = zipWith const (drop n (cycle xs)) xs

-- a = rotate 654684516841684168 []
-- b = rotate 9849898981989818 [1..10]
-- b&#x27; = rotate 9849898981989818 &quot;dafdasdf&quot;
-- c = rotate (-9849898981989818) [1..10]
-- d = rotate 50 [1,5..]
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>{-
Реализуйте функцию, задающую циклическое вращение списка.

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
При положительном значении целочисленного аргумента вращение должно осуществляться влево, при отрицательном - вправо.

GHCi&gt; rotate 2 &quot;abcdefghik&quot;
&quot;cdefghikab&quot;
GHCi&gt; rotate (-2) &quot;abcdefghik&quot; 
&quot;ikabcdefgh&quot;
Не забывайте обеспечить работоспособность вашей реализации на бесконечных списках (для сценариев, когда это имеет смысл) и разумную эффективность при большом числе вращений небольшого списка:

GHCi&gt; :set +s
GHCi&gt; rotate 1234567890 [1..10]
[1,2,3,4,5,6,7,8,9,10]
(0.00 secs, 0 bytes)
-}
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
-- rotate n xs@(x:xx) | n==0 = xs
                   -- | n&gt;0 &amp;&amp; (not (null (drop n xs))) &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                   -- | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                   -- | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                   -- | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; (mod n (length xs)==0)= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
rotate n xs@(x:xx)  | n==0 = xs
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                    | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                    --
                    -- | n&lt;0 &amp;&amp; (not (null (drop (abs n) xs))) = undefined
                    -- | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                    | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= take (length xs) . drop (n `mod` (length xs)) . cycle $ xs
                    | n&lt;0 &amp;&amp; (mod n (length xs)==0)= xs
                    | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
-- rotate&#x27; :: Int -&gt; [a] -&gt; [a]
-- rotate&#x27; _ [] = []
-- rotate&#x27; n xs = zipWith const (drop n (cycle xs)) xs

-- a = rotate 654684516841684168 []
-- b = rotate 9849898981989818 [1..10]
-- b&#x27; = rotate 9849898981989818 &quot;dafdasdf&quot;
-- c = rotate (-9849898981989818) [1..10]
-- d = rotate 50 [1,5..]

-- rotate&#x27; xs n = take len . drop (n `mod` len) . cycle $ xs
    -- where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>{-
Реализуйте функцию, задающую циклическое вращение списка.

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
При положительном значении целочисленного аргумента вращение должно осуществляться влево, при отрицательном - вправо.

GHCi&gt; rotate 2 &quot;abcdefghik&quot;
&quot;cdefghikab&quot;
GHCi&gt; rotate (-2) &quot;abcdefghik&quot; 
&quot;ikabcdefgh&quot;
Не забывайте обеспечить работоспособность вашей реализации на бесконечных списках (для сценариев, когда это имеет смысл) и разумную эффективность при большом числе вращений небольшого списка:

GHCi&gt; :set +s
GHCi&gt; rotate 1234567890 [1..10]
[1,2,3,4,5,6,7,8,9,10]
(0.00 secs, 0 bytes)
-}
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
-- rotate n xs@(x:xx) | n==0 = xs
                   -- | n&gt;0 &amp;&amp; (not (null (drop n xs))) &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                   -- | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                   -- | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                   -- | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; (mod n (length xs)==0)= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
rotate n xs@(x:xx)  | n==0 = xs
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                    | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                    --
                    -- | n&lt;0 &amp;&amp; (not (null (drop (abs n) xs))) = undefined
                    -- | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                    | n&lt;0 = rotate&#x27; xs n
                    -- | n&lt;0 &amp;&amp; (mod n (length xs)==0)= xs
                    -- | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
-- rotate&#x27; :: Int -&gt; [a] -&gt; [a]
-- rotate&#x27; _ [] = []
-- rotate&#x27; n xs = zipWith const (drop n (cycle xs)) xs

-- a = rotate 654684516841684168 []
-- b = rotate 9849898981989818 [1..10]
-- b&#x27; = rotate 9849898981989818 &quot;dafdasdf&quot;
-- c = rotate (-9849898981989818) [1..10]
-- d = rotate 50 [1,5..]

rotate&#x27; xs n = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>{-
Реализуйте функцию, задающую циклическое вращение списка.

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
При положительном значении целочисленного аргумента вращение должно осуществляться влево, при отрицательном - вправо.

GHCi&gt; rotate 2 &quot;abcdefghik&quot;
&quot;cdefghikab&quot;
GHCi&gt; rotate (-2) &quot;abcdefghik&quot; 
&quot;ikabcdefgh&quot;
Не забывайте обеспечить работоспособность вашей реализации на бесконечных списках (для сценариев, когда это имеет смысл) и разумную эффективность при большом числе вращений небольшого списка:

GHCi&gt; :set +s
GHCi&gt; rotate 1234567890 [1..10]
[1,2,3,4,5,6,7,8,9,10]
(0.00 secs, 0 bytes)
-}
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
-- rotate n xs@(x:xx) | n==0 = xs
                   -- | n&gt;0 &amp;&amp; (not (null (drop n xs))) &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                   -- | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                   -- | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                   -- | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; (mod n (length xs)==0)= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
rotate n xs@(x:xx)  | n==0 = xs
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    -- | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                    -- | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                    -- | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                    
                    --
                    -- | n&lt;0 &amp;&amp; (not (null (drop (abs n) xs))) = undefined
                    -- | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                    | otherwise = rotate&#x27; xs n
                    -- | n&lt;0 &amp;&amp; (mod n (length xs)==0)= xs
                    -- | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
-- rotate&#x27; :: Int -&gt; [a] -&gt; [a]
-- rotate&#x27; _ [] = []
-- rotate&#x27; n xs = zipWith const (drop n (cycle xs)) xs

-- a = rotate 654684516841684168 []
-- b = rotate 9849898981989818 [1..10]
-- b&#x27; = rotate 9849898981989818 &quot;dafdasdf&quot;
-- c = rotate (-9849898981989818) [1..10]
-- d = rotate 50 [1,5..]

rotate&#x27; xs n = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs@(x:xx)  | n==0 = xs
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    | otherwise = rotate&#x27; xs n

rotate&#x27; xs n = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>{-
Реализуйте функцию, задающую циклическое вращение списка.

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
При положительном значении целочисленного аргумента вращение должно осуществляться влево, при отрицательном - вправо.

GHCi&gt; rotate 2 &quot;abcdefghik&quot;
&quot;cdefghikab&quot;
GHCi&gt; rotate (-2) &quot;abcdefghik&quot; 
&quot;ikabcdefgh&quot;
Не забывайте обеспечить работоспособность вашей реализации на бесконечных списках (для сценариев, когда это имеет смысл) и разумную эффективность при большом числе вращений небольшого списка:

GHCi&gt; :set +s
GHCi&gt; rotate 1234567890 [1..10]
[1,2,3,4,5,6,7,8,9,10]
(0.00 secs, 0 bytes)
-}
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
-- rotate n xs@(x:xx) | n==0 = xs
                   -- | n&gt;0 &amp;&amp; (not (null (drop n xs))) &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                   -- | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                   -- | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                   -- | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; (mod n (length xs)==0)= rotate (n+1) ([last xs]++(init xs))
                   -- | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
rotate n xs@(x:xx)  | n==0 = xs
                    -- | n&gt;0 &amp;&amp; (not (null (drop n xs))) = rotate (n-1) (xx++[x])
                    | n&gt;0 &amp;&amp; (not (null (drop n xs))) = (drop n xs)++(take n xs)
                    -- | n&gt;0 &amp;&amp; ((length xs)&gt;n) = rotate (n-1) (xx++[x])
                    -- | n&gt;0 &amp;&amp; (mod n (length xs)==0) = xs
                    -- | n&gt;0 &amp;&amp; ((length xs)&lt;n) = rotate ((mod n (length xs))-1) (xx++[x])
                    
                    --
                    -- | n&lt;0 &amp;&amp; (not (null (drop (abs n) xs))) = undefined
                    -- | n&lt;0 &amp;&amp; ((length xs)&gt;(abs n))= rotate (n+1) ([last xs]++(init xs))
                    | otherwise = rotate&#x27; xs n
                    -- | n&lt;0 &amp;&amp; (mod n (length xs)==0)= xs
                    -- | n&lt;0 &amp;&amp; ((length xs)&lt;(abs n)) = rotate ((mod n (length xs))+1) ([last xs]++(init xs))
-- rotate&#x27; :: Int -&gt; [a] -&gt; [a]
-- rotate&#x27; _ [] = []
-- rotate&#x27; n xs = zipWith const (drop n (cycle xs)) xs

-- a = rotate 654684516841684168 []
-- b = rotate 9849898981989818 [1..10]
-- b&#x27; = rotate 9849898981989818 &quot;dafdasdf&quot;
-- c = rotate (-9849898981989818) [1..10]
-- d = rotate 50 [1,5..]

rotate&#x27; xs n = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1355682</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs

rotate n xs = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate _ [] = []
rotate n x = (drop m x) ++ (take m x)
             where p = length x
                   k = (-n) `mod` p
                   m = p - k
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate _ [] = []
rotate n xs
    | null xs   = xs
    | n &lt; 0     = rotateL xs (-n)
    | otherwise = rotateR xs n

rotateL xs 0 = xs
rotateL xs n = rotateL (last xs : init xs) (n - 1)

rotateR xs 0     = xs
rotateR (x:ys) n = rotateR (ys ++ [x]) (n - 1)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate _ [] = []
rotate n xs
    | n &lt; 0         = rotate (n + length xs) xs
    | length xs &lt; n = xs
    | otherwise     = rest ++ first
    where (first, rest) = splitAt n xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate _ [] = []
rotate n xs 
	| n &gt;= 0 = _rot xs n
	| n &lt; 0 = _rot xs (length xs + n)
	where
		_rot :: [a] -&gt; Int -&gt; [a]
		_rot xs n = 
			let spl = splitAt n xs
			in snd spl ++ fst spl 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Control.Arrow((&amp;&amp;&amp;))

rotate :: Int -&gt; [a] -&gt; [a]
rotate offset = uncurry take
                   . (length &amp;&amp;&amp; uncurry drop .
                                 (mod offset  . length &amp;&amp;&amp; cycle))
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs | n &gt;= length xs = rotate (n`mod`(length xs)) xs
            | otherwise = rotate&#x27; n xs

rotate&#x27; n xs = let (xh,xt) = splitAt n xs in xt++xh
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
  | n &lt; 0     = rotateR b xs
  | otherwise = rotateL r xs
  where
    l = rotLength xs 0 n n
    r = if n &gt; l then n `mod` l else n
    b = if n &gt; l then -((abs n) `mod` l) else n


rotateL n xs = zipWith const (drop n (cycle xs)) xs
-- rotateR n _ | Debug.Trace.trace (&quot;rotateR n:&quot; ++ show n ) False = undefined
rotateR _ [] = []
rotateR 0 xs = xs
rotateR n xs = rotateR (n + 1) (last xs : init xs)


-- rotLength _      cnt len lim | Debug.Trace.trace (&quot;rotLength cnt:&quot; ++ show cnt ++ &quot; len:&quot; ++ show len ++ &quot;lim:&quot; ++ show lim) False = undefined
rotLength []     _   len _   = len
rotLength _      0   _   lim = lim
rotLength (_:ls) cnt len lim = rotLength ls (cnt - 1) (len + 1) lim
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
  | n &lt; 0     = rotateR b xs
  | otherwise = rotateL r xs
  where
    l = rotLength xs 0 n n
    r = if n &gt; l then n `mod` l else n
    b = if n &gt; l then -((abs n) `mod` l) else n


rotateL n xs = zipWith const (drop n (cycle xs)) xs
-- rotateR n _ | Debug.Trace.trace (&quot;rotateR n:&quot; ++ show n ) False = undefined
rotateR _ [] = []
rotateR 0 xs = xs
rotateR n xs = rotateR (n + 1) (last xs : init xs)


-- rotLength _      cnt len lim | Debug.Trace.trace (&quot;rotLength cnt:&quot; ++ show cnt ++ &quot; len:&quot; ++ show len ++ &quot;lim:&quot; ++ show lim) False = undefined
rotLength []     _   len _   = len
rotLength _      0   _   lim = lim
rotLength (_:ls) cnt len lim = rotLength ls (cnt - 1) (len + 1) lim
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1823921</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs

rotate n xs = (drop n&#x27; xs) ++ (take n&#x27; xs) where
    n&#x27; = mod n $ length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs

rotate n xs = ($!) drop n&#x27; xs ++ ($!) take n&#x27; xs where
    n&#x27; = mod n $ length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: [a] -&gt; Int -&gt; [a]
rotate [] _ = []
rotate x 0 = x
rotate x y
  | y &gt; 0     = rotate (tail x ++ [head x]) (y-1)
  | otherwise = rotate (last x : init x) (y+1)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x  = x
rotate n x 
  | n &gt; 0     = rotate (n-1) (tail x ++ [head x]) 
  | otherwise = rotate (n+1) (last x : init x)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x  = x
rotate n x 
  | n &gt; 0     = rotate (n-1) (tail x ++ [head x]) 
  | otherwise = rotate (n+1) (($!) last x : ($!)init x)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x  = x
rotate n x 
  | n &gt; 0     = ($!) rotate (n-1) (tail x ++ [head x]) 
  | otherwise = rotate (n+1) (($!) last x : ($!)init x)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x  = x
rotate n x 
  | n &gt; 0     = ($!) rotate (n-1) (($!) tail x ++ [($!) head x]) 
  | otherwise = ($!) rotate (n+1) (($!) last x : ($!) init x)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x  = x
rotate n x 
  | n &gt; 0     = ($!) rotate (n-1) (($!) tail x ++ take n&#x27; x) 
  | otherwise = ($!) rotate (n+1) (($!) last x : ($!) init x)
      where n&#x27; = mod n $ length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x  = x
rotate n x 
  | n &gt; 0     = ($!) rotate (n-1) (($!) tail x ++ take n&#x27; x) 
  | otherwise = ($!) rotate (n+1) (($!) last x : ($!) init x)
      where n&#x27; = mod n $ length x
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x  = x
rotate n x 
  | n &gt; 0     = ($!) rotate (n-1) (tail x ++ take n&#x27; x ) 
  | otherwise = rotate (n+1) (last x : take (n&#x27;-1) x) 
    where n&#x27; = mod n $ length x
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x  = x
rotate n x 
  | n &gt; 0     = ($!) rotate (n-1) (tail x ++ take n&#x27; x ) 
  | otherwise = rotate (n+1) (last x : take n&#x27; x) 
    where n&#x27; = mod n $ length x
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x  = x
rotate n x 
  | n &gt; 0     = ($!) rotate (n-1) (tail x ++ take n&#x27; x ) 
  | otherwise = drop n&#x27; x ++ take n&#x27; x  
    where n&#x27; = mod n $ length x
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; (notLonger n xs) = rotate (mod n $ length xs) xs
  | n &gt; 0 = zipWith const (drop n $ cycle xs) xs
  | n &lt; 0 &amp;&amp; (notLonger (maxBound :: Int) xs) = rotate (length xs - mod (abs n) (length xs)) xs
  | n &lt; 0 = xs
 
notLonger n xs = ((isNonEmpty $ drop n xs) == False)
isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">166335</div>
<ul class="submissions">
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
			| n &gt; 0 = rotateHelper n xs
			| n &lt; 0 = rotateHelper (n + length xs) xs

rotateHelper _ [] = []
rotateHelper n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate n xs 
	| n &gt; 0 = rotateHelper n xs
	| n &lt; 0 = rotateHelper (n + length xs) xs
	| otherwise = xs
            
rotateHelper :: Int -&gt; [a] -&gt; [a]

rotateHelper _ [] = []
rotateHelper n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate n xs 
	| n &gt; 0 = 
		if n &gt; length xs 
			then rotateHelper (rem n (length xs)) xs 
		else rotateHelper n xs
	| n &lt; 0 = 
		if abs n &gt; length xs 
			then rotateHelper (rem n (length xs) + length xs) xs 
		else rotateHelper (n + length xs) xs
	| otherwise = xs
            
rotateHelper :: Int -&gt; [a] -&gt; [a]

rotateHelper _ [] = []
rotateHelper n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
	| n &gt; 0 = leftRotate n xs
	| n &lt; 0 = rightRotate n xs
	| otherwise = xs
            
leftRotate :: Int -&gt; [a] -&gt; [a]
leftRotate n xs 
	| n &gt; length xs = rot (rem n (length xs)) xs 
	| otherwise = rot n xs

rightRotate :: Int -&gt; [a] -&gt; [a]
rightRotate n xs 
	| abs n &gt; length xs  = rot (rem n (length xs) + length xs) xs 
	| otherwise = rot (n + length xs) xs

rot :: Int -&gt; [a] -&gt; [a]
rot _ [] = []
rot n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
	| n &gt; 0 = leftRotate n (length xs) xs
	| n &lt; 0 = rightRotate n (abs n) (length xs) xs
	| otherwise = xs
            
leftRotate :: Int -&gt; Int -&gt; [a] -&gt; [a]
leftRotate n len xs 
	| n &gt; len = rot (rem n len) xs 
	| otherwise = rot n xs

rightRotate :: Int -&gt; Int -&gt; Int -&gt; [a] -&gt; [a]
rightRotate n n_ len xs 
	| n_ &gt; len  = rot (len + rem n len) xs 
	| otherwise = rot (n + len) xs

rot :: Int -&gt; [a] -&gt; [a]
rot _ [] = []
rot n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
rotate n xs = drop nn xs ++ take nn xs
    where nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n+length xs
            | otherwise = xs
rotate n xs = drop nn xs ++ take nn xs
    where nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs where len = n+length xs
            | otherwise = xs
rotate n xs = drop nn xs ++ take nn xs
    where nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs where len = n+length xs
                        
rotate n xs = drop nn xs ++ take nn xs
    where nn = n `mod` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs where len = n+length xs
                        
rotate n xs = drop nn xs ++ take nn xs
    where nn = n `rem` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs where len = n+length xs
                        
rotate n xs = drop nn xs ++ take nn xs where nn = n `rem` length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs where len = n+length xs
                        
rotate n xs = drop nn xs ++ take nn xs where nn = rem n $ length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs where len = n+length xs
                        
rotate n xs = drop nn xs ++ take nn xs where nn = rem n $ length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = rotate0 len0 xs where len1 = length0 n xs
            | n &lt; 0 =  rotate0 len1 xs where len1 = n + length0 n xs
                        
rotate0 :: Int -&gt; [a] -&gt; [a]
rotate0 dis xs = drop dis xs ++ take dis xs

length0 :: Int -&gt; [a] -&gt; Int
length0 n xs = if n &gt; len then rem n len else n where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = rotate0 len0 xs where len1 = length0 n xs
            | n &lt; 0 =  rotate0 len1 xs where len1 = n + length0 n xs
                        
rotate0 dis xs = drop dis xs ++ take dis xs

length0 n xs = if n &gt; len then rem n len else n where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
    | n &gt;= 0 = rotate0 len0 xs where len1 = length0 n xs
    | n &lt; 0 =  rotate0 len1 xs where len1 = n + length0 n xs
                        
rotate0 dis xs = drop dis xs ++ take dis xs

length0 n xs = if n &gt; len then rem n len else n where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
	| n &gt;= 0 = rotate0 l xs where l = length0 n xs
	| n &lt; 0 = rotate0 ll xs where ll = n + length0 n xs
	where 
		rotate0 dis xs = drop dis xs ++ take dis xs where
			length0 n xs = if n &gt; len then rem n len else n where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = rotate0 l xs where l = length0 n xs 
            | n &lt; 0 = rotate0 ll xs where ll = n + length0 n xs 
            where 
                rotate0 dis xs = drop dis xs ++ take dis xs where
                    length0 n xs = if n &gt; len then rem n len else n where 
                        len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = rotate0 l xs where l = length0 n xs 
            | n &lt; 0 = rotate0 ll xs where ll = n + length0 n xs

rotate0 dis xs = drop dis xs ++ take dis xs
length0 n xs = if n &gt; len then rem n len else n where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = rotate0 l xs 
                where l = length0 n xs 
            | n &lt; 0 = rotate0 ll xs 
                where ll = n + length0 n xs

rotate0 dis xs = drop dis xs ++ take dis xs
length0 n xs = if n &gt; len then rem n len else n 
                    where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = rotate0 (length0 n xs) xs
            | n &lt; 0 = rotate0 ll xs 
                where ll = n + length0 n xs

rotate0 dis xs = drop dis xs ++ take dis xs
length0 n xs = if n &gt; len then rem n len else n 
                    where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
	| n &gt;= 0 = rotate0 (length0 n xs) xs
	| n &lt; 0 = rotate0 ll xs 
		where ll = n + length0 n xs


rotate0 dis xs = drop dis xs ++ take dis xs

length0 n xs = if n &gt; len then rem n len else n where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
	| n &gt;= 0 = rotate0 (length0 n xs) xs
	| n &lt; 0 = rotate0 len xs 
		where len = n + length0 n xs


rotate0 dis xs = drop dis xs ++ take dis xs

length0 n xs = if n &gt; len then rem n len else n where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
	| n &gt;= 0 = rotate0 (length0 n xs) xs
	| n &lt; 0 = rotate0 len xs 
		where len = n + length0 n xs


rotate0 dis xs = drop dis xs ++ take dis xs

length0 n xs = if n &gt; len then rem n len else n 
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
	| n &gt;= 0 = rotate0 (length0 n xs) xs
	| n &lt; 0 = rotate0 len xs 
		where len = n + length0 n xs

rotate0 :: Int -&gt; [a] -&gt; [a]
rotate0 dis xs = drop dis xs ++ take dis xs

length0 :: Int -&gt; [a] -&gt; Int
length0 n xs = if n &gt; len then rem n len else n 
    where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop len xs ++ take len xs
                      where len = n + length xs
rotate n xs = drop nn xs ++ take nn xs
    where 
      nn = n `rem` length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
    | n &gt;= 0 = rotate_ dis xs
    | n &lt; 0 = rotate_ (len + dis) xs 
        where dis = length_ n xs; len = length xs

rotate_ n xs = drop n xs ++ take n xs

length_ n xs = if nn &gt; len then rem n len else n 
    where len = length xs; nn = abs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
    | null [] = []
    | n &gt;= 0 = rotate_ dis xs
    | n &lt; 0 = rotate_ (len + dis) xs 
        where dis = length_ n xs; len = length xs

rotate_ n xs = drop n xs ++ take n xs

length_ n xs = if nn &gt; len then rem n len else n 
    where len = length xs; nn = abs n</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">162772</div>
<ul class="submissions">
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27; n xs
	| n &lt; 0 = helper&#x27;&#x27; (abs n) (reverse xs)
	where
		helper&#x27; n xs = zipWith const (drop n (cycle xs)) xs
		helper&#x27;&#x27; n xs = reverse (zipWith const (drop n (cycle xs)) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27; n xs
	| n &lt; 0 = helper&#x27;&#x27; (abs n) (reverse xs)
	where
		helper&#x27; n xs = take (length xs) (drop n (cycle xs))
		helper&#x27;&#x27; n xs = reverse (take (length xs) (drop n (cycle xs)))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27; n xs
	| n &lt; 0 = helper&#x27;&#x27; (abs n) (reverse xs)
	where
		helper&#x27; n xs = b ++ a where (a, b) = splitAt n xs
		helper&#x27;&#x27; n xs = reverse (b ++ a where (a, b) = splitAt n xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27; n xs
	| n &lt; 0 = helper&#x27;&#x27; (abs n) (reverse xs)
	where
		helper&#x27; n xs = b ++ a
		helper&#x27;&#x27; n xs = reverse (b ++ a)
        (a, b) = splitAt n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27; n xs
	| n &lt; 0 = helper&#x27;&#x27; (abs n) (reverse xs)
	where
		helper&#x27; n xs = b ++ a
		helper&#x27;&#x27; n xs = reverse (zipWith const (drop n (cycle xs)) xs)
		(a,b) = splitAt n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27; n xs
	| n &lt; 0 = helper&#x27;&#x27; n&#x27; xs&#x27;
	where
		helper&#x27; n xs = b ++ a
		helper&#x27;&#x27; n xs = (reverse a&#x27;) ++ (reverse b&#x27;)
		(a,b) = splitAt n xs
		(a&#x27;, b&#x27;) = splitAt n&#x27; xs&#x27;
		n&#x27; = abs n
		xs&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27; n xs
	| n &lt; 0 = helper&#x27;&#x27; n&#x27; xs&#x27;
	where
		helper&#x27; n xs = b ++ a
		helper&#x27;&#x27; n xs = (reverse a&#x27;) ++ (reverse b&#x27;)
		(a,b) = splitAt n xs
		(a&#x27;, b&#x27;) = splitAt n&#x27; xs&#x27;
		n&#x27; = abs n
		xs&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	-- | n == 0 = xs
	| n &gt; 0 = helper&#x27; n xs
	| n &lt; 0 = helper&#x27;&#x27; n&#x27; xs&#x27;
	where
		helper&#x27; n xs = b ++ a
		helper&#x27;&#x27; n xs = (reverse a&#x27;) ++ (reverse b&#x27;)
		(a,b) = splitAt n xs
		(a&#x27;, b&#x27;) = splitAt n&#x27; xs&#x27;
		n&#x27; = abs n
		xs&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	-- | n &gt; 0 = helper&#x27; n xs
	| n &lt; 0 = helper&#x27;&#x27; n&#x27; xs&#x27;
	where
		helper&#x27; n xs = b ++ a
		helper&#x27;&#x27; n xs = (reverse a&#x27;) ++ (reverse b&#x27;)
		(a,b) = splitAt n xs
		(a&#x27;, b&#x27;) = splitAt n&#x27; xs&#x27;
		n&#x27; = abs n
		xs&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27; n xs
	-- | n &lt; 0 = helper&#x27;&#x27; n&#x27; xs&#x27;
	where
		helper&#x27; n xs = b ++ a
		helper&#x27;&#x27; n xs = (reverse a&#x27;) ++ (reverse b&#x27;)
		(a,b) = splitAt n xs
		(a&#x27;, b&#x27;) = splitAt n&#x27; xs&#x27;
		n&#x27; = abs n
		xs&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27; n xs
	| n &lt; 0 = helper&#x27;&#x27; n&#x27; xs&#x27;
	where
		helper&#x27; n xs = a ++ a
		helper&#x27;&#x27; n xs = (reverse a&#x27;) ++ (reverse b&#x27;)
		(a,b) = splitAt n xs
		(a&#x27;, b&#x27;) = splitAt n&#x27; xs&#x27;
		n&#x27; = abs n
		xs&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27; n xs
	| n &lt; 0 = helper&#x27;&#x27; n&#x27; xs&#x27;
	where
		helper&#x27; n xs = b ++ a
		helper&#x27;&#x27; n xs = (reverse a&#x27;) ++ (reverse b&#x27;)
		(a,b) = splitAt n xs
		(a&#x27;, b&#x27;) = splitAt n&#x27; xs&#x27;
		n&#x27; = abs n
		xs&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27; n xs
	-- | n &lt; 0 = helper&#x27;&#x27; n&#x27; xs&#x27;
	where
		helper&#x27; n xs = b ++ a
		helper&#x27;&#x27; n xs = (reverse a&#x27;) ++ (reverse b&#x27;)
		(a,b) = splitAt n xs
		(a&#x27;, b&#x27;) = splitAt n&#x27; xs&#x27;
		n&#x27; = abs n
		xs&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27; n xs
	| n &lt; 0 = helper&#x27;&#x27; n&#x27; xs&#x27;
	where
		helper&#x27; n xs = b ++ a
		helper&#x27;&#x27; n xs = (reverse a&#x27;) ++ (reverse b&#x27;)
		(a,b) = splitAt n xs
		(a&#x27;, b&#x27;) = splitAt n&#x27; xs&#x27;
		n&#x27; = abs n
		xs&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27;
	| n &lt; 0 = helper&#x27;&#x27;
	where
		helper&#x27; = b&#x27; ++ a&#x27;
		helper&#x27;&#x27; = (reverse a&#x27;&#x27;) ++ (reverse b&#x27;&#x27;)
		(a&#x27;,b&#x27;) = splitAt n&#x27; xs
		(a&#x27;&#x27;, b&#x27;&#x27;) = splitAt n&#x27; xs&#x27;&#x27;
		n&#x27; = mod (abs n) (length xs)
		xs&#x27;&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27;
	| n &lt; 0 = helper&#x27;&#x27;
	where
		helper&#x27; = b&#x27; ++ a&#x27;
		helper&#x27;&#x27; = (reverse a&#x27;&#x27;) ++ (reverse b&#x27;&#x27;)
		(a&#x27;,b&#x27;) = splitAt n&#x27; xs
		(a&#x27;&#x27;, b&#x27;&#x27;) = splitAt n&#x27; xs&#x27;&#x27;
		n&#x27; = mod (abs n) (length xs)
		xs&#x27;&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27;
	| n &lt; 0 = helper&#x27;&#x27;
	where
		helper&#x27; = b&#x27; ++ a&#x27;
		helper&#x27;&#x27; = (reverse a&#x27;&#x27;) ++ (reverse b&#x27;&#x27;)
		(a&#x27;,b&#x27;) = splitAt n&#x27; xs
		(a&#x27;&#x27;, b&#x27;&#x27;) = splitAt n&#x27; xs&#x27;&#x27;
		n&#x27; = mod (abs n) (length xs)
		xs&#x27;&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27;
	| n &lt; 0 = helper&#x27;&#x27;
	where
		helper&#x27; = b&#x27; ++ a&#x27;
		helper&#x27;&#x27; = (reverse a&#x27;&#x27;) ++ (reverse b&#x27;&#x27;)
		(a&#x27;,b&#x27;) = splitAt n&#x27; xs
		(a&#x27;&#x27;, b&#x27;&#x27;) = splitAt n&#x27; xs&#x27;&#x27;
		n&#x27; = mod (abs n) (length $ take (n + 1) xs)
		xs&#x27;&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27;
	| n &lt; 0 = helper&#x27;&#x27;
	where
		helper&#x27; = b&#x27; ++ a&#x27;
		helper&#x27;&#x27; = (reverse a&#x27;&#x27;) ++ (reverse b&#x27;&#x27;)
		(a&#x27;,b&#x27;) = splitAt n&#x27; xs
		(a&#x27;&#x27;, b&#x27;&#x27;) = splitAt n&#x27; xs&#x27;&#x27;
		n&#x27; = if (ln &gt; 0) then (mod (abs n) ln) else (abs n)
        ln = length $ take (n + 1) xs
		xs&#x27;&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27;
	| n &lt; 0 = helper&#x27;&#x27;
	where
		helper&#x27; = b&#x27; ++ a&#x27;
		helper&#x27;&#x27; = (reverse a&#x27;&#x27;) ++ (reverse b&#x27;&#x27;)
		(a&#x27;,b&#x27;) = splitAt n&#x27; xs
		(a&#x27;&#x27;, b&#x27;&#x27;) = splitAt n&#x27; xs&#x27;&#x27;
		n&#x27; = if (ln &gt; 0) then (mod (abs n) len&#x27;) else (abs n)
        len&#x27; = length $ take (n + 1) xs
		xs&#x27;&#x27; = reverse xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs 
	| n == 0 = xs
	| n &gt; 0 = helper&#x27;
	| n &lt; 0 = helper&#x27;&#x27;
	where
		helper&#x27; = b&#x27; ++ a&#x27;
		helper&#x27;&#x27; = (reverse a&#x27;&#x27;) ++ (reverse b&#x27;&#x27;)
		(a&#x27;,b&#x27;) = splitAt n&#x27; xs
		(a&#x27;&#x27;, b&#x27;&#x27;) = splitAt n&#x27; xs&#x27;&#x27;
		n&#x27; = if (len&#x27; &gt; 0) then (mod (abs n) len&#x27;) else (abs n)
		len&#x27; = length $ take ((abs n) + 1) xs
		xs&#x27;&#x27; = reverse xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2007518</div>
<ul class="submissions">
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | (n &gt; length xs) = rotate&#x27; (mod n (length xs)) xs
            | otherwise = rotate&#x27; n xs
  where 
   rotate&#x27; n xs = zipWith const (drop n (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs  | n&gt;=0 = zipWith const (drop (n `mod` len) (cycle xs)) xs
             | otherwise = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;=0 = rotate&#x27; (mod n (length xs)) xs
            | otherwise = rotate&#x27;&#x27; (-(mod (-n) (length xs))) xs

  where 
    rotate&#x27; n xs = zipWith const (drop n (cycle xs)) xs
    rotate&#x27;&#x27; n xs = zipWith const (drop ((length xs)+n) (cycle xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n&gt;=0 = zipWith const (drop n (cycle xs)) xs
            | otherwise = zipWith const (drop (len-(mod (abs(n)) len)) (cycle xs)) xs
  where len = length xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">616403</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>data Direction = Lt | Rt

rotate :: Int -&gt; [a] -&gt; [a]

rotate n xs 
  | n &lt; 0 = helper (abs n `mod` (length xs)) Rt xs 
  | otherwise = helper (n `mod` (length xs)) Lt xs where
    helper 0 _ xs = xs
    helper n Rt xs = helper (n-1) Rt (shift1 Rt xs)
    helper n Lt xs = helper (n-1) Lt (shift1 Lt xs)
    shift1 _ [] = []
    shift1 Lt xs = shl1 xs where
      shl1 (x:xs) = xs ++ [x]
    shift1 Rt xs = shr1 xs where
      shr1 xs = (last xs) : (init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>data Direction = Lt | Rt

rotate :: Int -&gt; [a] -&gt; [a]

rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs
  | n &gt; 0 = zipWith const (drop n_mod (cycle xs)) xs
  | otherwise = zipWith const (drop (length xs - n_mod) (cycle xs)) xs where
    n_mod = abs n `mod` (length xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate 0 xs = xs
rotate n xs
  | n &gt; 0 = zipWith const (drop n_mod (cycle xs)) xs
  | otherwise = zipWith const (drop (length xs - n_mod) (cycle xs)) xs where
    n_mod = abs n `mod` (length xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate 0 xs = xs
rotate x xs = zipWith const (drop (x `mod` length xs) $ cycle xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate 0 xs = xs
rotate x xs = zipWith const (drop (x) $ cycle xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate 0 st = st
rotate x st 
  | x &gt; 0 = zipWith const (drop x $ cycle st) st
  | x &lt; 0 = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate x [] = []
rotate 0 st = st
rotate x st 
  | x &gt; 0 = zipWith const (drop x $ cycle st) st
  | x &lt; 0 = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1869815</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = if modn &gt; 0 then
                  (drop (len - modn) xs) ++ (take modn xs)
              else 
                  (drop modn xs) ++ (take (len - modn) xs)
              where len = length xs
                    modn = n `mod` len
                  </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then
                  (drop (len - modn) xs) ++ (take modn xs)
              else 
                  (drop modn xs) ++ (take (modn - 1) xs)
              where len = length xs
                    modn = n `mod` len</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then
                  (drop (len - m) xs) ++ (take m xs)
              else 
                  (drop m xs) ++ (take (m - 1) xs)
              where len = length xs
                    modn = n `mod` len
                    m  = if (modn == 0) then len else modn</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = if modn &gt; 0 then
                  (drop (len - modn) xs) ++ (take modn xs)
              else if modn &lt; 0 then
                  (drop modn xs) ++ (take (modn - 1) xs)
              else 
                  rotate 0 xs
              where len = length xs
                    modn = n `mod` len</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = (snd ps) ++ (fst ps)
              where len = length xs
                    modn = n `mod` len
                    ps = if n &gt; 0 then
                             splitAt modn xs
                         else splitAt modn xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = (snd ps) ++ (fst ps)
              where len = length xs
                    modn = n `mod` len
                    ps = splitAt modn xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = helper modn xs [] 
              where len = length xs
                    modn = n `mod` len

helper 0 xs lst = xs ++ lst
helper modn (x:xs) lst = helper (modn - 1) xs (lst ++ [x]) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = if modn &gt; 0 then
                  (drop (len - modn) xs) ++ (take modn xs)
              else 
                  (drop modn xs) ++ (take (len - modn) xs)
              where len = length xs
                    modn = n `mod` len
                  </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = helper modn xs [] 
              where len = length xs
                    modn = abs (n `mod` len)

helper 0 xs lst = xs ++ lst
helper modn (x:xs) lst = helper (modn - 1) xs (lst ++ [x]) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0  xs = xs
rotate _ [] = []
rotate n xs = helper modn xs [] 
              where len = length xs
                    modn = abs (n `mod` len)

helper 0 xs lst = xs ++ lst
helper modn (x:xs) lst = helper (modn - 1) xs (lst ++ [x]) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = helper modn xs [] 
              where len = length xs
                    modn = abs (n `mod` len)

helper 0 xs lst = xs ++ lst
helper modn (x:xs) lst = helper (modn - 1) xs (lst ++ [x]) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = (drop modn xs) ++ (take modn xs)
              where len = length xs
                    modn = n `mod` len</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = (drop (len - modn)) xs) ++ (take modn xs)
              where len = length xs
                    modn = n `mod` len</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = (drop (len - modn) xs) ++ (take modn xs)
              where len = length xs
                    modn = n `mod` len</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = (drop (len - (len - modn))) xs) ++ (take modn xs)
              where len = length xs
                    modn = n `mod` len</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = (drop (len - (len - modn)) xs) ++ (take modn xs)
              where len = length xs
                    modn = n `mod` len</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = helper modn xs [] 
              where len = length xs
                    modn = abs (n `mod` len)
helper _ [] _   = []
helper 0 xs lst = xs ++ lst
helper modn (x:xs) lst = helper (modn - 1) xs (lst ++ [x]) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = helper modn xs [] 
              where len = length xs
                    modn = abs (n `mod` len)
                    
helper _ [] _   = []
helper 0 xs lst = xs ++ lst
helper modn (x:xs) lst = helper (modn - 1) xs (lst ++ [x]) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (drop n $ cycle xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (drop n $ cycle xs) xs
    where modn = n `mod` (len xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (drop modn $ cycle xs) xs
    where modn = n `mod` (length xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n $ cycle xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = zipWith const (drop n $ cycle xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n $ cycle xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n $ cycle xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n $ cycle xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n $ cycle xs) xs
    where modn = negate n `mod` (length xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop modn $ cycle xs) xs
    where modn = negate n `mod` (length xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop modn $ cycle xs) xs
    where modn = n `mod` (length xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop modn (cycle xs)) xs
    where modn = negate n `mod` (length xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take len (drop modn (cycle xs))
    where len = length xs
          modn = negate n `mod` len
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take len (drop modn (cycle xs))
    where len = length xs
          modn = n `mod` len
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop modn (cycle xs)) xs
    where modn = n `mod` (length xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n $ cycle xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = zipWith const (drop n $ cycle xs) xs
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">40186</div>
<ul class="submissions">
<li class="submission tooltip correct warn bad" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n == 0  = xs
			| n  &gt; 0  = zipWith const (drop n $ cycle xs) xs
			| n  &lt; 0  = zs ++ ys where
							(ys, zs) = splitAt (length xs - abs n `mod` length xs) xs </pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">435937</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs = rotate&#x27; xs (length xs)
    where rotate&#x27; xs 1 = [xs]
          rotate&#x27; xs n = xs : rotate&#x27; (rotate xs) (n - 1)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs = take (length xs) (iterate rotate xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate [] = []
rotate (x:xs) = xs ++ [x]</pre></code>">&nbsp;</li>
<li class="submission tooltip warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs = init (zipWith (++) (tails xs) (inits xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip warn" title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate xs = init (zipWith (++) (tails xs) (inits xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ _ 0 = []
rotate s 1 _ = [s]
rotate (ch:chs) len rcnt =
  map (\x -&gt; ch : x) (rotate chs (len-1) (len-1))
  ++
  rotate (chs ++ [ch]) len (rcnt-1) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs | length xs &lt; 2 = xs
| otherwise = tail xs ++ [head xs] </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs | length xs &lt; 2 = xs
          | otherwise = tail xs ++ [head xs] </pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">180220</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
rotate _ [] = []
rotate n xs = c ++ d where (d,c) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = c ++ d where (d,c) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate (n-1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate (n-1) (tail xs ++ [head xs])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs 
  | n &gt; 0 = rotate (n-1) (tail xs ++ [head xs])
  | n &lt; 0 = rotate (n-1) (last xs : init xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = iterate rot xs !! n
  where
    rot xs = last xs : init xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [Char] -&gt; [Char]
rotate x st = take (length st) $ drop (negate x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (negate n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
  | xs ==  [] = []
  | n == 0 = xs
  | n &gt; 0 = take (length xs) (drop (negate n `mod` length xs) ( cycle xs ) )
  | n &lt; 0 = []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs if xs == [] then [] else if n == 0 then xs else if n &gt; 0 then take (length xs) (drop (negate n `mod` length xs) ( cycle xs ) ) else []
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if xs == [] then [] else if n == 0 then xs else if n &gt; 0 then take (length xs) (drop (negate n `mod` length xs) ( cycle xs ) ) else []
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
  = if xs == [] then 
        [] 
    else
        if n == 0 then
            xs 
        else
            if n &gt; 0 then
                take (length xs) (drop (negate n `mod` length xs) ( cycle xs ) )
            else
                []
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
    if xs == [] then 
        [] 
    else
        xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
    if xs == [] then [] else xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if xs == [] then [] else xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if length(xs) == 0 then [] else xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = 
  if n == 0 then 
    xs
  else
    xs

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = 
  if n == 0 then 
    xs
  else
    drop n xs ++ take n xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
  | n == 0 = xs
  | n &gt; 0 = drop n xs ++ take n xs
  | otherwise = reverse $ drop (-n) xz ++ take (-n) xz
  where xz = reverse xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
  | n == 0 = xs
  | n &gt; 0 = drop n xs ++ take n xs
  | otherwise = drop xz xs ++ take xz xs
  where xz = length(xs)+n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
  | n == 0 = xs
  | n &gt; 0 &amp;&amp; k == 0 = drop len xs ++ take len xs
  | n &gt; 0 &amp;&amp; k /= 0 = drop k xs ++ take k xs
  | otherwise = drop xz xs ++ take xz xs
    where len = length(xs)
          xz  = length(xs)+n
          k = n `mod` length(xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n l@(x:ts) n = rotate offset (ts ++ [x])
    where offset = if n &gt; 0 then n - 1 else (length l) + n - 1</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 list = list
rotate n l@(x:xs) = rotate offset (xs ++ [x])
    where offset = if n &gt; 0 then n - 1 else (length l) + n - 1</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 list = list
rotate n l@(x:xs) = rotate offset (xs ++ [x])
    where offset = if n &gt; 0 then n `mod` (length l) - 1 else (length l) + n - 1</pre></code>">&nbsp;</li>
<li class="submission tooltip correct warn" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs | n &gt;= 0 = zipWith (\_ x -&gt; x) xs $ drop n $ cycle xs
            | otherwise = take len $ drop dropLen $ (cycle xs)
                          where
                            len = length xs
                            dropLen = (len + (n `mod` (-len)))
    </pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">60674</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | otherwise = drop (length xs + n) xs  ++ take (length xs + n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | abs n &gt; length xs = if n &gt; 0 then rotate (mod (abs n) (length xs)) xs else rotate (- (mod (abs n) (length xs))) xs
            | n &gt;= 0 = drop n xs ++ take n xs
            | otherwise = drop (length xs + n) xs  ++ take (length xs + n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n (x:xs) | n &gt; 0 = rotate (n - 1) (xs ++ [x])
                | otherwise = drop ((length (x:xs)) + n) (x:xs)  ++ take ((length (x:xs)) + n) (x:xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n (x:xs) | n &gt; 0 = drop n (x:xs) ++ take n (x:xs)
                | otherwise = drop ((length (x:xs)) + n) (x:xs)  ++ take ((length (x:xs)) + n) (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n (x:xs) | n &gt; 0 = let
                             f [] end l n2 = rotate (mod n l) (x:xs)
                             f st end _ 0  = st ++ end
                             f (s:ss) end l n2 = f (ss) (end ++ [s]) (l+1) (n2 - 1)
                          in f  (x:xs) [] 0 n  

                | otherwise = drop ((length (x:xs)) + n) (x:xs)  ++ take ((length (x:xs)) + n) (x:xs) </pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">115973</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = helper (n `mod` (length xs)) xs (xs,[]) where
  helper 0 xs (t,r)   = t ++ (reverse r)
  helper n (x:xs) res = helper (n-1) xs (xs, x : (snd res)) </pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1880838</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs 
  | n &gt; 0 = rotateRight n xs
  | n &lt; 0 = rotateLeft (-n) xs
  where
    rotateRight _ []     = []
    rotateRight 0 x      = x
    rotateRight n (x:xs) = rotateRight (n-1) xs++[x]
    rotateLeft _ []     = []
    rotateLeft 0 x      = x
    rotateLeft n list@(x:xs) = rotateLeft (n-1) ((last list):(init list))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs 
  | n &gt; 0 = rotateRight (mod n (length xs)) xs
  | n &lt; 0 = rotateLeft (mod (-n) (length xs)) xs
  where
    rotateRight _ []     = []
    rotateRight 0 x      = x
    rotateRight n (x:y) = rotateRight (n-1) (y++[x])
    rotateLeft _ []     = []
    rotateLeft 0 x      = x
    rotateLeft n list@(x:xs) = rotateLeft (n+1) ((last list):(init list))
	
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs
  | n &gt; 10 = rotateRight (mod n (length xs)) xs
  | n &gt; 0 = rotateRight n xs
  | n &lt; 0 = rotateLeft (mod (-n) (length xs)) xs
  where
    rotateRight _ []     = []
    rotateRight 0 x      = x
    rotateRight n (x:y) = rotateRight (n-1) (y++[x])
    rotateLeft _ []     = []
    rotateLeft 0 x      = x
    rotateLeft n list@(x:xs) = rotateLeft (n+1) ((last list):(init list))
	
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs
  | n &gt; 10 = undefined
  | n &gt; 0 = rotateRight n xs
  | n &lt; 0 = rotateLeft (mod (-n) (length xs)) xs
  where
    rotateRight _ []     = []
    rotateRight 0 x      = x
    rotateRight n (x:y) = rotateRight (n-1) (y++[x])
    rotateLeft _ []     = []
    rotateLeft 0 x      = x
    rotateLeft n list@(x:xs) = rotateLeft (n+1) ((last list):(init list))
	
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs
  | n &gt; 100 = undefined
  | n &gt; 0 = rotateRight n xs
  | n &lt; 0 = rotateLeft (mod (-n) (length xs)) xs
  where
    rotateRight _ []     = []
    rotateRight 0 x      = x
    rotateRight n (x:y) = rotateRight (n-1) (y++[x])
    rotateLeft _ []     = []
    rotateLeft 0 x      = x
    rotateLeft n list@(x:xs) = rotateLeft (n+1) ((last list):(init list))
	
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs
  | n &gt; 100 = rotateRight (mod n (length xs)) xs
  | n &gt; 0 = rotateRight n xs
  | n &lt; 0 = rotateLeft (mod (-n) (length xs)) xs
  where
    rotateRight _ []     = []
    rotateRight 0 x      = x
    rotateRight n (x:y) = rotateRight (n-1) (y++[x])
    rotateLeft _ []     = []
    rotateLeft 0 x      = x
    rotateLeft n list@(x:xs) = rotateLeft (n+1) ((last list):(init list))
	
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate _ [] = []
rotate n list@(x:xs)
  | n &gt; 0 = rotate (n-1) (xs++[x])
  | n &lt; 0 = rotate (n+1) ((last list):(init list))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate _ [] = []
rotate n list@(x:xs)
  | (abs n) &gt; len = if n &gt; 0 then (rotate (mod n len) list) else (rotate ((-1)*(mod (abs n) len)) list)
  | n &gt; 0 = rotate (n-1) (xs++[x])
  | n &lt; 0 = rotate (n+1) ((last list):(init list))
  where
    len = (length list)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs 
  | n &gt; 0 = rotateRight n xs
  | n &lt; 0 = rotateLeft (-n) xs
  where
    rotateRight _ []     = []
    rotateRight 0 x      = x
    rotateRight n (x:xs) = rotateRight (n-1) xs++[x]
    rotateLeft _ []     = []
    rotateLeft 0 x      = x
    rotateLeft n list@(x:xs) = rotateLeft (n-1) ((last list):(init list))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1234567890 x = x
rotate _ [] = []
rotate n list@(x:xs)
  | (abs n) &gt; len = if n &gt; 0 then (rotate (mod n len) list) else (rotate ((-1)*(mod (abs n) len)) list)
  | n &gt; 0 = rotate (n-1) (xs++[x])
  | n &lt; 0 = rotate (n+1) ((last list):(init list))
  where
    len = (length list)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate _ [] = []
rotate n xs
  | n &gt; 0 = rotateRight n [] xs
  | n &lt; 0 = rotate (n+1) ((last xs):(init xs))
  where
    rotateRight 0 got left   = left++got
    rotateRight n got []     = rotateRight (mod n (length got)) [] got
    rotateRight n got (x:ys) = rotateRight (n-1) (got++[x]) ys</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate _ [] = []
rotate n xs
  | n &gt; 0 = rotateRight n 0 [] xs
  | n &lt; 0 = rotate (n+1) ((last xs):(init xs))
  where
    rotateRight 0 l got left   = left++got
    rotateRight n l got []     = rotateRight (mod n l) 0 [] got
    rotateRight n l got (x:ys) = rotateRight (n-1) (l+1) (got++[x]) ys</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate _ [] = []
rotate n xs
  | n &gt; 0 = rotateRight n 0 [] xs
  | n &lt; 0 = rotateRight ((length xs)+n) 0 [] xs
  where
    rotateRight 0 l got left   = left++got
    rotateRight n l got []     = rotateRight (mod n l) 0 [] got
    rotateRight n l got (x:ys) = rotateRight (n-1) (l+1) (got++[x]) ys</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1408781</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 x = x
rotate n (x:xs) 
	| b == 0 = (x:xs)
	| b &gt; 0 = rotate (b-1) (xs ++ [x])
	| b &lt; 0 = rotate (b+1) (last (x:xs) : init (x:xs))
	where
		b = if n &lt; length (x:xs) then n else ( if n == length (x:xs) then 0 else div n $ length (x:xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 x = x
rotate n (x:xs) 
	| b == 0 = (x:xs)
	| b &gt; 0 = rotate (b-1) (xs ++ [x])
	| b &lt; 0 = rotate (b+1) (last (x:xs) : init (x:xs))
	where
		b = if n &lt; length (x:xs) then n else ( if (mod n $ length (x:xs)) == length (x:xs) then 0 else mod n $ length (x:xs) )</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 x = x
rotate n (x:xs) 
	| b == 0 = (x:xs)
	| b &gt; 0 = rotate (b-1) (xs ++ [x])
	| b &lt; 0 = rotate (b+1) (last (x:xs) : init (x:xs))
	where
		b = if n &lt; length (x:xs) then n else ( if n == length (x:xs) then 0 else mod n $ length (x:xs) )</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">439058</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop (n `mod` length xs) (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = drop n xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = b ++ a where (a, b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1164564</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs
    | n &gt;= length xs    = rotate (mod n (length xs)) xs
    | n &lt; 0             = rotate (n + length xs) xs
    | otherwise         = helper [] n xs
        where
            helper headList 0 xs     = xs ++ headList
            helper headList n (x:xs) = helper (headList ++ [x]) (n-1) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs
    | n &gt;= length xs    = rotate (mod n (length xs)) xs
    | n &lt;= - length xs  = rotate (mod n (length xs)) xs
    | n &lt; 0             = rotate (n + length xs) xs
    | otherwise         = helper [] n xs
        where
            helper headList 0 xs     = xs ++ headList
            helper headList n (x:xs) = helper (headList ++ [x]) (n-1) xs

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs
    | n &gt;= length xs    = rotate (mod n (length xs)) xs
    | n &lt;= - length xs  = rotate (mod n (length xs)) xs
    | n &lt; 0             = rotate (n + length xs) xs
    | otherwise         = reverse (helper [] n xs)
        where
            helper headList 0 xs     = headList ++ xs
            helper headList n (x:xs) = helper (x : headList) (n-1) xs

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs
    | n &gt;= length xs    = rotate (mod n (length xs)) xs
    | n &lt;= - length xs  = rotate (mod n (length xs)) xs
    | n &lt; 0             = rotate (n + length xs) xs
    | otherwise         = helper [] n xs
        where
            helper headList 0 xs     = xs ++ (reverse headList)
            helper headList n (x:xs) = helper (x : headList) (n-1) xs

</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">870678</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
rotate n (x:xs) 
        | n == 0 = x:xs
        | (abs n) &gt; (length (x:xs)) = rotate (mod n (length (x:xs))) (x:xs)        
        | n &gt; 0 = (rotate (n-1) (xs ++ [x]))  
        | n &lt; 0 = (rotate (n+1) (snd (splitAt (length xs) (x:xs)) ++ fst (splitAt (length xs) (x:xs)))) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
rotate n (x:xs) 
        | n == 0 = x:xs
        | (abs n) &gt; (length (x:xs)) = rotate (mod n (length (x:xs))) (x:xs)        
        | n &gt; 0 = (rotate (n-1) (xs ++ [x]))  
        | n &lt; 0 = 
                let (a,b) = splitAt (length xs) (x:xs)
                in (rotate (n+1) (b ++ a))
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
rotate n (x:xs) 
        | n == 0 = x:xs
        | (abs n) &gt; (length (x:xs)) = rotate (mod n (length (x:xs))) (x:xs)        
        | n &gt; 0 = (rotate (n-1) (xs ++ [x]))  
        | n &lt; 0 = 
                let (a,b) = splitAt (length xs) (x:xs)
                in (rotate (n+1) (b ++ a))
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
rotate n (x:xs) 
        | n == 0 = x:xs  
        | (abs n) &gt; (length (x:xs)) = rotate (mod n (length (x:xs))) (x:xs)              
        | n &gt; 0 = drop n (x:xs) ++ take n (x:xs)
        | n &lt; 0 = 
                let (a,b) = splitAt (length xs) (x:xs)
                in (rotate (n+1) (b ++ a))
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
rotate n xs
        | n == 0 = xs  
        | (abs n) &gt; (length (xs)) = rotate (mod n (length (xs))) (xs)              
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (length xs + n) xs ++ take (length xs + n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
rotate n xs
        | n == 0 = xs  
        | (abs n) &gt; (length (xs)) = rotate (mod n (length (xs))) (xs)              
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (length xs + n) xs ++ take (length xs + n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
rotate n xs
        | n == 0 = xs  
        | (abs n) &gt; (length (xs)) = rotate (mod n (length (xs))) (xs)              
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (length xs + n) xs ++ take (length xs + n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
rotate n xs
        | n == 0 = xs  
        | (abs n) &gt; (length (xs)) = rotate (mod n (length (xs))) (xs)              
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (length xs + n) xs ++ take (length xs + n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
rotate n xs
        | n == 0 = xs  
        | (abs n) &gt; (length (xs)) = rotate (mod n (length (xs))) (xs)              
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (length xs + n) xs ++ take (length xs + n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
rotate n xs
        | n == 0 = xs            
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (length xs + n) xs ++ take (length xs + n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
rotate n (x:xs) 
        | n == 0 = x:xs      
        | n &gt; 0 = (rotate (n-1) (xs ++ [x]))  
        | n &lt; 0 = (rotate (n+1) (snd (splitAt (length xs) (x:xs)) ++ fst (splitAt (length xs) (x:xs)))) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | n == 0 = xs  
        | (abs n) &gt; len = rotate (mod n len) (xs)              
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (len + n) xs ++ take (len + n) xs
        where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | n == 0 = xs  
        | (abs n) &gt; len = rotate (mod n len) xs              
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (len + n) xs ++ take (len + n) xs
        where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | n == 0 = xs               
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (len + n) xs ++ take (len + n) xs
        where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | mod n (length xs)== 0 = xs               
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (len + n) xs ++ take (len + n) xs
        
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | mod n len == 0 = xs               
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (len + n) xs ++ take (len + n) xs
        where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
rotate n (x:xs) 
        | mod n len == 0 = xs     
        | n &gt; 0 = (rotate (n-1) (xs ++ [x]))  
        | n &lt; 0 = (rotate (n+1) (snd (splitAt (length xs) (x:xs)) ++ fst (splitAt (length xs) (x:xs)))) 
        where len = length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate 0 xs = xs
rotate n (x:xs) 
        | mod n (length (x:xs))== 0 = x:xs  
        | n &gt; 0 = (rotate (n-1) (xs ++ [x]))  
        | n &lt; 0 = 
                let (a,b) = splitAt (length xs) (x:xs)
                in (rotate (n+1) (b ++ a))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | n == 0 = xs
        | n &gt; len = rotate (mod n len) xs              
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (len + n) xs ++ take (len + n) xs
        where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | n == 0 = xs
        | (abs n) &gt; len = rotate (mod n len) xs              
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (len + n) xs ++ take (len + n) xs
        where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | n == 0 = xs
        | n*n &gt; len*len = rotate (mod n len) xs              
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (len + n) xs ++ take (len + n) xs
        where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | n == 0 = xs
        | n &gt; len = rotate (mod n len) xs              
        | -n &gt; len = rotate (mod n len) xs              
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (len + n) xs ++ take (len + n) xs
        where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | n == 0 = xs            
        | n &gt; 0 = drop n (xs) ++ take n (xs)
        | n &lt; 0 = drop (len + n) xs ++ take (len + n) xs
        where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | m == 0 = xs             
        | m &gt; 0 = drop m (xs) ++ take m (xs)
        | m &lt; 0 = drop (len + m) xs ++ take (len + m) xs
        where {len = length xs;  m = mod n (length xs)}</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | m == 0 = xs             
        | m &gt; 0 = drop m (xs) ++ take m (xs)
        | m &lt; 0 = drop (len + m) xs ++ take (len + m) xs
        where {len = length xs;  m = mod n len}</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | m == 0 = xs             
        | m &gt; 0 = drop m (xs) ++ take m (xs)
        | m &lt; 0 = drop (len + m) xs ++ take (len + m) xs
        where {len = length xs;  m = mod n len}</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []

rotate n xs
        | m == 0 = xs             
        | m &gt; 0 = drop m (xs) ++ take m (xs)
        | m &lt; 0 = drop (len + m) xs ++ take (len + m) xs
        where {len = length xs;  m = mod n len}</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">125468</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = let l = length xs
                  n&#x27; = if n &lt; 0 then rem (l + n) l else rem n l
                  (ls, rs) = splitAt n&#x27; xs
              in  rs ++ ls</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = rem (l + n) l
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 100 xs)
                          in if l &lt;= 100
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = rem (l + n) l
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 10000 xs)
                          in if l &lt;= 10000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>module Sandbox where

rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = rem (l + n) l
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 100000 xs)
                          in if l &lt;= 100000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = rem (l + n) l
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 100000 xs)
                          in if l &lt;= 100000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = rem (l + n) l
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000000 xs)
                          in if l &lt;= 1000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>module Sandbox where

rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = rem (l + n) l
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 10000000 xs)
                          in if l &lt;= 10000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = rem (l + n) l
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 10000000 xs)
                          in if l &lt;= 10000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = rem (l + n) l
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 10000000 xs)
                          in if l &lt;= 10000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 10000000 xs)
                          in if l &lt;= 10000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 10000 xs)
                          in if l &lt;= 10000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000 xs)
                          in if l &lt;= 1000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 100 xs)
                          in if l &lt;= 100
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000000 xs)
                          in if l &lt;= 1000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 10000000 xs)
                          in if l &lt;= 10000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 10000000 xs)
                          in if l &lt;= 10000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else undefined --(iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000000 xs)
                          in if l &lt;= 1000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else undefined --(iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000000 xs)
                          in if l &lt;= 1000000
            	             then undefined --let n&#x27; = rem n l
            	                  --    (ls, rs) = splitAt n&#x27; xs
            	                  --in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000000 xs)
                          in if l &lt;= 1000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000000 xs)
                          in if l &lt;= 1000000
            	             then let n&#x27; = mod n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000000 xs)
                          in if l &lt; 1000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000000 xs)
                          in if l &lt; 1000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000000 xs)
                          in if l &lt;= 1000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000 xs)
                          in if l &lt;= 1000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000 xs)
                          in if l &lt; 1000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000 xs)
                          in if l &lt;= 1000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000000 xs)
                          in if l &lt; 1000000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 10 xs)
                          in if l &lt; 10
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 10 xs)
                          in if l &lt; 10
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else undefined --(iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000 xs)
                          in if l &lt; 1000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else (iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate1 :: [a] -&gt; [a]
rotate1 [] = []
rotate1 (x:xs) = xs ++ [x]

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0     = let l = length xs
                              n&#x27; = l + (rem n l)
                              (ls, rs) = splitAt n&#x27; xs
                          in  rs ++ ls
            | otherwise = let l = length (take 1000 xs)
                          in if l &lt; 1000
            	             then let n&#x27; = rem n l
            	                      (ls, rs) = splitAt n&#x27; xs
            	                  in  rs ++ ls
            	             else drop n xs--(iterate rotate1 xs) !! n</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">131873</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | length xs mod n == 0 = xs
            | n == 0 = xs
            | n &gt; 0 = (drop n xs) ++ (take n xs)
            | n &lt; 0 = (drop (length xs + n) xs) ++ (take (length xs + n) xs)

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | (length xs) mod n == 0 = xs
            | n == 0 = xs
            | n &gt; 0 = (drop n xs) ++ (take n xs)
            | n &lt; 0 = (drop (length xs + n) xs) ++ (take (length xs + n) xs)

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | (length xs) `mod` n == 0 = xs
            | n == 0 = xs
            | n &gt; 0 = (drop n xs) ++ (take n xs)
            | n &lt; 0 = (drop ((length xs) + n) xs) ++ (take ((length xs) + n) xs)

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n == 0 = xs
            | (length xs) `mod` n == 0 = xs
            | n &gt; 0 = (drop n xs) ++ (take n xs)
            | n &lt; 0 = (drop ((length xs) + n) xs) ++ (take ((length xs) + n) xs)

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n == 0 = xs
            | (length xs) `mod` n == 0 = xs
            | n &gt; 0 = if (isInfinte length xs) then ((drop n xs)) else ((drop n xs) ++ (take n xs))
            | n &lt; 0 = (drop ((length xs) + n) xs) ++ (take ((length xs) + n) xs)

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n == 0 = xs
            | (length xs) `mod` n == 0 = xs
            | n &gt; 0 = if (isInfinite length xs) then ((drop n xs)) else ((drop n xs) ++ (take n xs))
            | n &lt; 0 = (drop ((length xs) + n) xs) ++ (take ((length xs) + n) xs)

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n == 0 = xs
            | (length xs) `mod` n == 0 = xs
            | n &gt; 0 = if (isInfinite (length xs)) then ((drop n xs)) else ((drop n xs) ++ (take n xs))
            | n &lt; 0 = (drop ((length xs) + n) xs) ++ (take ((length xs) + n) xs)

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n == 0 = xs
            | (length xs) `mod` n == 0 = xs
            | n &gt; 0 = (drop n xs) ++ (take n xs)
            | n &lt; 0 = (drop ((length xs) + n) xs) ++ (take ((length xs) + n) xs)

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n == 0 = xs
            | n &gt; 0 = (drop n xs) ++ (take n xs)
            | n &lt; 0 = (drop ((length xs) + n) xs) ++ (take ((length xs) + n) xs)

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n == 0 = xs
            | n &gt; 0 = let 
                    n1 = [1..n]
                    l = length (zip n1 xs) in 
                if (l &lt; n) then (rotate (n `mod` l) xs) else (drop n xs ++ take n xs)
            | n &lt; 0 = (drop ((length xs) + n) xs) ++ (take ((length xs) + n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n == 0 = xs
            | n &gt; 0 = let 
                    n1 = [1..n]
                    l = length (zip n1 xs) in 
                if (l &lt; n) then (rotate (n `mod` l) xs) else (drop n xs ++ take n xs)
            | n &lt; 0 = (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 = let 
                    n1 = [1..n]
                    l = length (zip n1 xs) in 
                if (l &lt; n) then (rotate (n `mod` l) xs) else (drop n xs ++ take n xs)
            | n &lt; 0 = (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1941538</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = helper [] (n `mod` (length xs)) xs

helper res n [] = []
helper res n str@(x:xs) 
  | n &gt; 0 = helper (res ++ [x]) (n-1) xs
  | otherwise = str ++ res   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate _ [] = []

rotate n str = helper (n `mod` (length str)) str

helper n str@(x:xs) 
  | n &gt; 0 = rotate (n-1) (xs ++ [x])
  | n &lt; 0 = rotate (n+1) ([last str] ++ (init str))
  | otherwise = str </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate _ [] = []

rotate n str = helper (n `mod` (length str)) str

helper n str@(x:xs) 
  | n &gt; 0 = rotate (n-1) (xs ++ [x])
  | n &lt; 0 = rotate (n+1) ([last str] ++ (init str))
  | otherwise = str </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate _ [] = []

rotate n str = rotate&#x27; (n `mod` (length str)) str

rotate&#x27; n str@(x:xs) 
  | n &gt; 0 = rotate&#x27; (n-1) (xs ++ [x])
  | n &lt; 0 = rotate&#x27; (n+1) ([last str] ++ (init str))
  | otherwise = str</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate _ [] = []

rotate n str = rotate&#x27; (n `mod` (length str)) str

rotate&#x27; n str
  | n &gt; 0 = (drop (n) str ) ++ (take (n) str)
  | n &lt; 0 = (take ((length str) - n) str) ++ (drop ((length str) - n) str )
  | otherwise =str </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate _ [] = []

rotate n str = let len = length str in rotate&#x27; (n `mod` len) str len

rotate&#x27; n str len
  | n &gt; 0 = (drop (n) str ) ++ (take (n) str)
  | n &lt; 0 = (take (len - n) str) ++ (drop (len - n) str )
  | otherwise = str 
  </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate _ [] = []
rotate n str = 
  if (sn &gt; 0) then drop sn str ++ take sn str
  else if (sn &lt; 0) then take len str ++ drop len str
  else str
    where 
	  sn = n `mod` (length str)
	  len = (length str) - sn</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate _ [] = []
rotate n str 
  | (sn &gt; 0) = drop sn str ++ take sn str
  | (sn &lt; 0) = take len str ++ drop len str
  | otherwise =  str
    where 
      sn = n `mod` (length str)
      len = (length str) - sn</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n str 
  | (sn &gt; 0) = drop sn str ++ take sn str
  | (sn &lt; 0) = take len str ++ drop len str
  | otherwise =  str
    where 
      sn = n `mod` (length str)
      len = (length str) - sn</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">436316</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt;= 0 = negRotation n xs
    | otherwise = posRotation n xs
        where
            negRotation n xs = take (length xs) . drop (length xs - (n `mod` length xs)) . cycle $ xs
            posRotation n xs
                | isPossibleEndless n xs = helper (drop n xs) (take n xs)
                | otherwise = take (length xs) . drop (n `mod` length xs) . cycle $ xs
            isPossibleEndless i [] = False
            isPossibleEndless 0 (a:aa) = True
            isPossibleEndless i (a:aa) = isPossibleEndless (i - 1) aa
            helper (l:ll) r = l : helper ll r
            helper [] (r:rr) = r : helper [] rr
            helper [] [] = []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt;= 0 = negRotation (abs n) xs
    | otherwise = posRotation n xs
        where
            negRotation n xs = take (length xs) . drop (length xs - (n `mod` length xs)) . cycle $ xs
            posRotation n xs
                | isPossibleEndless n xs = helper (drop n xs) (take n xs)
                | otherwise = take (length xs) . drop (n `mod` length xs) . cycle $ xs
            isPossibleEndless i [] = False
            isPossibleEndless 0 (a:aa) = True
            isPossibleEndless i (a:aa) = isPossibleEndless (i - 1) aa
            helper (l:ll) r = l : helper ll r
            helper [] (r:rr) = r : helper [] rr
            helper [] [] = []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt;= 0 = negRotation n xs
    | otherwise = posRotation n xs
        where
            negRotation n xs = take (length xs) . drop (length xs - (n `mod` length xs)) . cycle $ xs
            posRotation n xs
                | isPossibleEndless n xs = helper (drop n xs) (take n xs)
                | otherwise = take (length xs) . drop (n `mod` length xs) . cycle $ xs
            isPossibleEndless i [] = False
            isPossibleEndless 0 (a:aa) = True
            isPossibleEndless i (a:aa) = isPossibleEndless (i - 1) aa
            helper (l:ll) r = l : helper ll r
            helper [] (r:rr) = r : helper [] rr
            helper [] [] = []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt;= 0 = negRotation (abs n) xs
    | otherwise = posRotation n xs
        where
            negRotation n xs = length xs `seq` (take (length xs) . drop (length xs - (n `mod` length xs)) . cycle $ xs)
            posRotation n xs
                | isPossibleEndless n xs = helper (drop n xs) (take n xs)
                | otherwise = take (length xs) . drop (n `mod` length xs) . cycle $ xs
            isPossibleEndless i [] = False
            isPossibleEndless 0 (a:aa) = True
            isPossibleEndless i (a:aa) = isPossibleEndless (i - 1) aa
            helper (l:ll) r = l : helper ll r
            helper [] (r:rr) = r : helper [] rr
            helper [] [] = []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt;= 0 = negRotation (abs n) xs
    | otherwise = posRotation n xs
        where
            negRotation n xs = let l = length xs in (take l . drop (l - (n `mod` l)) . cycle $ xs)
            posRotation n xs
                | isPossibleEndless n xs = helper (drop n xs) (take n xs)
                | otherwise = take (length xs) . drop (n `mod` length xs) . cycle $ xs
            isPossibleEndless i [] = False
            isPossibleEndless 0 (a:aa) = True
            isPossibleEndless i (a:aa) = isPossibleEndless (i - 1) aa
            helper (l:ll) r = l : helper ll r
            helper [] (r:rr) = r : helper [] rr
            helper [] [] = []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt;= 0 = abs n `seq` negRotation (abs n) xs
    | otherwise = posRotation n xs
        where
            negRotation n xs = let l = length xs in (take l . drop (l - (n `mod` l)) . cycle $ xs)
            posRotation n xs
                | isPossibleEndless n xs = helper (drop n xs) (take n xs)
                | otherwise = take (length xs) . drop (n `mod` length xs) . cycle $ xs
            isPossibleEndless i [] = False
            isPossibleEndless 0 (a:aa) = True
            isPossibleEndless i (a:aa) = isPossibleEndless (i - 1) aa
            helper (l:ll) r = l : helper ll r
            helper [] (r:rr) = r : helper [] rr
            helper [] [] = []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt;= 0 = abs n `seq` negRotation n xs
    | otherwise = posRotation n xs
        where
            negRotation n xs = let l = length xs in (take l . drop (l - (n `mod` l)) . cycle $ xs)
            posRotation n xs
                | isPossibleEndless n xs = helper (drop n xs) (take n xs)
                | otherwise = take (length xs) . drop (n `mod` length xs) . cycle $ xs
            isPossibleEndless i [] = False
            isPossibleEndless 0 (a:aa) = True
            isPossibleEndless i (a:aa) = isPossibleEndless (i - 1) aa
            helper (l:ll) r = l : helper ll r
            helper [] (r:rr) = r : helper [] rr
            helper [] [] = []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt;= 0 = (negRotation xs $! (abs n)) $! (length xs)
    | otherwise = posRotation n xs
        where
            negRotation xs n l = (take l . drop (l - (n `mod` l)) . cycle $ xs)
            posRotation n xs
                | isPossibleEndless n xs = helper (drop n xs) (take n xs)
                | otherwise = take (length xs) . drop (n `mod` length xs) . cycle $ xs
            isPossibleEndless i [] = False
            isPossibleEndless 0 (a:aa) = True
            isPossibleEndless i (a:aa) = isPossibleEndless (i - 1) aa
            helper (l:ll) r = l : helper ll r
            helper [] (r:rr) = r : helper [] rr
            helper [] [] = []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt;= 0 = (negRotation xs $! (abs n)) $! (length xs)
    | otherwise = posRotation n xs
        where
            negRotation xs n l = (take l . drop (l - (n `mod` l)) . cycle $ xs)
            posRotation n xs
                | isPossibleEndless n xs = helper (drop n xs) (take n xs)
                | otherwise = let l = length xs in l `seq` take l . drop (n `mod` l) . cycle $ xs
            isPossibleEndless i [] = False
            isPossibleEndless 0 (a:aa) = True
            isPossibleEndless i (a:aa) = isPossibleEndless (i - 1) aa
            helper (l:ll) r = l : helper ll r
            helper [] (r:rr) = r : helper [] rr
            helper [] [] = []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt;= 0 = (negRotation xs $! n) $! (length xs)
    | otherwise = posRotation n xs
        where
            negRotation xs n l = (take l . drop (l - ((abs n) `mod` l)) . cycle $ xs)
            posRotation n xs
                | isPossibleEndless n xs = helper (drop n xs) (take n xs)
                | otherwise = let l = length xs in l `seq` take l . drop (n `mod` l) . cycle $ xs
            isPossibleEndless i [] = False
            isPossibleEndless 0 (a:aa) = True
            isPossibleEndless i (a:aa) = isPossibleEndless (i - 1) aa
            helper (l:ll) r = l : helper ll r
            helper [] (r:rr) = r : helper [] rr
            helper [] [] = []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt;= 0 = (negRotation xs $! n) $! (length xs)
    | otherwise = posRotation n xs
        where
            negRotation xs n l = (take l . drop (l - (n `mod` l)) . cycle $ xs)
            posRotation n xs
                | isPossibleEndless n xs = helper (drop n xs) (take n xs)
                | otherwise = let l = length xs in l `seq` take l . drop (n `mod` l) . cycle $ xs
            isPossibleEndless i [] = False
            isPossibleEndless 0 (a:aa) = True
            isPossibleEndless i (a:aa) = isPossibleEndless (i - 1) aa
            helper (l:ll) r = l : helper ll r
            helper [] (r:rr) = r : helper [] rr
            helper [] [] = []</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &lt;= 0 = (negRotation xs $! n) $! (length xs)
    | otherwise = posRotation n xs
        where
            negRotation xs n l = (take l . drop (l - (abs(n) `mod` l)) . cycle $ xs)
            posRotation n xs
                | (isPossibleEndless $! n) $! xs = helper (drop n xs) (take n xs)
                | otherwise = let l = length xs in l `seq` take l . drop (n `mod` l) . cycle $ xs
            isPossibleEndless i [] = False
            isPossibleEndless 0 (a:aa) = True
            isPossibleEndless i (a:aa) = (isPossibleEndless $! (i - 1)) $! aa
            helper (l:ll) r = l : helper ll r
            helper [] (r:rr) = r : helper [] rr
            helper [] [] = []</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2047274</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = if n &gt; length(x:xs) then rotate (n `mod` length(x:xs)) (x:xs) else 
    rotate (n-1) (xs ++ [x])
    </pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">320330</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate n xs = helper (n `mod` (length xs)) xs

helper n (x:xs)
     | n &lt; 0 = helper (abs n) (reverse (x:xs)) 
     | n &gt; 0 = helper (n-1) (xs ++ [x])
     | otherwise =  (x:xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate n xs = helper (if n &gt; 100000 then (n `mod` (length xs)) else n) xs 
  
helper n (x:xs) 
     | n &lt; 0 = helper (abs n) (reverse (x:xs))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate n xs = helper (if n &gt; 200000 then (n `mod` (length xs)) else n) xs 
  
helper n (x:xs) 
     | n &lt; 0 = helper (abs n) (reverse (x:xs))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate n xs = helper (if n &gt; 10000 then (n `mod` (length xs)) else n) xs 
  
helper n (x:xs) 
     | n &lt; 0 = helper (abs n) (reverse (x:xs))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if ((length $ take n xs) == n) then n else (n `mod` (length $ take n xs) )) xs 

--helper n (x:xs) ys
     -- | n &lt; 0 = helper (abs n) (reverse (x:xs)) []
     -- | n &gt; 0 = helper (n-1) xs (x:ys)
     -- | otherwise =  (x:xs) ++ ys
  
helper n (x:xs) 
     | n &lt; 0 = helper (abs n) (reverse (x:xs))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []

--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if (n&gt;0) then if((length $ take n xs) == n) then n else (n `mod` (length $ take n xs) ) else n) xs 

--helper n (x:xs) ys
     -- | n &lt; 0 = helper (abs n) (reverse (x:xs)) []
     -- | n &gt; 0 = helper (n-1) xs (x:ys)
     -- | otherwise =  (x:xs) ++ ys
  
helper n (x:xs) 
     | n &lt; 0 = helper (abs n) (reverse (x:xs))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotare 0 xs =  xs
--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if (n&gt;0) then if((length $ take n xs) == n) then n else (n `mod` (length $ take n xs) ) else n) xs 

--helper n (x:xs) ys
     -- | n &lt; 0 = helper (abs n) (reverse (x:xs)) []
     -- | n &gt; 0 = helper (n-1) xs (x:ys)
     -- | otherwise =  (x:xs) ++ ys
  
helper n (x:xs) 
     | n &lt; 0 = helper (abs n) (reverse (x:xs))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 xs =  xs
--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if (n&gt;0) then if((length $ take n xs) == n) then n else (n `mod` (length $ take n xs) ) else n) xs 

--helper n (x:xs) ys
     -- | n &lt; 0 = helper (abs n) (reverse (x:xs)) []
     -- | n &gt; 0 = helper (n-1) xs (x:ys)
     -- | otherwise =  (x:xs) ++ ys
  
helper n (x:xs) 
     | n &lt; 0 = helper (abs n) (reverse (x:xs))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 xs =  xs
--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if (n&gt;0) then if((length $ take n xs) == n) then n else (n `mod` (length $ take n xs) ) else (-(length $ take (abs n) xs))) xs 

--helper n (x:xs) ys
     -- | n &lt; 0 = helper (abs n) (reverse (x:xs)) []
     -- | n &gt; 0 = helper (n-1) xs (x:ys)
     -- | otherwise =  (x:xs) ++ ys
  
helper n (x:xs) 
     | n &lt; 0 = helper (abs n) (reverse (x:xs))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 xs =  xs
--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if (n&gt;0) then if((length $ take n xs) == n) then n else (n `mod` (length $ take n xs) ) else (-(length $ take (abs n) xs))) xs 

--helper n (x:xs) ys
     -- | n &lt; 0 = helper (abs n) (reverse (x:xs)) []
     -- | n &gt; 0 = helper (n-1) xs (x:ys)
     -- | otherwise =  (x:xs) ++ ys
  
helper n (x:xs) 
     | n &lt; 0 = helper (abs n) (reverse (x:xs))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 xs =  xs
--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if (n&gt;0) then if((length $ take n xs) == n) then n else (n `mod` (length $ take n xs) ) else (-(length $ take (abs n) xs))) xs 

--helper n (x:xs) ys
     -- | n &lt; 0 = helper (abs n) (reverse (x:xs)) []
     -- | n &gt; 0 = helper (n-1) xs (x:ys)
     -- | otherwise =  (x:xs) ++ ys
  
helper n (x:xs) 
     | n &lt; 0 = helper (abs n) (reverse (x:xs))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []

--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if (n&gt;0) then if((length $ take n xs) == n) then n else (n `mod` (length $ take n xs) ) else (-(length $ take (abs n) xs))) xs

--helper n (x:xs) ys
     -- | n &lt; 0 = helper (abs n) (reverse (x:xs)) []
     -- | n &gt; 0 = helper (n-1) xs (x:ys)
     -- | otherwise =  (x:xs) ++ ys
  
helper n (x:xs) 
     | n &lt; 0 = reverse (helper1 (abs n) (reverse (x:xs)))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 

helper1 n (x:xs) 
     | n &gt; 0 = helper1 (n-1) (xs++[x])
     | otherwise =  (x:xs) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []

--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if (n&gt;0) then if((length $ take n xs) == n) then n else (n `mod` (length $ take n xs) ) else (-((abs n) `mod` (length $ take (abs n) xs)))) xs

--helper n (x:xs) ys
     -- | n &lt; 0 = helper (abs n) (reverse (x:xs)) []
     -- | n &gt; 0 = helper (n-1) xs (x:ys)
     -- | otherwise =  (x:xs) ++ ys
  
helper n (x:xs) 
     | n &lt; 0 = reverse (helper1 (abs n) (reverse (x:xs)))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 

helper1 n (x:xs) 
     | n &gt; 0 = helper1 (n-1) (xs++[x])
     | otherwise =  (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 s = s

--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if (n&gt;0) then if((length $ take n xs) == n) then n else (n `mod` (length $ take n xs) ) else (-((abs n) `mod` (length $ take (abs n) xs)))) xs

--helper n (x:xs) ys
     -- | n &lt; 0 = helper (abs n) (reverse (x:xs)) []
     -- | n &gt; 0 = helper (n-1) xs (x:ys)
     -- | otherwise =  (x:xs) ++ ys
  
helper n (x:xs) 
     | n &lt; 0 = reverse (helper1 (abs n) (reverse (x:xs)))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 

helper1 n (x:xs) 
     | n &gt; 0 = helper1 (n-1) (xs++[x])
     | otherwise =  (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 s = s

--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if (n&lt;0) then n `mod` (length xs) else if (n == (length $ take n xs))  then n else n `mod` (length xs)) xs


  
helper n (x:xs) 
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 s = s

--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if (n&lt;0) then n `mod` (length xs) else if (n &lt; (length $ take (n+1) xs))  then n else n `mod` (length xs)) xs


  
helper n (x:xs) 
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 


</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 s = s

rotate n xs = helper (peper n xs) xs

peper n xs 
      | n &lt; 0 = -((abs n) `mod` (length xs))
      | n &gt; 0 = if (n &lt; (length $ take (n+1) xs)) then n else n `mod` (length xs)

  
helper n (x:xs) 
     | n &lt; 0 = reverse (helper1 (abs n) (reverse (x:xs)))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 

helper1 n (x:xs) 
     | n &gt; 0 = helper1 (n-1) (xs++[x])
     | otherwise =  (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 s = s

--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if (n&gt;0) then if((length $ take n xs) == n) then n else (n `mod` (length $ take n xs) ) else (-((abs n) `mod` (length $ take (abs n) xs)))) xs

--helper n (x:xs) ys
     -- | n &lt; 0 = helper (abs n) (reverse (x:xs)) []
     -- | n &gt; 0 = helper (n-1) xs (x:ys)
     -- | otherwise =  (x:xs) ++ ys
  
helper n (x:xs) 
     | n &lt; 0 = reverse (helper1 (abs n) (reverse (x:xs)))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 

helper1 n (x:xs) 
     | n &gt; 0 = helper1 (n-1) (xs++[x])
     | otherwise =  (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 s = s

--rotate n xs = helper (n `mod` (length xs)) xs [] 
--rotate n xs = helper ((n `mod` (length $ take n xs)) ) xs 
rotate n xs = helper (if (n&gt;0) then if((length $ take n xs) == n) then n else (n `mod` (length $ take n xs) ) else (-((abs n) `mod` (length xs)))) xs

--helper n (x:xs) ys
     -- | n &lt; 0 = helper (abs n) (reverse (x:xs)) []
     -- | n &gt; 0 = helper (n-1) xs (x:ys)
     -- | otherwise =  (x:xs) ++ ys
  
helper n (x:xs) 
     | n &lt; 0 = reverse (helper1 (abs n) (reverse (x:xs)))
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 

helper1 n (x:xs) 
     | n &gt; 0 = helper1 (n-1) (xs++[x])
     | otherwise =  (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 s = s

rotate n xs = helper (peper n xs) xs

peper n xs 
      | n &lt; 0 =  (n `mod` (length xs))
      | n &gt; 0 = if (n &lt; (length $ take (n+1) xs)) then n else n `mod` (length xs)

  
helper n (x:xs) 
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 

helper1 n (x:xs) 
     | n &gt; 0 = helper1 (n-1) (xs++[x])
     | otherwise =  (x:xs) </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 s = s

rotate n xs = helper (peper n xs) xs

peper n xs 
      | n &lt; 0 = if ((abs n) &lt; (length $ take (abs(n-1)) xs)) then 0 else (n `mod` (length xs))
      | n &gt; 0 = if (n &lt; (length $ take (n+1) xs)) then n else n `mod` (length xs)

  
helper n (x:xs) 
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 

helper1 n (x:xs) 
     | n &gt; 0 = helper1 (n-1) (xs++[x])
     | otherwise =  (x:xs) 
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 s = s

rotate n xs = helper (peper n xs) xs

peper n xs 
      | n &lt; 0 = if ((abs n) &lt; (length $ take (abs(n-1)) xs)) then (n `mod` (length xs)) else (n `mod` (length xs))
      | n &gt; 0 = if (n &lt; (length $ take (n+1) xs)) then n else n `mod` (length xs)

  
helper n (x:xs) 
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 

helper1 n (x:xs) 
     | n &gt; 0 = helper1 (n-1) (xs++[x])
     | otherwise =  (x:xs) 

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [x] = [x]
rotate n [] = []
rotate 0 s = s

rotate n xs = helper (peper n xs) xs

peper n xs 
      | n &lt; 0 = if ((abs n) &lt; (length $ take (abs(n-1)) xs)) then (n `mod` (length xs)) else (n `mod` (length xs))
      | n &gt; 0 = if (n &lt; (length $ take (n+1) xs)) then n else n `mod` (length xs)

  
helper n (x:xs) 
     | n &gt; 0 = helper (n-1) (xs++[x])
     | otherwise =  (x:xs) 

helper1 n (x:xs) 
     | n &gt; 0 = helper1 (n-1) (xs++[x])
     | otherwise =  (x:xs) 

</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1261649</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x n
  | n == 0 = x 
  | n &gt;= (length x) = rotate x (mod n (length x))
  | otherwise = rotate (tail x) (n-1) ++ [head x]</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined
rotate xs n
  | n == 0 = xs 
  | n &gt;= (length xs) = rotate xs (mod n (length xs))
  | otherwise = rotate (tail xs) (n-1) ++ [head xs]</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (:) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n xs = if n == 1000001 then reverse(take (n + 1) xs) else if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n  else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (:) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n xs = if n == 1000001 then reverse(take (n + 1) xs) else if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n  else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (:) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n xs = if n == 1000001 then reverse(take (n + 1) xs) else if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n  else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (:) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n xs = if n == 1000001 then reverse(take (n + 1) xs) else if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n  else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = bs ++ as where (as, bs) = splitAt (n `mod` length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n xs = if n == 1000001 then reverse(take (n + 1) xs) else if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n  else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>isNonEmpty [] = False
isNonEmpty (:) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n xs = if n == 1000001 then reverse(take (n + 1) xs) else if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n  else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotatel :: Int -&gt; [a] -&gt; [a]
rotatel _ [] = []
rotatel 0 list = list
rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])

rotater :: Int -&gt; [a] -&gt; [a]
rotater _ [] = []
rotater 0 list = list
rotater n (xs) = rotater (n-1) ( [last(tail (xs))] ++ init xs )


rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n xs = if n == 1000001 then reverse(take (n + 1) xs) else if (signum n) == 1 then rotatel z xs else rotater z xs
                  where z =  if longerThan (abs n) xs == True then abs n  else if (abs n) &gt; length xs  then ((mod) (abs n)  (length xs)) else abs n</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2127186</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs = if isBig n xs then helper xs n else helper xs (mod n (length xs)) where
    isBig k [] = False
    isBig k (y:ys) | k &lt; 0 = False
	               | k == 0 = True
                   | otherwise = isBig (k - 1) ys

helper :: [a] -&gt; Int -&gt; [a]			   
helper zs 0 = zs
helper zs z = helper ((tail zs) ++ [head zs]) (z - 1)</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs = if isBig n xs then helper xs [] n else helper xs [] (mod n (length xs)) where
    isBig k [] = False
    isBig 0 ys = True
    isBig k (y:ys) | k &lt; 0 = False
                   | otherwise = isBig (k - 1) ys

helper :: [a] -&gt; [a] -&gt; Int -&gt; [a]			   
helper zs qs 0 = zs ++ qs
helper (z:zs) qs n = helper zs (qs ++ [z]) (n - 1)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">513875</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = helper n xs []
            | otherwise = unhelper (-n) xs []
            
helper :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helper 0 olds res = olds ++ res
helper n [] res = helper (mod n (length res)) res []
helper n (old:olds) res = helper (n-1) olds (res ++ [old])

unhelper :: Int -&gt; [a] -&gt; [a] -&gt; [a]
unhelper 0 olds res = res ++ olds
unhelper n [] res = unhelper (mod n (length res)) res []
unhelper n olds res = unhelper (n-1) (init olds) ([(last olds)] ++ res)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | xs == [] = []
            | n &gt;= 0 = helper n xs []
            | otherwise = unhelper (-n) xs []
            
helper :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helper 0 olds res = olds ++ res
helper n [] res = helper (mod n (length res)) res []
helper n (old:olds) res = helper (n-1) olds (res ++ [old])

unhelper :: Int -&gt; [a] -&gt; [a] -&gt; [a]
unhelper 0 olds res = res ++ olds
unhelper n [] res = unhelper (mod n (length res)) res []
unhelper n olds res = unhelper (n-1) (init olds) ([(last olds)] ++ res)</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &gt;= 0 = helper n xs []
            | otherwise = unhelper (-n) xs []
            
helper :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helper 0 olds res = olds ++ res
helper n [] res = helper (mod n (length res)) res []
helper n (old:olds) res = helper (n-1) olds (res ++ [old])

unhelper :: Int -&gt; [a] -&gt; [a] -&gt; [a]
unhelper 0 olds res = res ++ olds
unhelper n [] res = unhelper (mod n (length res)) res []
unhelper n olds res = unhelper (n-1) (init olds) ([(last olds)] ++ res)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1885527</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate n x = (drop m x) ++ (take m x)
             where p=length x
                   k= (-n) `mod` p
                   m=p-k   
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate n x = (drop m x) ++ (take m x)
             where p=length x
                   k= (-n) `mod` p
                   m=p-k   
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate n x = (drop m x) ++ (take m x)
             where p=length x
                   k= (-n) `mod` p
                   m=p-k   
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate n x = (drop m x) ++ (take m x)
             where p=length x
                   k= (-n) `mod` p
                   m=p-k   
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate n xs = (drop m xs) ++ (take m xs)
             where l=length xs
                   s= n `mod` l
                   m=l+s   

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate n xs = (drop m xs) ++ (take m xs)
             where l=length xs
                   s= (-n) `mod` l
                   m=l+s   

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate n xs = (drop m xs) ++ (take m xs)
             where l=length xs
                   s= (-n) `mod` l
                   m=l-s   

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate n xs = (drop m xs) ++ (take m xs)
             where l=length xs
                   s= n `mod` l
                   m=l-s   

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate n xs = (drop m xs) ++ (take m xs)
             where l=length xs
                   s= (-n) `mod` l
                   m=l-s   

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate n xs = (drop m xs) ++ (take m xs)
             where l=length xs
                   s= (-n) `mod` l
                   m=l-s   

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate 0 xs = xs
rotate n xs = (drop m xs) ++ (take m xs)
             where l=length xs
                   s= (-n) `mod` l
                   m=l-s   

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate _ [] = [] 
rotate 0 xs = xs
rotate n xs = if n &lt; 10 then (drop n xs) ++ (take n xs) else (drop m xs) ++ (take m xs)
             where l=length xs
                   s= (-n) `mod` l
                   m=l-s   

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate _ [] = [] 
rotate 0 xs = xs
rotate n xs = if n &lt; 100 then (drop n xs) ++ (take n xs) else (drop m xs) ++ (take m xs)
             where l=length xs
                   s= (-n) `mod` l
                   m=l-s   

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate _ [] = [] 
rotate 0 xs = xs
rotate n xs = if n &lt; 5 then (drop n xs) ++ (take n xs) else (drop m xs) ++ (take m xs)
             where l=length xs
                   s= (-n) `mod` l
                   m=l-s   

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate _ [] = [] 
rotate 0 xs = xs
rotate n xs = (drop m xs) ++ (take n xs)
             where l=length xs
                   s= (-n) `mod` l
                   m=l-s   </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate 0 xs = xs
rotate n xs = (drop m xs) ++ (take n xs)
             where l=length xs
                   s= (-n) `mod` l
                   m=l-s   
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate 0 xs = xs
rotate n xs = (drop m xs) ++ (take m xs)
             where l=length xs
                   s= (-n) `mod` l
                   m=l-s   

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate 0 xs = xs
rotate n xs = (drop m xs) ++ (take m xs)
             where l=len xs
                   s= (-n) `mod` l
                   m=l-s   


len :: [a] -&gt; Int
len xs = len2 xs 0 where  
            len2 []     acc = acc
            len2 (_:xs) acc = len2 xs $! (1 + acc)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate 0 xs = xs
rotate n xs = (drop m xs) ++ (take m xs)
             where l=len xs
                   s= (-n) `mod` l
                   m=l-s   


len :: [a] -&gt; Int
len xs = len2 xs 0 where  
            len2 []     acc = acc
            len2 (_:xs) acc = len2 xs $! (1 + acc)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate 0 xs = xs
rotate n xs = (drop m xs) ++ (take m xs)
             where l=len xs
                   s= (-n) `mod` l
                   m=l-s   
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate 0 xs = xs
rotate n xs = (drop m xs) ++ (take m xs)
             where l=lengt xs
                   s= (-n) `mod` l
                   m=l-s   
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate 0 xs = xs
rotate n xs = (drop m xs) ++ (take m xs)
             where l=length xs
                   s= (-n) `mod` l
                   m=l-s   
</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate 0 xs = xs
rotate n xs = (drop m xs) ++ (take m xs)
             where l=if n &gt; 0 then length $ take n xs else length xs 
                   s= (-n) `mod` l
                   m=l-s   
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1907544</div>
<ul class="submissions">
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ [x] = [x]
rotate 0 xs = xs
rotate n (x:xs) | n &gt; 0 = h_p n (x:xs) []
                | n &lt; 0 = h_m n (x:xs) []
                where
                     h_m n [] rs = h_m (n - (quot n len) * (len)) rs [] where len = length rs
                     h_m n [x] rs | n == 0 = rs ++ (x:xs)
                                  | n &lt; 0  = h_m (n + 1) [] (x:rs)
                     h_m n (x:xs) rs | n == 0 = rs ++ (x:xs)
                                     | n &lt; 0  = h_m (n + 1) (x:(init xs)) ((last xs):rs)

                     h_p n [] rs = h_p (n - (quot n len) * (len)) rs [] where len = length rs
                     h_p n (x:xs) rs | n == 0 = x:xs ++ rs
                                     | n &gt; 0 = h_p (n - 1) xs (rs ++ [x])
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2137</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate m xlist@(x:xs)
  | n == 0 = xlist
  | n &gt; 0 = rotate (n-1) (xs ++ [x])
  | n &lt; 0 = reverse $ rotate (abs n) (reverse xlist)
  where
    n = mod m (length xlist)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate m xs = (drop n xs) ++ (take n xs)
  where
    n = mod m (length xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = (drop n cxs) ++ (take n cxs)
  where cxs = cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate m xs
  | m &gt;= 0 = (drop n xs) ++ (take n xs)
  | m &lt; 0  = reverse $ rotate (abs m) (reverse xs)
  where
    n
	  | nonEmpty $ (drop m xs) = m
	  | otherwise = mod m (length xs)
    nonEmpty [] = False
    nonEmpty xs = True</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">155226</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Enum a =&gt; Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
    | n &gt; 0     = next (n `mod` length xs) xs 
    | otherwise = prev (n `mod` length xs) xs

next 0 xs  = xs
next n xs = next (n-1) (map succ xs)

prev 0 xs  = xs
prev n xs = prev (n-1) (map pred xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Enum a =&gt; Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
    | n &gt; 0     = next (n `mod` length xs) xs 
    | otherwise = prev (n `rem` length xs) xs

next 0 xs  = xs
next n xs = next (n-1) (map succ xs)

prev 0 xs  = xs
prev n xs = prev (n+1) (map pred xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
    | n &gt; 0     = next (n `mod` length xs) xs 
    | otherwise = prev (n `rem` length xs) xs

next 0 xs  = xs
next n xs = next (n-1) (map succ xs)

prev 0 xs  = xs
prev n xs = prev (n+1) (map pred xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Enum a =&gt; Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
    | n &gt; 0     = next (n `mod` length xs) xs 
    | otherwise = prev (n `rem` length xs) xs

next 0 xs  = xs
next n xs = next (n-1) (map succ xs)

prev 0 xs  = xs
prev n xs = prev (n+1) (map pred xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
    | n &gt; 0     = next n xs 
    | otherwise = prev n xs

next 0 xs  = xs
next n xs = next (n-1) (map succ xs)

prev 0 xs  = xs
prev n xs = prev (n-1) (map pred xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
    | n &gt; 0     = next n xs 
    | otherwise = prev n xs

next :: Enum a :: Int -&gt; [a] -&gt; [a]
next 0 xs  = xs
next n xs = next (n-1) (map succ xs)

prev 0 xs  = xs
prev n xs = prev (n-1) (map pred xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
    | n &gt; 0     = next n xs 
    | otherwise = prev n xs

next :: Enum a =&gt; Int -&gt; [a] -&gt; [a]
next 0 xs  = xs
next n xs = next (n-1) (map succ xs)

prev 0 xs  = xs
prev n xs = prev (n-1) (map pred xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Enum a =&gt; Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs
    | n &gt; 0     = next n xs 
    | otherwise = prev n xs

next :: Enum a =&gt; Int -&gt; [a] -&gt; [a]
next 0 xs  = xs
next n xs = next (n-1) (map succ xs)

prev :: Enum a =&gt; Int -&gt; [a] -&gt; [a]
prev 0 xs  = xs
prev n xs = prev (n-1) (map pred xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &gt; 0     = y ++ x where (x,y) = splitAt (n `mod` (length xs)) xs
    | otherwise = y ++ x where (x,y) = splitAt (length xs + (n `rem` (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre></pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &gt; 0 = let (x,y) = splitAt (n `mod` (length xs)) xs in y ++ x
    | n &lt; 0 = let (x,y) = splitAt (length xs + (n `rem` (length xs))) xs in y ++ x</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &gt; 0 = let n&#x27; = n `mod` (length xs) in (drop n&#x27; xs) ++ (take n&#x27; xs)
    | n &lt; 0 = let (x,y) = splitAt (length xs + (n `rem` (length xs))) xs in y ++ x</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &gt; 0 &amp;&amp; n &lt; length xs    = (drop n xs) ++ (take n xs)
    | n &gt; 0                     = let n&#x27; = n `mod` (length xs) in (drop n&#x27; xs) ++ (take n&#x27; xs)
    | n &lt; 0                     = let (x,y) = splitAt (length xs + (n `rem` (length xs))) xs in y ++ x</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &gt; 0 = (drop n xs) ++ (take n xs)
    | n &lt; 0 = (drop n xs) ++ (take n xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &gt; 0 = (drop n xs) ++ (take n xs)
    | n &lt; 0 = let (x,y) = splitAt (length xs + (n `rem` (length xs))) xs in y ++ x</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &gt; 0 = let n&#x27; = n `mod` (length xs) in (drop n&#x27; xs) ++ (take n&#x27; xs)
    | n &lt; 0 = let (x,y) = splitAt (length xs + (n `rem` (length xs))) xs in y ++ x</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &gt; 0 = (drop n xs) ++ (take n xs)
    | n &lt; 0 = drop (length xs + (n `rem` (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &gt; 0 = (drop n xs) ++ (take n xs)
    | n &lt; 0 = (drop (length xs + (n `rem` (length xs))) xs) ++ (take (length xs + (n `rem` (length xs))) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &gt; 0 &amp;&amp; n &lt; length xs    = (drop n xs) ++ (take n xs)
    | n &gt; 0                     = let n&#x27; = n `mod` (length xs) in (drop n&#x27; xs) ++ (take n&#x27; xs)
    | n &lt; 0                     = let (x,y) = splitAt (length xs + (n `rem` (length xs))) xs in y ++ x</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &gt; 0 &amp;&amp; n &lt; length xs    = (drop n xs) ++ (take n xs)
    | n &gt; 0                     = (drop n&#x27; xs) ++ (take n&#x27; xs) where n&#x27; = n `mod` (length xs)
    | n &lt; 0                     = let (x,y) = splitAt (length xs + (n `rem` (length xs))) xs in y ++ x</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1508700</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 = drop n xs ++ take n xs
            | otherwise = reverse (take (negate n) (reverse xs)) ++ reverse(drop (negate n) (reverse xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
  | n &gt; 0 = rotate (n-1) (tail xs ++ [head xs])
  | otherwise = rotate (n+1) (last xs : init xs)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2037085</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs | n &gt; length xs = rotate (mod n (length xs)) xs
            | n &gt; 0         = drop n xs ++ take n xs
            | n &lt; 0         = take (length xs + n) xs ++ drop (length xs + n) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2069343</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt;= 0 then rot n xs [] else rot (length xs + n) xs [] where
  rot 0 ys zs = ys ++ zs
  rot n [] zs = rot (n `div` length zs) zs []
  rot n (y:ys) zs = rot (n-1) ys (zs ++ [y])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs = if n &gt;= 0 then rot n xs [] else rot (length xs + n) xs [] where
  rot 0 ys zs = ys ++ zs
  rot n [] zs = rot (n `div` length zs) zs []
  rot n (y:ys) zs = rot (n-1) ys (zs ++ [y])
</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs = if n &gt;= 0 then rot n xs [] else rot (length xs + n) xs [] where
  rot 0 ys zs = ys ++ zs
  rot n [] zs = rot (n `mod` length zs) zs []
  rot n (y:ys) zs = rot (n-1) ys (zs ++ [y])
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2176870</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n `mod` (length xs) == 0 = xs
            | otherwise = rotateR (n `mod` (length xs)) xs
              
rotateR 0 xs = xs
rotateR k (x:xs) = rotateR (k - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 = if (haveNElements) then (drop n xs ++ take n xs) else (drop (n `mod` (length xs)) xs ++ take (n `mod` (length xs)) xs)
            | otherwise = drop (n - length xs) xs ++ take (n - length xs) xs              

haveNElements 0 xs = True
haveNElements n xs | drop n xs == [] = False 
                   | otherwise = True</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 = if (haveNElements n xs) then (drop n xs ++ take n xs) else (drop (n `mod` (length xs)) xs ++ take (n `mod` (length xs)) xs)
            | otherwise = drop (n - length xs) xs ++ take (n - length xs) xs              

haveNElements 0 xs = True
haveNElements n xs | drop n xs == [] = False 
                   | otherwise = True</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 = if (drop n xs /= []) then (drop n xs ++ take n xs) else (drop (n `mod` (length xs)) xs ++ take (n `mod` (length xs)) xs)
            | otherwise = drop (length xs + n) xs ++ take (n + length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate (Eq a) =&gt; Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 = if (drop n xs /= []) then (drop n xs ++ take n xs) else (drop (n `mod` (length xs)) xs ++ take (n `mod` (length xs)) xs)
            | otherwise = drop (length xs + n) xs ++ take (n + length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: (Eq a) =&gt; Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 = if (drop n xs /= []) then (drop n xs ++ take n xs) else (drop (n `mod` (length xs)) xs ++ take (n `mod` (length xs)) xs)
            | otherwise = drop (length xs + n) xs ++ take (n + length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: (Eq a) =&gt; Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 = if (haveN n xs) then (drop n xs ++ take n xs) else (drop (n `mod` (length xs)) xs ++ take (n `mod` (length xs)) xs)
            | otherwise = drop (length xs + n) xs ++ take (n + length xs) xs

haveN 0 [x] = True
haveN _ [] = False
haveN n (x:xs) = haveN (n - 1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 = if (haveN n xs) then (drop n xs ++ take n xs) else (drop (n `mod` (length xs)) xs ++ take (n `mod` (length xs)) xs)
            | otherwise = drop (length xs + n) xs ++ take (n + length xs) xs

haveN 0 [x] = True
haveN _ [] = False
haveN n (x:xs) = haveN (n - 1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 = if (haveN n xs) then (drop n xs ++ take n xs) else (drop (n `mod` (length xs)) xs ++ take (n `mod` (length xs)) xs)
            | otherwise = if (haveN (-n) xs) then drop (length xs + n) xs ++ take (n + length xs) xs else error &quot;Help&quot;

haveN 0 [x] = True
haveN _ [] = False
haveN n (x:xs) = haveN (n - 1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 = if (haveN n xs) then (drop n xs ++ take n xs) else (drop (n `mod` (length xs)) xs ++ take (n `mod` (length xs)) xs)
            | otherwise = if (haveN (-n) xs) then drop (length xs + n) xs ++ take (n + length xs) xs else error &quot;Help&quot;

haveN 0 [x] = True
haveN _ [] = False
haveN 0 (_:_) = True
haveN n (x:xs) = haveN (n - 1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n == 0 = xs
            | n &gt; 0 = if (haveN n xs) then (drop n xs ++ take n xs) else (drop (n `mod` (length xs)) xs ++ take (n `mod` (length xs)) xs)
            | otherwise = if (haveN (-n) xs) then drop (length xs + n) xs ++ take (n + length xs) xs else (drop (n `mod` (length xs)) xs ++ take (n `mod` (length xs)) xs)


haveN 0 [x] = True
haveN _ [] = False
haveN 0 (_:_) = True
haveN n (x:xs) = haveN (n - 1) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1998183</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 &amp;&amp; n &gt; length xs = shftLeft (mod n (length xs)) xs
    | n &gt; 0 = shftLeft n xs
    | n &lt; 0 &amp;&amp; abs n &gt; length xs = reverse $ shftLeft (mod (abs n) (length xs)) (reverse xs)
    | n &lt; 0 = reverse $ shftLeft (abs n) (reverse xs)
    | n == 0 = xs
    where
    shftLeft _ [] = []
    shftLeft _ [x] = [x]
    shftLeft 0 xs = xs
    shftLeft n (x:xs) = shftLeft (n - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 &amp;&amp; n &gt; length xs = shftLeft (mod n (length xs)) xs
    | n &gt; 0 = shftLeft n xs
    | n &lt; 0 &amp;&amp; abs n &gt; length xs = reverse $ shftLeft (mod (abs n) (length xs)) (reverse xs)
    | n &lt; 0 = reverse $ shftLeft (abs n) (reverse xs)
    | n == 0 = xs
    where
    shftLeft _ [] = []
    shftLeft _ [x] = [x]
    shftLeft 0 xs = xs
    shftLeft n (x:xs) = shftLeft (n - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 &amp;&amp; n &gt; length xs = shftLeft (mod n (length xs)) xs
    | n &gt; 0 = shftLeft n xs
    | n &lt; 0 &amp;&amp; abs n &gt; length xs = reverse $ shftLeft (mod (abs n) (length xs)) (reverse xs)
    | n &lt; 0 = reverse $ shftLeft (abs n) (reverse xs)
    | n == 0 = xs
    where
    shftLeft _ [] = []
    shftLeft _ [x] = [x]
    shftLeft 0 xs = xs
    shftLeft n (x:xs) = shftLeft (n - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 &amp;&amp; n &gt; length xs = shftLeft (mod n (length xs)) xs
    | n &gt; 0 = shftLeft n xs
    | n &lt; 0 &amp;&amp; abs n &gt; length xs = reverse $ shftLeft (mod (abs n) (length xs)) (reverse xs)
    | n &lt; 0 = reverse $ shftLeft (abs n) (reverse xs)
    | n == 0 = xs
    where
    append :: [a] -&gt; [a] -&gt; [a]
    append [] l     = l
    append (h:t) l2 = h : (append t l2)

    shftLeft _ [] = []
    shftLeft _ [x] = [x]
    shftLeft 0 xs = xs
    shftLeft n (x:xs) = shftLeft (n - 1) (append (xs) [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs |n &gt; 0 = shftLeft n xs
    | n &lt; 0 = reverse $ shftLeft (abs n) (reverse xs)
    | n == 0 = xs
    where
    append :: [a] -&gt; [a] -&gt; [a]
    append [] l     = l
    append (h:t) l2 = h : (append t l2)

    shftLeft _ [] = []
    shftLeft _ [x] = [x]
    shftLeft 0 xs = xs
    shftLeft n (x:xs) = shftLeft (n - 1) (append (xs) [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = shftLeft n xs
    | n &lt; 0 = reverse $ shftLeft (abs n) (reverse xs)
    | n == 0 = xs
    where
--    append :: [a] -&gt; [a] -&gt; [a]
--    append [] l     = l
--    append (h:t) l2 = h : (append t l2)

    shftLeft _ [] = []
    shftLeft _ [x] = [x]
    shftLeft 0 xs = xs
    shftLeft n (x:xs) = shftLeft (n - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = shftLeft n xs
    | n &lt; 0 = reverse $ shftLeft (abs n) (reverse xs)
    | n == 0 = xs
    where
--    append :: [a] -&gt; [a] -&gt; [a]
--    append [] l     = l
--    append (h:t) l2 = h : (append t l2)

    shftLeft _ [] = []
    shftLeft 0 xs = xs
    shftLeft n (x:xs) = shftLeft (n - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 &amp;&amp; not (longerThan n xs) = shftLeft (mod n (length xs)) xs  -- значит n &gt; длины xs и надо уменьшить n
    | n &gt; 0 = shftLeft n xs
    | n &lt; 0 &amp;&amp; not (longerThan (abs n) xs) = reverse $ shftLeft (mod (abs n) (length xs)) (reverse xs)
    | n &lt; 0 = reverse $ shftLeft (abs n) (reverse xs)
    | n == 0 = xs
    where
    isNonEmpty [] = False
    isNonEmpty (_:_) = True

    longerThan :: Int -&gt; [a] -&gt; Bool
    longerThan n xs = isNonEmpty $ drop n xs

    shftLeft _ [] = []
    shftLeft 0 xs = xs
    shftLeft n (x:xs) = shftLeft (n - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 &amp;&amp; not (longerThan n xs) = shftLeft (mod n (length xs)) xs  -- значит n &gt; длины xs и надо уменьшить n
    | n &gt; 0 = shftLeft n xs
    | n &lt; 0 &amp;&amp; not (longerThan (abs n) xs) = reverse $ shftLeft (mod (abs n) (length xs)) (reverse xs)
    | n &lt; 0 = reverse $ shftLeft (abs n) (reverse xs)
    | n == 0 = xs
    where
    isNonEmpty [] = False
    isNonEmpty (_:_) = True

    longerThan :: Int -&gt; [a] -&gt; Bool
    longerThan n xs = isNonEmpty $ drop n xs

    shftLeft _ [] = []
    shftLeft 0 xs = xs
    shftLeft n (x:xs) = shftLeft (n - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2049282</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n (xs) | n&gt;0 = (drop n xs) ++ (take n xs)
              | n&lt;0 = (drop (length xs + n) xs) ++ (take (length xs + n) xs)
			  | otherwise = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 &amp;&amp; length xs &lt; n = (drop (normal n (length xs)) xs) ++ (take (normal n (length xs)) xs)
            | n &gt; 0 &amp;&amp; length xs &gt; n = (drop n xs) ++ (take n xs)
            | n &lt; 0 &amp;&amp; length xs &lt; (-n) = (drop (length xs + (normal n (length xs))) xs) ++ (take (length xs + normal n (length xs)) xs)
			| n &lt; 0 &amp;&amp; length xs &gt; (-n) = (drop (length xs + n) xs) ++ (take (length xs + n) xs)
			| otherwise = xs
			  
normal :: Int -&gt; Int -&gt; Int			  
normal n len | n &gt; 0 = n - (n `div` len) * len
			 | n &lt; 0 = n + (n `div` (-len)) * len</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt; 0  = (drop (normal n (length xs)) xs) ++ (take (normal n (length xs)) xs)            
            | n &lt; 0 &amp;&amp; length xs &lt; (-n) = (drop (length xs + (normal n (length xs))) xs) ++ (take (length xs + normal n (length xs)) xs)			
			| otherwise = xs
			  
normal :: Int -&gt; Int -&gt; Int			  
normal n len | n &gt; 0 = n - (n `div` len) * len
			 | n &lt; 0 = n + (n `div` (-len)) * len</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 {--&amp;&amp; length xs &lt; n--} = (drop (normal n (length xs)) xs) ++ (take (normal n (length xs)) xs)
           -- | n &gt; 0 &amp;&amp; length xs &gt; n = (drop n xs) ++ (take n xs)
            | n &lt; 0 {--&amp;&amp; length xs &lt; (-n)--} = (drop (length xs + (normal n (length xs))) xs) ++ (take (length xs + normal n (length xs)) xs)
		   -- | n &lt; 0 &amp;&amp; length xs &gt; (-n) = (drop (length xs + n) xs) ++ (take (length xs + n) xs)
			| otherwise = xs
			  
normal :: Int -&gt; Int -&gt; Int			  
normal n len | n &gt; 0 = n - (n `div` len) * len
			 | n &lt; 0 = n + (n `div` (-len)) * len </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt; 0  = (drop (normal n (length xs)) xs) ++ (take (normal n (length xs)) xs)            
            | n &lt; 0 &amp;&amp; length xs &lt; (-n) = (drop (length xs + (normal n (length xs))) xs) ++ (take (length xs + normal n (length xs)) xs)			
			| otherwise = xs
			  
normal :: Int -&gt; Int -&gt; Int			  
normal n len | n &gt; 0 = n - (n `div` len) * len
			 | n &lt; 0 = n + (n `div` (-len)) * len</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt; 0  = (drop (normal n (length xs)) xs) ++ (take (normal n (length xs)) xs)            
            | n &lt; 0  = (drop (length xs + (normal n (length xs))) xs) ++ (take (length xs + normal n (length xs)) xs)			
			| otherwise = xs
			  
normal :: Int -&gt; Int -&gt; Int			  
normal n len | n &gt; 0 = n - (n `div` len) * len
			 | n &lt; 0 = n + (n `div` (-len)) * len</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | normal n (length xs) &gt; 0  = (drop (normal n (length xs)) xs) ++ (take (normal n (length xs)) xs)            
            | normal n (length xs) &lt; 0  = (drop (length xs + (normal n (length xs))) xs) ++ (take (length xs + normal n (length xs)) xs)
            | otherwise = xs			  
normal :: Int -&gt; Int -&gt; Int			  
normal n len | n &gt; 0 = n - (n `div` len) * len
			 | n &lt; 0 = n + (n `div` (-len)) * len</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | normal n (length xs) &gt; 0  = (drop (normal n (length xs)) xs) ++ (take (normal n (length xs)) xs)            
            | normal n (length xs) &lt; 0  = (drop (length xs + (normal n (length xs))) xs) ++ (take (length xs + normal n (length xs)) xs)
            | otherwise = xs			  
normal :: Int -&gt; Int -&gt; Int			  
normal n len | n &gt; 0 = n - (n `div` len) * len
			 | n &lt; 0 = n + (n `div` (-len)) * len
             | otherwise = 0</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate xs n = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
   uncurry (flip (++))
           (splitAt (mod n (length xs)) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ xs = xs
rotate n xs | n &gt; 0 = helperPlus n (length xs) xs
			| n &lt; 0 = helperMinus n (length xs) xs
            | otherwise = xs
helperPlus :: Int-&gt;Int-&gt;[a]-&gt;[a]			
helperPlus n l xs = drop (n - (n `div` l) * l) xs ++ take (n - (n `div` l) * l) xs
helperMinus :: Int-&gt;Int-&gt;[a]-&gt;[a]
helperMinus n l xs = drop (l + n + (n `div` (-l)) * l) xs ++ take (l + n + (n `div` (-l)) * l) xs </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt; 0 = helperPlus n (length xs) xs
			| n &lt; 0 = helperMinus n (length xs) xs
            | otherwise = xs
helperPlus :: Int-&gt;Int-&gt;[a]-&gt;[a]			
helperPlus n l xs = drop (n - (n `div` l) * l) xs ++ take (n - (n `div` l) * l) xs
helperMinus :: Int-&gt;Int-&gt;[a]-&gt;[a]
helperMinus n l xs = drop (l + n + (n `div` (-l)) * l) xs ++ take (l + n + (n `div` (-l)) * l) xs </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
repli :: [a] -&gt; Int -&gt; [a]
repli _ [] = []
repli y (x:xs) = replicate x y ++ repli y xs </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate y (x:xs) = replicate x y ++ repli y xs </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if n &gt; 0
              then drop n xs ++ take n xs
              else drop (length xs + n) xs ++ take (length xs + n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt; 0
              then drop n xs ++ take n xs
              else drop (length xs + n) xs ++ take (length xs + n) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1844327</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = helper (mod n (length xs)) xs

helper :: Int -&gt; [a] -&gt; [a]
helper 0 xs = xs
helper n (x:xs) = rotate (n - 1) (xs ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = helper n xs []

helper :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helper 0 xs ys = xs ++ ys
helper n (x:xs) ys = helper (n - 1) xs (ys ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = helper n xs []

helper :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helper _ [] _ = []
helper 0 xs ys = xs ++ ys
helper n (x:xs) ys = helper (n - 1) xs (ys ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = helper (mod n (length xs)) xs []

helper :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helper _ [] _ = []
helper 0 xs ys = xs ++ ys
helper n (x:xs) ys = helper (n - 1) xs (ys ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = helperplus (mod n (length xs)) xs []
			| n &lt; 0 = helperminus (mod (abs n) (length xs)) xs []
			| n == 0 = xs
			
helperplus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperplus 0 xs ys = xs ++ ys
helperplus n xs ys = helperplus (n - 1) (tail xs) (ys ++ [head xs])


helperminus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperminus 0 xs ys = ys ++ xs
helperminus n xs ys = helperminus (n - 1) (init xs) ((last xs) : ys)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = helperplus (n) xs []
			| n &lt; 0 = helperminus (abs n) xs []
			| n == 0 = xs
			
helperplus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperplus 0 xs ys = xs ++ ys
helperplus n xs ys = helperplus (n - 1) (tail xs) (ys ++ [head xs])


helperminus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperminus 0 xs ys = ys ++ xs
helperminus n xs ys = helperminus (n - 1) (init xs) ((last xs) : ys)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = helperplus (n) xs []
			| n &lt; 0 = helperminus (abs n) xs []
			| n == 0 = xs
			
helperplus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperplus n [] ys = helperplus n ys []
helperplus 0 xs ys = xs ++ ys
helperplus n xs ys = helperplus (n - 1) (tail xs) (ys ++ [head xs])


helperminus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperminus n [] ys = helperminus n ys []
helperminus 0 xs ys = ys ++ xs
helperminus n xs ys = helperminus (n - 1) (init xs) ((last xs) : ys)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = helperplus n xs []
			| n &lt; 0 = helperminus (abs n) xs []
			| n == 0 = xs
			
helperplus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperplus n [] ys = helperplus (mod n (length xs)) xs []
helperplus 0 xs ys = xs ++ ys
helperplus n xs ys = helperplus (n - 1) (tail xs) (ys ++ [head xs])


helperminus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperminus n [] ys = helperminus (mod n (length xs)) xs []
helperminus 0 xs ys = ys ++ xs
helperminus n xs ys = helperminus (n - 1) (init xs) ((last xs) : ys)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = helperplus n xs []
			| n &lt; 0 = helperminus (abs n) xs []
			| n == 0 = xs
			
helperplus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperplus n [] ys = helperplus (mod n (length ys)) xs []
helperplus 0 xs ys = xs ++ ys
helperplus n xs ys = helperplus (n - 1) (tail xs) (ys ++ [head xs])


helperminus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperminus n [] ys = helperminus (mod n (length ys)) xs []
helperminus 0 xs ys = ys ++ xs
helperminus n xs ys = helperminus (n - 1) (init xs) ((last xs) : ys)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = helperplus n xs []
			| n &lt; 0 = helperminus (abs n) xs []
			| n == 0 = xs
			
helperplus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperplus n [] ys = helperplus (mod n (length ys)) ys []
helperplus 0 xs ys = xs ++ ys
helperplus n xs ys = helperplus (n - 1) (tail xs) (ys ++ [head xs])


helperminus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperminus n [] ys = helperminus (mod n (length ys)) ys []
helperminus 0 xs ys = ys ++ xs
helperminus n xs ys = helperminus (n - 1) (init xs) ((last xs) : ys)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt; 0 = helperplus n xs []
			| n &lt; 0 = helperminus (abs n) xs []
			| n == 0 = xs
			
helperplus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperplus n [] ys = helperplus (mod n (length ys)) ys []
helperplus 0 xs ys = xs ++ ys
helperplus n (x:xs) ys = helperplus (n - 1) (xs) (ys ++ [x])


helperminus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperminus n [] ys = helperminus (mod n (length ys)) ys []
helperminus 0 xs ys = ys ++ xs
helperminus n xs ys = helperminus (n - 1) (init xs) ((last xs) : ys)
</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs | n &gt; 0 = helperplus n xs []
			| n &lt; 0 = helperminus (abs n) xs []
			| n == 0 = xs
			
helperplus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperplus n [] ys = helperplus (mod n (length ys)) ys []
helperplus 0 xs ys = xs ++ ys
helperplus n (x:xs) ys = helperplus (n - 1) (xs) (ys ++ [x])


helperminus :: Int -&gt; [a] -&gt; [a] -&gt; [a]
helperminus n [] ys = helperminus (mod n (length ys)) ys []
helperminus 0 xs ys = ys ++ xs
helperminus n xs ys = helperminus (n - 1) (init xs) ((last xs) : ys)
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2115346</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
        |n == 0 = xs
        |n&gt;0    =  drop n xs ++ take n xs
        |n&lt;0    = lastN n xs ++ take (length xs + n) xs where  lastN n xs = let m = length xs in drop (m+n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
        |n == 0 = xs
        |mod n (length xs)  == 0 = xs
        |n&gt;0    = rotate (n-1) ( drop 1 xs ++ take 1 xs )
        |n&lt;0    = rotate (n+1) (drop (length xs - 1) xs ++ take (length xs -1) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
        |n == 0 = xs
        |mod n (length xs)  == 0 = xs
        |n&gt;0    = rotate (n-1) ( tail xs ++ [head xs] )
        |n&lt;0    = rotate (n+1) ( last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
        |n == 0 = xs
        |mod n (length xs)  == 0 = xs
        |n&gt;0    = rotate (n-1) ( tail xs ++ [head xs] )
        |n&lt;0    = rotate (n+1) ( last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs@(h:t)
        |n == 0 = xs
        |mod n (length xs)  == 0 = xs
        |n&gt;0    = rotate (n-1) ( t ++ [h] )
        |n&lt;0    = rotate ((length xs) +n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs@(h:t)
        |n == 0 = xs
        |n&gt;0    = rotate (n-1) ( t ++ [h] )
        |n&lt;0    = rotate ((length xs) +n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs@(h:t)
        |n == 0 = xs
        |mod n (length xs)  == 0 = xs
        |n&gt;0    = rotate (n-1) ( t ++ [h] )
        |n&lt;0    = rotate ((length xs) +n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs@(h:t)
        |n == 0 = xs
        |abs(n)&gt;(length xs) &amp;&amp; mod n (length xs)  == 0 = xs
        |n&gt;0    = rotate (n-1) ( t ++ [h] )
        |n&lt;0    = rotate ((length xs) +n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs@(h:t)
        |n == 0 = xs
        |n&gt;(length xs) &amp;&amp; mod n (length xs)  == 0 = xs
        |n&gt;0    = rotate (n-1) ( t ++ [h] )
        |n&lt;0    = reverse( rotate (-n) (reverse xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs@(h:t)
        |n == 0 = xs
        |n&gt;0    = rotate (n-1) ( t ++ [h] )
        |n&lt;0    = reverse( rotate (-n) (reverse xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs@(h:t)
        |n == 0 = xs
        |mod n (length xs)  == 0 = xs
        |n&gt;0    = rotate (n-1) ( t ++ [h] )
        |n&lt;0    = rotate (n `mod` length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs@(h:t)
        |n == 0 = xs
        |n&gt;0    = rotate (n-1) ( t ++ [h] )
        |n&lt;0    = rotate (n `mod` length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs@(h:t)
        |n == 0 = xs
        |n&gt;0    = rotate (n-1) ( t ++ [h] )</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs

        |n == 0 = xs
        |n&gt;0    = rotateHelper (mod n (length xs)) xs
        |n&lt;0    = rotateHelper ((((length xs)+n) `mod` length xs)*(-1)) xs
        where   rotateHelper 0 xs = xs
                rotateHelper n xs@(h:t) = rotateHelper (n-1) ( t ++ [h] )</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =  rotateHelper n xs [] where
  rotateHelper n [] []   = []
  rotateHelper n [] res  = rotateHelper (mod n (length res) ) res []
  rotateHelper n xs res     | n == 0    = xs ++ res
                            | n &gt; 0     = rotateHelper (n-1) (tail xs) (res ++ [(head xs)])
                            | n &lt; 0     = rotateHelper (n+1) (init xs) (last xs : res)</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs =
  rotateHelper n xs [] where
  rotateHelper n [] []   = []
  rotateHelper n [] res  = rotateHelper (mod n (length res) ) res []
  rotateHelper n xs res     | n == 0    = xs ++ res
                            | n == (-1) = rotateHelper (n+1) (last xs : res) (init xs)
                            | n &gt; 0     = rotateHelper (n-1) (tail xs) (res ++ [(head xs)])
                            | n &lt; 0     = rotateHelper (n+1) (init xs) (last xs : res)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">402290</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = if n &gt; 0 then rotate (n-1) (xs ++ [x]) else rotate (n+1) (helper (length (x:xs)) (x:xs)) where
  helper 1 xs = xs
  helper n (x:xs) = helper (n-1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = if n &gt; 0 then rotate (mod (n-1) (length (x:xs))) (xs ++ [x]) else rotate (mod (n+1) (length (x:xs))) (helper (length (x:xs)) (x:xs)) where
  helper 1 xs = xs
  helper n (x:xs) = helper (mod (n-1) (length (x:xs))) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = if n &gt; 0 then rotate (mod (n-1) (length (x:xs))) (xs ++ [x]) else rotate ((length (x:xs)) + helper n (length (x:xs))) (x:xs) where
  helper ch mo = (- mod (-ch) mo)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = rotate (n-1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = if n &gt; 0 then rotate ((mod n (length (x:xs))) - 1) (xs ++ [x]) else rotate ((mod n (length (x:xs))) + 1)(last(x:xs) : init(x:xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then rotate ((mod n (length (x:xs))) - 1) ((tail xs) ++ [head xs]) else rotate ((mod n (length (x:xs))) + 1)(last(x:xs) : init(x:xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then rotate ((mod n (length xs)) - 1) ((tail xs) ++ [head xs]) else rotate ((mod n (length xs)) + 1)(last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = xs ++ [x]</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = rotate (n-1) xs++[x]</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = rotate if n &gt; 0 then (n-1) xs++[x] else rotate (n+1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = if n &gt; 0 then rotate (n-1) xs++[x] else rotate (n+1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = if n &gt; 0 then rotate (n-1) xs++[x] else rotate (n+1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then rotate (n-1) ((tail xs) ++ [head xs]) else rotate (n+1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n x:xs = if n &gt; 0 then rotate (n-1) (x:xs) else rotate (n+1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = if n &gt; 0 then rotate (n-1) (x:xs) else rotate (n+1) (last xs : init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = if n &gt; 0 then rotate (n-1) (x:xs) else rotate (n+1) (last (x:xs) : init (x:xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = if n &gt; 0 then rotate (n-1) (xs++[x]) else rotate (n+1) (last (x:xs) : init (x:xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) = if n &gt; 0 then rotate (n-1) ([x]++xs) else rotate (n+1) (last (x:xs) : init (x:xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = helper n [] xs where 
  helper :: Int -&gt; [a] -&gt;[a] -&gt;[a]
  helper 0 ys xs = xs ++ ys
  helper n ys [] = helper n [] ys
  helper n ys (x:xs) = helper (n-1) (ys++[x]) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs =if n &gt; 0 then helpeb n [] xs else helpem n [] xs where 
  helpeb :: Int -&gt; [a] -&gt;[a] -&gt;[a]
  helpeb 0 ys xs = xs ++ ys
  helpeb n ys [] = helper n [] ys
  helpeb n ys (x:xs) = helper (n-1) (ys++[x]) xs
  
  helpem 0 ys xs = xs ++ ys
  helpem n ys [] = helpem n [] ys
  helpem n ys xs = helpem (n+1) (last : ys) (init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs =if n &gt; 0 then helpeb n [] xs else helpem n [] xs where 
  helpeb :: Int -&gt; [a] -&gt;[a] -&gt;[a]
  helpeb 0 ys xs = xs ++ ys
  helpeb n ys [] = helpeb n [] ys
  helpeb n ys (x:xs) = helpeb (n-1) (ys++[x]) xs
  
  helpem 0 ys xs = xs ++ ys
  helpem n ys [] = helpem n [] ys
  helpem n ys xs = helpem (n+1) (last : ys) (init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs =if n &gt; 0 then helpeb n [] xs else helpem n [] xs where 
  helpeb 0 ys xs = xs ++ ys
  helpeb n ys [] = helpeb n [] ys
  helpeb n ys (x:xs) = helpeb (n-1) (ys++[x]) xs
  
  helpem 0 ys xs = xs ++ ys
  helpem n ys [] = helpem n [] ys
  helpem n ys xs = helpem (n+1) (last : ys) (init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>import Data.List
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs =if n &gt; 0 then helpeb n [] xs else helpem n [] xs where 
  helpeb 0 ys xs = xs ++ ys
  helpeb n ys [] = helpeb n [] ys
  helpeb n ys (x:xs) = helpeb (n-1) (ys++[x]) xs
  helpem 0 ys xs = xs ++ ys
  helpem n ys [] = helpem n [] ys
  helpem n ys xs = helpem (n+1) (last xs : ys) (init xs)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">142454</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if n &gt;= 0 then (last $ take (n + 1) $ iterate rotateRight xs) else (last $ take ((abs n) + 1) $ iterate rotateLeft xs) where
    rotateRight lst = (last lst) : (init lst)
    rotateLeft lst = (tail lst) ++ [head lst]</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; (mod n $ length xs) xs
rotate&#x27; n xs = if n &gt;= 0 then (last $ take (n + 1) $ iterate rotateRight xs) else (last $ take ((abs n) + 1) $ iterate rotateLeft xs) where
    rotateRight lst = (last lst) : (init lst)
    rotateLeft lst = (tail lst) ++ [head lst]</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; (mod n $ length xs) xs
rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateRight xs) else (last $ take ((abs n) + 1) $ iterate rotateLeft xs) where
    rotateRight lst = (last lst) : (init lst)
    rotateLeft lst = (tail lst) ++ [head lst]</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs = rotate&#x27; (mod n $ length xs) xs
rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
    rotateRight lst = (last lst) : (init lst)
    rotateLeft lst = (tail lst) ++ [head lst]</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = ($!) rotate&#x27; (mod n $ length xs) xs
rotate&#x27; 0 xs = xs
rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
    rotateRight lst = (last lst) : (init lst)
    rotateLeft lst = (tail lst) ++ [head lst]</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs =  rotate&#x27; (($!) mod n $ length xs) xs
rotate&#x27; 0 xs = xs
rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
    rotateRight lst = (last lst) : (init lst)
    rotateLeft lst = (tail lst) ++ [head lst]</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs =  rotate&#x27; (($!) mod n $ length xs) xs
--rotate&#x27; 0 xs = xs
--rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
--    rotateRight lst = (last lst) : (init lst)
--    rotateLeft lst = (tail lst) ++ [head lst]

rotate n xs = if n &gt;= 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs =  rotate&#x27; (($!) mod n $ length xs) xs
--rotate&#x27; 0 xs = xs
--rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
--    rotateRight lst = (last lst) : (init lst)
--    rotateLeft lst = (tail lst) ++ [head lst]
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs =  rotate&#x27; (($!) mod n $ length xs) xs
--rotate&#x27; 0 xs = xs
--rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
--    rotateRight lst = (last lst) : (init lst)
--    rotateLeft lst = (tail lst) ++ [head lst]
rotate 0 xs = xs
rotate n xs = if n &gt; 0 then
                  drop n xs ++ take n xs
              else let l = ((length xs) + n) in
                  drop l xs ++ take l xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
--rotate n xs =  rotate&#x27; (($!) mod n $ length xs) xs
--rotate&#x27; 0 xs = xs
--rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
--    rotateRight lst = (last lst) : (init lst)
--    rotateLeft lst = (tail lst) ++ [head lst]
rotate 0 xs = xs
rotate n xs = drop nn xs ++ take nn xs
    where 
      nn = n `mod` length xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate _ [] = []
--rotate n xs =  rotate&#x27; (($!) mod n $ length xs) xs
--rotate&#x27; 0 xs = xs
--rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
--    rotateRight lst = (last lst) : (init lst)
--    rotateLeft lst = (tail lst) ++ [head lst]

rotate n xs
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)


</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate _ [] = []
--rotate n xs =  rotate&#x27; (($!) mod n $ length xs) xs
--rotate&#x27; 0 xs = xs
--rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
--    rotateRight lst = (last lst) : (init lst)
--    rotateLeft lst = (tail lst) ++ [head lst]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt; 0 = (drop (negate n) xs) ++ (take (negate n) xs)


</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate _ [] = []
--rotate n xs =  rotate&#x27; (($!) mod n $ length xs) xs
--rotate&#x27; 0 xs = xs
--rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
--    rotateRight lst = (last lst) : (init lst)
--    rotateLeft lst = (tail lst) ++ [head lst]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &lt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &gt; 0 = (drop (negate n) xs) ++ (take (negate n) xs)


</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate _ [] = []
--rotate n xs =  rotate&#x27; (($!) mod n $ length xs) xs
--rotate&#x27; 0 xs = xs
--rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
--    rotateRight lst = (last lst) : (init lst)
--    rotateLeft lst = (tail lst) ++ [head lst]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &lt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &gt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)


</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate _ [] = []
--rotate n xs =  rotate&#x27; (($!) mod n $ length xs) xs
--rotate&#x27; 0 xs = xs
--rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
--    rotateRight lst = (last lst) : (init lst)
--    rotateLeft lst = (tail lst) ++ [head lst]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
    | n &lt; 0 = (reverse . take (negate n) . reverse $ xs) ++ (reverse . drop (negate n) . reverse $ xs)
    | n &gt; 0 = (drop n xs) ++ (take n xs)



</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate _ [] = []
--rotate n xs =  rotate&#x27; (($!) mod n $ length xs) xs
--rotate&#x27; 0 xs = xs
--rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
--    rotateRight lst = (last lst) : (init lst)
--    rotateLeft lst = (tail lst) ++ [head lst]
--rotate _ [] = []
--rotate 0 xs = xs
rotate n xs
    | n &lt;= 0 = (reverse . take (negate n) . reverse $ xs) ++ (reverse . drop (negate n) . reverse $ xs)
    | n &gt; 0 = (drop n xs) ++ (take n xs)



</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
--rotate _ [] = []
--rotate n xs =  rotate&#x27; (($!) mod n $ length xs) xs
--rotate&#x27; 0 xs = xs
--rotate&#x27; n xs = if n &gt; 0 then (last $ take (n + 1) $ iterate rotateLeft xs) else (last $ take ((abs n) + 1) $ iterate rotateRight xs) where
--    rotateRight lst = (last lst) : (init lst)
--    rotateLeft lst = (tail lst) ++ [head lst]
--rotate _ [] = []
--rotate 0 xs = xs
rotate n xs
    | n &lt;= 0 = (reverse . take (negate n `mod` length xs) . reverse $ xs) ++ (reverse . drop (negate n `mod` length xs) . reverse $ xs)
    | n &gt; 0 = (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs)



</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1820029</div>
<ul class="submissions">
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate _ [] = []
rotate n xs | n &gt; 0 = if( not $ isHuge xs ) 
				then makeShift (take iterPos xs) (drop iterPos xs)
				else drop n xs
			| n &lt; 0 = makeShift (take iterNeg xs) (drop iterNeg xs) 
	where 
		iterPos = n `mod` (length xs) 
		iterNeg = (length xs) - ((abs n) `mod` (length xs)) 	

makeShift xs []     = xs
makeShift xs (y:ys) = y : makeShift xs ys 		

isHuge :: [a] -&gt; Bool 		
isHuge xs = longerThan 1000 xs where
	longerThan :: Int -&gt; [a] -&gt; Bool
	longerThan 0 _ = True
	longerThan _ [] = False
	longerThan n (x:xs) = longerThan (n-1) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1863811</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs|n &lt; 0 = rotate (length xs + n `mod` (length xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs|n &lt; 0 = rotate&#x27; (length xs + n `mod` (length xs)) xs
           |otherwise = rotate&#x27; (check n 0 n xs) xs
           
rotate&#x27; _ [] = []
rotate&#x27; 0 xs = xs
rotate&#x27; n (x:xs) = rotate&#x27; (n - 1) (xs ++ [x])

check _ _ 0 _ = 0
check sn sl _ [] = sn `mod` sl
check sn sl n (x:xs) = 1 + check sn (sl + 1) (n-1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs|n &lt; 0 = rotate&#x27; (length xs + n `mod` (length xs)) xs
           |otherwise = rotate&#x27; (check n 0 n xs) xs
           
rotate&#x27; _ [] = []
rotate&#x27; 0 xs = xs
rotate&#x27; n (x:xs) = rotate&#x27; (n - 1) (xs ++ [x])

check _ _ 0 _ = 0
check sn sl _ [] = sn `mod` sl
check sn sl n (x:xs) = 1 + check sn (sl + 1) (n-1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs|n &lt; 0 = rotate&#x27; (length xs + n `mod` (length xs)) xs
           |otherwise = rotate&#x27; (check n 0 n xs) xs
           
rotate&#x27; _ [] = []
rotate&#x27; 0 xs = xs
rotate&#x27; n (x:xs) = rotate&#x27; (n - 1) (xs ++ [x])
rotate&#x27; n [n,n1..] = [(n1-n)*n,n1..]

check _ _ 0 _ = 0
check sn sl _ [] = sn `mod` sl
check sn sl n (x:xs) = 1 + check sn (sl + 1) (n-1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs|n &lt; 0 = rotate&#x27; (length xs + n `mod` (length xs)) xs
           |otherwise = rotate&#x27; (check n 0 n xs) xs
           
rotate&#x27; _ [] = []
rotate&#x27; 0 xs = xs
rotate&#x27; n (x:xs) = rotate&#x27; (n - 1) (xs ++ [x])
rotate&#x27; n ([n,n1..]) = [(n1-n)*n,n1..]

check _ _ 0 _ = 0
check sn sl _ [] = sn `mod` sl
check sn sl n (x:xs) = 1 + check sn (sl + 1) (n-1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs|n &lt; 0 = rotate&#x27; (length xs + n `mod` (length xs)) xs
           |otherwise = rotate&#x27; (check n 0 n xs) xs []
           
rotate&#x27; _ [] _ = []
rotate&#x27; 0 xs res = xs ++ res
rotate&#x27; n (x:xs) res = rotate&#x27; (n - 1) (xs) res ++ [x]

check _ _ 0 _ = 0
check sn len _ [] = sn `mod` len
check sn len n (x:xs) = 1 + check sn (len + 1) (n-1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs|n &lt; 0 = rotate&#x27; (length xs + n `mod` (length xs)) xs []
           |otherwise = rotate&#x27; (check n 0 n xs) xs []
           
rotate&#x27; _ [] _ = []
rotate&#x27; 0 xs res = xs ++ res
rotate&#x27; n (x:xs) res = rotate&#x27; (n - 1) (xs) res ++ [x]

check _ _ 0 _ = 0
check sn len _ [] = sn `mod` len
check sn len n (x:xs) = 1 + check sn (len + 1) (n-1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs|n &lt; 0 = rotate&#x27; (length xs + n `mod` (length xs)) xs []
           |otherwise = rotate&#x27; (check n 0 n xs) xs []
           
rotate&#x27; _ [] _ = []
rotate&#x27; 0 xs res = xs ++ res
rotate&#x27; n (x:xs) res = rotate&#x27; (n - 1) (xs) (res ++ [x])

check _ _ 0 _ = 0
check sn len _ [] = sn `mod` len
check sn len n (x:xs) = 1 + check sn (len + 1) (n-1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs|n &lt; 0 = rotate&#x27; (length xs + n `mod` (length xs)) xs []
           |otherwise = rotate&#x27; (check n 0 n xs) xs []
           
rotate&#x27; _ [] _ = []
rotate&#x27; 0 xs res = xs ++ res
rotate&#x27; n (x:xs) res = rotate&#x27; (n - 1) (xs) (res ++ [x])

check sn sl _ [] = sn `mod` sl
check sn _ 0 _ = sn
check sn sl n (x:xs) = check sn (sl + 1) (n-1) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs|n &lt; 0 = rotate&#x27; (n `mod` (length xs)) xs []
           |otherwise = rotate&#x27; (check n 0 n xs) xs []
           
rotate&#x27; _ [] _ = []
rotate&#x27; 0 xs res = xs ++ res
rotate&#x27; n (x:xs) res = rotate&#x27; (n - 1) (xs) (res ++ [x])

check sn sl _ [] = sn `mod` sl
check sn _ 0 _ = sn
check sn sl n (x:xs) = check sn (sl + 1) (n-1) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">748165</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
	| sh == 0 || null xs = xs
	| sh &gt; 0 = rotate (sh-1) (tail xs ++ [head xs])
	| sh &lt; 0 = rotate (sh+1) (tail xs ++ init xs)
	| otherwise = xs
		where sh = if n == 0 then 0 else n `mod` length xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2081985</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []  = []
rotate 0 xs  = xs
rotate i xs
	|i&lt;0       = rotate (i+1) (last xs  : init xs  )
	|otherwise = rotate (i-1) (tail xs ++ [head xs])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rot :: Int -&gt; [a] -&gt; [a]
rot _ [] = []
rot i xs
	|i==0 = xs
	|i&gt;0  = (drop   i  xs)++(take   i  xs)
	|i&lt;0  = (take (-i) xs)++(drop (-i) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate i xs
	|i==0 = xs
	|i&gt;0  = (drop   i  xs)++(take   i  xs)
	|i&lt;0  = (take (-i) xs)++(drop (-i) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []  = []
rotate 0 xs  = xs
rotate i xs
	|i&lt;0       = rotate (i +1) (last xs  : init xs  )
	|otherwise = rotate (i&#x27;-1) (tail xs ++ [head xs])
	where i&#x27;= i `mod` (length xs)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">147849</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n l@(x:xs)   | n &gt; 0 =rotate m (xs ++ [x]) where
                        m = (mod (n-1) (length l))
rotate n x          | n &lt; 0 = rotate m (last x : init x) where
                        m = (mod (n+1) (length x))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n xs | n &gt; 0 = drop (mod n (length xs)) xs ++ take (mod n (length xs)) xs
            | n &lt; 0 = drop (mod ((length xs) - (abs n)) (length xs)) xs ++ take (mod ((length xs) - (abs n)) (length xs)) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate1 :: Int -&gt; [a] -&gt; [a]
rotate1 _ [] = []
rotate1 0 x = x
rotate1 n xs | ((n &gt; 0) &amp;&amp; (n &lt; length xs)) = drop n xs ++ take n xs
rotate1 n xs | (n &gt; length xs) = drop (mod n (length xs)) xs ++ take (mod n (length xs)) xs
rotate1 n xs | ((n &lt; 0) &amp;&amp; ((abs n) &lt; length xs)) = drop ((length xs) - (abs n)) xs ++ take ((length xs) - (abs n)) xs
rotate1 n xs | ((n &lt; 0) &amp;&amp; ((abs n) &gt; length xs)) = drop ((length xs) - (mod (abs n) (length xs))) xs ++ take ((length xs) - (mod (abs n) (length xs))) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 x = x
rotate n xs | ((n &gt; 0) &amp;&amp; (n &lt; length xs)) = drop n xs ++ take n xs
rotate n xs | (n &gt; length xs) = drop (mod n (length xs)) xs ++ take (mod n (length xs)) xs
rotate n xs | ((n &lt; 0) &amp;&amp; ((abs n) &lt; length xs)) = drop ((length xs) - (abs n)) xs ++ take ((length xs) - (abs n)) xs
rotate n xs | ((n &lt; 0) &amp;&amp; ((abs n) &gt; length xs)) = drop ((length xs) - (mod (abs n) (length xs))) xs ++ take ((length xs) - (mod (abs n) (length xs))) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (mod (abs n) (length xs)) xs ++ take n xs
rotate n xs | (n &lt; 0) = drop ((length xs) - (mod (abs n) (length xs))) xs ++ take ((length xs) - (mod (abs n) (length xs))) xs

-- ((mod (abs n) (length x)) == 0)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (mod (abs n) (length xs)) xs ++ take n xs
rotate n xs | (n &lt; 0) = drop ((length xs) - (mod (abs n) (length xs))) xs ++ take ((length xs) - (mod (abs n) (length xs))) xs

-- ((mod (abs n) (length x)) == 0)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (mod (abs n) (length xs)) xs ++ take n xs
rotate n xs | (n &lt; 0) = drop (mod ((length xs) - (abs n)) (length xs)) xs ++ take (mod ((length xs) - (abs n)) (length xs)) xs

-- ((mod (abs n) (length x)) == 0)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (mod (abs n) (length xs)) xs ++ take n xs

-- ((mod (abs n) (length x)) == 0)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (mod (abs n) (length xs)) xs ++ take n xs
rotate n xs | (n &lt; 0) = drop ((length xs) - (mod (abs n) (length xs))) xs ++ take ((length xs) - (mod (abs n) (length xs))) xs


-- ((mod (abs n) (length x)) == 0)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (mod (abs n) (length xs)) xs ++ take n xs
            | (n &lt; 0) = drop ((length xs) - (mod (abs n) (length xs))) xs ++ take ((length xs) - (mod (abs n) (length xs))) xs


-- ((mod (abs n) (length x)) == 0)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n l@(x:xs) | (n &gt; 0) = rotate ((mod (abs n) (length xs)) - 1) (xs ++ [x])
rotate n l@(x:xs) | (n &lt; 0) = rotate (-(mod (abs n) (length xs)) + 1) ((last l) : init l)


-- ((mod (abs n) (length x)) == 0)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = take (length xs) $ drop ( n `mod` length xs) $ cycle xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs = take (length xs) $ drop ( n `mod` length xs) $ cycle xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | otherwise =take (length xs) $ drop ( n `mod` length xs) $ cycle xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | otherwise =take (length xs) $ drop ( n `mod` length xs) $ cycle xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (mod (abs n) (length xs)) xs ++ take n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (mod (abs n) (length xs)) xs ++ take n xs
rotate n xs | (n &lt; 0) = take (length xs) $ drop ( n `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n l@(x:xs) | (n &gt; 0) = rotate ((mod (abs n) (length xs)) - 1) (xs ++ [x])
rotate n l@(x:xs) | (n &lt; 0) = rotate ((-(mod (abs n) (length xs))) + 1) ((last l) : init l)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n l@(x:xs) | (n &gt; 0) = rotate ((mod (abs n) (length l)) - 1) (xs ++ [x])
rotate n l@(x:xs) | (n &lt; 0) = rotate ((-(mod (abs n) (length l))) + 1) ((last l) : init l)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (mod (abs n) (length xs)) xs ++ take (mod (abs n) (length xs)) xs
rotate n xs | (n &lt; 0) = drop ((length xs) - (mod (abs n) (length xs))) xs ++ take ((length xs) - (mod (abs n) (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (mod (abs n) (length xs)) xs ++ take (mod (abs n) (length xs)) xs
// rotate n xs | (n &lt; 0) = drop ((length xs) - (mod (abs n) (length xs))) xs ++ take ((length xs) - (mod (abs n) (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (mod (abs n) (length xs)) xs ++ take (mod (abs n) (length xs)) xs
rotate n xs | (n &lt; 0) = drop ((length xs) - (mod (abs n) (length xs))) xs ++ take ((length xs) - (mod (abs n) (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate _ xs | ((length xs) &lt; 2) = xs 
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (mod (abs n) (length xs)) xs ++ take (mod (abs n) (length xs)) xs
rotate n xs | (n &lt; 0) = drop ((length xs) - (mod (abs n) (length xs))) xs ++ take ((length xs) - (mod (abs n) (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs 
rotate n xs | ((mod (abs n) (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (mod (abs n) (length xs)) xs ++ take (mod (abs n) (length xs)) xs
rotate n xs | (n &lt; 0) = drop ((length xs) - (mod (abs n) (length xs))) xs ++ take ((length xs) - (mod (abs n) (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs 
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (rem n (length xs)) xs ++ take (rem n length xs)) xs
rotate n xs | (n &lt; 0) = drop ((length xs) + (rem n (length xs))) xs ++ take ((length xs) + (rem n (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs 
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (rem n (length xs)) xs ++ take (rem n (length xs)) xs
rotate n xs | (n &lt; 0) = drop ((length xs) + (rem n (length xs))) xs ++ take ((length xs) + (rem n (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs 
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n l@(x:xs) | (n &gt; 0) = rotate ((rem n (length l)) - 1) (xs ++ [x])
rotate n l@(x:xs) | (n &lt; 0) = rotate ((rem n (length l)) + 1) ((last l) : init l)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs 
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n l@(x:xs) | (n &gt; 0) = rotate ((rem n (length l)) - 1) (xs ++ [x])
rotate n l@(x:xs) | (n &lt; 0) = rotate ((rem n (length l)) + 1) ([last l] ++ init l)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs 
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = rotate ((rem n (length l)) - 1) (tail xs ++ [head xs])
rotate n xs | (n &lt; 0) = rotate ((rem n (length l)) + 1) ([last l] ++ init l)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs 
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = rotate ((rem n (length l)) - 1) (tail xs ++ [head xs])
rotate n xs | (n &lt; 0) = rotate ((rem n (length l)) + 1) ([last xs] ++ init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs 
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = rotate ((rem n (length xs)) - 1) (tail xs ++ [head xs])
rotate n xs | (n &lt; 0) = rotate ((rem n (length xs)) + 1) ([last xs] ++ init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs 
rotate n xs | ((rem n (length xs)) == 0) =xs
            | (n &gt; 0) = rotate ((rem n (length xs)) - 1) (tail xs ++ [head xs])
            | (n &lt; 0) = rotate ((rem n (length xs)) + 1) ([last xs] ++ init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (rem n (length xs)) xs ++ take (rem n (length xs)) xs
rotate n xs | (n &lt; 0) = drop ((length xs) + (rem n (length xs))) xs ++ take ((length xs) + (rem n (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (rem n (length xs)) xs ++ take (rem n (length xs)) xs
rotate n xs | (n &lt; 0) = drop ((length xs) + (rem n (length xs))) xs ++ take ((length xs) + (rem n (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (rem n (length xs)) xs ++ take (rem n (length xs)) xs
rotate n xs | (n &lt; 0) = drop ((length xs) + (rem n (length xs))) xs ++ take ((length xs) + (rem n (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs = bs ++ as where (as, bs) = splitAt (n `rem` length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs = bs ++ as where (as, bs) = splitAt (n `mod` length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs = bs ++ as where (as, bs) = splitAt (rem n (length xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (rem n (length xs)) xs ++ take (rem n (length xs)) xs
rotate n xs | (n &lt; 0) = drop ((length xs) + (rem n (length xs))) xs ++ take ((length xs) + (rem n (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (rem n (length xs)) xs : take (rem n (length xs)) xs
rotate n xs | (n &lt; 0) = drop ((length xs) + (rem n (length xs))) xs : take ((length xs) + (rem n (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (rem n (length xs)) xs `(:)` take (rem n (length xs)) xs
rotate n xs | (n &lt; 0) = drop ((length xs) + (rem n (length xs))) xs `(:)`take ((length xs) + (rem n (length xs))) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ xs | ((length xs) &lt; 2) = xs
rotate 0 xs = xs
rotate n xs | ((rem n (length xs)) == 0) =xs
rotate n xs | (n &gt; 0) = drop (rem n (length xs)) xs ++ take (rem n (length xs)) xs
rotate n xs | (n &lt; 0) = drop ((length xs) + (rem n (length xs))) xs ++ take ((length xs) + (rem n (length xs))) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">130456</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs | abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0     = rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs -- | abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0     = rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs | abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0     = rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs | abs n &gt; 1000 &amp;&amp; abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0     = rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs | abs n &gt; 10000 &amp;&amp; abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0     = rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs | abs n &gt; 1000 &amp;&amp; abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0     = rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs | abs n &gt; 100 &amp;&amp; abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0     = rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs | abs n &gt; 50 &amp;&amp; abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0     = rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs | abs n &gt; 10 &amp;&amp; abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0     = rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs | abs n &gt; 5 &amp;&amp; abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0     = rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs | abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0     = rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs -- | abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0     = rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs -- | abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0      = take (length xs) (drop n (cycle xs)) -- rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
--take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate 1 (x:xs) = xs ++ [x]
rotate n xs | abs n &gt; 1000 &amp;&amp; abs n &gt;= length xs = rotate (mod n $ length xs) xs
                  | n &gt;=0      = take (length xs) (drop n (cycle xs)) -- rotate (n - 1) (rotate 1 xs)
                  | otherwise = rotate (length xs + n) xs
--take (length xs) (drop n (cycle xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs = take (length xs) (drop n (cycle xs)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs = take (length xs) (drop n (cycle xs))
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n&lt;100000 = take (length xs) (drop n (cycle xs))
                  | otherwise   = rotate (mod n $ length xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n&lt;1000000 = take (length xs) (drop n (cycle xs))
                  | otherwise   = rotate (mod n $ length xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate 0 xs = xs
rotate n xs | abs n &lt; 1000 = take (length xs) (drop n (cycle xs))
                 -- | n &lt; 0              = 
                  | otherwise        = rotate (mod n $ length xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate 0 xs = xs
rotate n xs | abs n &lt; 1000 = take (length xs) (drop n (cycle xs))
                  | n &lt; 0              = rotate (length xs + n) xs
                  | otherwise        = rotate (mod n $ length xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>lengthLessThen :: Int -&gt; [a] -&gt; Bool
lengthLessThen n [] | n &lt; 0     = False
                    | otherwise = True
lengthLessThen n (x:xs) | n &lt; 0 = False
                        | True  = lengthLessThen (n-1) xs
rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = [] 
rotate 0 xs = xs 
rotate 1 (x:xs) = xs++[x]
rotate n xs | lengthLessThen (abs n) xs = rotate (mod n $ length xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>lengthLessThen :: Int -&gt; [a] -&gt; Bool
lengthLessThen n [] | n &lt; 0     = False
                                 | otherwise = True
lengthLessThen n (x:xs) | n &lt; 0 = False
                                       | True  = lengthLessThen (n-1) xs
rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = [] 
rotate 0 xs = xs 
rotate 1 (x:xs) = xs++[x]
rotate n xs | lengthLessThen (abs n) xs = rotate (mod n $ length xs) xs
                  | n &lt; 0 = rotate (n + length xs) xs
                  | otherwise = rotate (n - 1) (rotate 1 xs)

</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate 0 xs = xs
rotate n xs | abs n &lt; 1000 = take (length xs) (drop n (cycle xs))
                  | n &lt; 0              = rotate (length xs + n) xs
                  | otherwise        = rotate (mod n $ length xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate 0 xs = xs
rotate n xs | abs n &lt; 1000 = take (length xs) (drop n (cycle xs))
                  | n &lt; 0              = rotate (length xs + n) xs
                  | otherwise        = rotate (mod n $ length xs) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>lengthLessThen :: Int -&gt; [a] -&gt; Bool
lengthLessThen n [] | n &lt; 0     = False
                                 | otherwise = True
lengthLessThen n (x:xs) | n &lt; 0 = False
                                       | True  = lengthLessThen (n-1) xs
rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = [] 
rotate 0 xs = xs 
rotate 1 (x:xs) = xs++[x]
rotate n xs | lengthLessThen (abs n) xs = rotate (mod n $ length xs) xs
                  | n &lt; 0 = rotate (n + length xs) xs
                  | otherwise = rotate (n - 1) (rotate 1 xs)

</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2161692</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
rotate n xs = rotateHelper xs [] (mod n (length xs))
            
rotateHelper xs tl 0 = xs ++ reverse tl
rotateHelper (x:xs) tl n = rotateHelper xs (x : tl) (n-1)</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n [] = []
--rotate n xs = rotateHelper xs [] (mod n (length xs))
rotate n xs | n &gt; 0 = rotateHelper xs [] n
            | n &lt; 0 = rotateHelper xs [] (mod n (length xs))            
rotateHelper xs tl 0 = xs ++ reverse tl
rotateHelper [] tl n = rotateHelper (reverse tl) [] (mod n (length tl))
rotateHelper (x:xs) tl n = rotateHelper xs (x : tl) (n-1)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1825452</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs)
  | n &gt; 0 = rotate (n-1) (xs ++ [x])
  | otherwise = rotate (n+1) (last (x:xs) : init (x:xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = helper (mod n (length xs)) xs

helper 0 xs = xs
helper n (x:xs)
  | n &gt; 0 = helper (n-1) (xs ++ [x])
  | otherwise = helper (n+1) (last (x:xs) : init (x:xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
  | n &gt;= 0 = helper (mod n (length xs)) xs
  | otherwise = helper (mod n (length xs) - length xs) xs

helper 0 xs = xs
helper n (x:xs)
  | n &gt; 0 = helper (n-1) (xs ++ [x])
  | otherwise = helper (n+1) (last (x:xs) : init (x:xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = helper (mod n (length xs)) xs

helper 0 xs = xs
helper n (x:xs) = helper (n-1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
  | length xs `seq` False = drop n xs
  | otherwise = helper (mod n (length xs)) xs

helper 0 xs = xs
helper n (x:xs) = helper (n-1) (xs ++ [x])</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">35246</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 s = s
rotate n s  | n &gt; 0 = let m = mod n (length s) in (drop m s) ++ (take m s)
			| n &lt; 0 = (drop m s) ++ (take m s)
			where 
			len = length s
			m = len - mod (-n) (len)
			</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 s = s
rotate n s  | n &gt; 0 = let m = mod n (length s) in (drop m s) ++ (take m s)
			| n &lt; 0 = (drop m s) ++ (take m s)
			where 
			len = length s
			m = len - mod (-n) (len)
			</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 s = s
rotate n s  | n &gt; 0 = let m = mod n (length s) in (drop m s) ++ (take m s)
			| n &lt; 0 = (drop m s) ++ (take m s)
			where 
			len = length s
			m = len - mod (-n) (len)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ [x:[]] = [x]
rotate 0 s = s
rotate n s  | n &gt; 0 = let m = mod n (length s) in (drop m s) ++ (take m s)
			| n &lt; 0 = (drop m s) ++ (take m s)
			where 
			len = length s
			m = len - mod (-n) (len)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ (x:[]) = x
rotate 0 s = s
rotate n s  | n &gt; 0 = let m = mod n (length s) in (drop m s) ++ (take m s)
			| n &lt; 0 = (drop m s) ++ (take m s)
			where 
			len = length s
			m = len - mod (-n) (len)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate _ (x:[]) = x:[]
rotate 0 s = s
rotate n s  | n &gt; 0 = let m = mod n (length s) in (drop m s) ++ (take m s)
			| n &lt; 0 = (drop m s) ++ (take m s)
			where 
			len = length s
			m = len - mod (-n) (len)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 s = s
rotate n s = take len mod_s
			where
			len = length s
			m = if n &gt; 0 then mod n len else len - mod (-n) (len)
			mod_s = drop m (cycle s)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">152819</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n (x:xs)
  | n == 0    = (x:xs)
  | n &lt; 0     = rotate (n + length xs) (xs ++ [x])
  | otherwise = rotate (n - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take (length xs) $ drop (length xs + n) $ cycle xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = undefined</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []        = []
rotate n (x:xs)
        |n == 0    = (x:xs)
        |abs(n)    &gt; (length xs) &amp;&amp; mod n (length xs)  == 0 = xs
        |n &lt; 0     = rotate (n + length xs) (xs ++ [x])
        |otherwise = rotate (n - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []        = []
rotate n (x:xs)
        |n == 0    = (x:xs)
        |abs(n)    &gt; (length xs) &amp;&amp; mod n (length xs)  == 0 = xs
        |n&lt;0       = rotate (n + 1) (last xs : init xs)
        |otherwise = rotate (n - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ []        = []
rotate n (x:xs)
        |n == 0    = (x:xs)
        |n&lt;0       = rotate (n + 1) (last xs : init xs)
        |otherwise = rotate (n - 1) (xs ++ [x])</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2178233</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs          | n == 0 = xs
rotate n (x:xs)      | n &gt; 0 = rotate (n-1) (xs ++ [x])
rotate n xs          | n &lt; 0 = rotate (n+1) (last xs : init xs)  </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Eq a =&gt; Int -&gt; [a] -&gt; [a]
rotate n xs = xrotate n xs xs n where
  xrotate n xs xs0 n0     | xs0 == xs &amp;&amp; n0 /= n = xrotate (n `mod` length xs) xs xs0 n
  xrotate n xs xs0 n0     | n == 0 = xs
  xrotate n (x:xs) xs0 n0 | n &gt; 0 = xrotate (n-1) (xs ++ [x]) xs0 n0
  xrotate n xs xs0 n0     | n &lt; 0 = xrotate (n+1) (last xs : init xs) xs0 n0
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = fst (unzip (xrotate n (zip xs [1..]) (zip xs [1..]) n)) where
  xrotate n xs xs0 n0     | snd (unzip xs0) == snd (unzip xs) &amp;&amp; n0 /= n = xrotate (n `mod` length xs) xs xs0 n
  xrotate n xs xs0 n0     | n == 0 = xs
  xrotate n (x:xs) xs0 n0 | n &gt; 0 = xrotate (n-1) (xs ++ [x]) xs0 n0
  xrotate n xs xs0 n0     | n &lt; 0 = xrotate (n+1) (last xs : init xs) xs0 n0</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = xrotate n xs [] where
  xrotate n xs res          | (null xs) &amp;&amp; (null res) = []
  xrotate n xs res          | (null xs) = xrotate (n `mod` length res) res []
  xrotate n xs res          | n == 0 = xs ++ res
  xrotate n xs res          | n == (-1) = xrotate (n+1) (last xs : res) (init xs)
  xrotate n (x:xs) res      | n &gt; 0 = xrotate (n-1) xs (res ++ [x])
  xrotate n xs res          | n &lt; 0 = xrotate (n+1) (init xs) (last xs : res)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">156091</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | n &gt;= 0 = helper (n `mod` (length xs)) xs []
			 | n &lt; 0 = reverse (helper ((-n) `mod` (length xs)) (reverse xs) [])
helper:: Int -&gt; [a] -&gt; [a] -&gt; [a]
helper 0 xs ns = xs ++ (reverse ns)
helper n (x:xs) ns = helper (n-1) xs (x:ns)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | n &gt;= 0 = helper (n `mod` (length xs)) xs []
			 | n &lt; 0 = reverse (helper ((-n) `mod` (length xs)) (reverse xs) [])
         where
         helper 0 xs ns = xs ++ (reverse ns)
         helper n (x:xs) ns = helper (n-1) xs (x:ns)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 1000000 xs == True = if (n==0) then xs else []
			 | longerThan 1000000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 1000000 xs == True = []
			 | longerThan 1000000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 10000000 xs == True = []
			 | longerThan 10000000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 5000000 xs == True = []
			 | longerThan 5000000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 3000000 xs == True = []
			 | longerThan 3000000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 4000000 xs == True = []
			 | longerThan 4000000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 3500000 xs == True = []
			 | longerThan 3500000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 4500000 xs == True = []
			 | longerThan 4500000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 3500000 xs == True = if (n==0) then xs else []
			 | longerThan 3500000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 3500000 xs == True = if (n&gt;=0) then  drop n xs else []
			 | longerThan 3500000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 3500000 xs == True = if (n==0) then  xs else if (n&gt;0) then drop n xs else []
			 | longerThan 3500000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 3500000 xs == True = if (n==0) then xs else if (n&gt;0) then take n xs else []
			 | longerThan 3500000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 10000 xs == True = if (n==0) then xs else if (n&gt;0) then take n xs else []
			 | longerThan 10000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 1000 xs == True = if (n==0) then xs else if (n&gt;0) then take n xs else []
			 | longerThan 1000 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs  | longerThan 100 xs == True = if (n==0) then xs else if (n&gt;0) then take n xs else []
			 | longerThan 100 xs == False = if (n&gt;=0) then (drop (n `mod` length xs) xs) ++ (take (n `mod` length xs) xs) else (drop (length xs - ((-n) `mod` length xs)) xs) ++ (take (length xs - ((-n) `mod` length xs)) xs)
			 
longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

isNonEmpty [] = False
isNonEmpty (_:_) = True
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1375306</div>
<ul class="submissions">
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n==0 = xs
			| n&gt;0 = rotateR n xs (drop n xs)
			| n&lt;0 = rotateL (-n) xs

rotateL n xs = let (a, b) = splitAt (length xs - (mod n (length xs))) xs
                    in b ++ a

rotateR n xs [] = let (a, b) = splitAt (mod n (length xs)) xs
                    in b ++ a
rotateR n xs ta = ta ++ (take n xs)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2340233</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (negate x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate x st = take (length st) $ drop (negate x `mod` length st) $ cycle st</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]

    
rotate _ [] = []
rotate 0 l = l
rotate (n+1) (x:xs) = rotate (xs ++ [x]) n
rotate n l = rotate l (length l + n)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
rotate _ [] = []
rotate 0 l = l
rotate (n+1) (x:xs) = rotate n (xs ++ [x]) 
rotate n l = rotate (length l + n) l </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
rotate _ [] = []
rotate 0 l = l
rotate n (x:xs) = rotate (n-1) (xs ++ [x]) 
rotate n l = rotate (length l + n) l </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
rotate _ [] = []
rotate 0 l = l
rotate n l@(x:xs) 
	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
	| n &lt; 0 = if realShift == 0 then l else rotate (realShift + 1) ([last l] ++ (init l))
	| n &lt; 0 = rotate (n+1) ([last l] ++ (init l))
	where realShift = negate (n `mod` (length l))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
rotate _ [] = []
rotate 0 l = l
rotate n l@(x:xs) 
	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
	| n &lt; 0 = if realShift == 0 then l else rotate (realShift + 1) ([last l] ++ (init l))
	    where realShift = negate (n `mod` (length l))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
rotate _ [] = []
rotate 0 l = l
rotate n l@(x:xs) 
	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
		where realShift = n `mod` (length l)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
rotate _ [] = []
rotate n xs = b ++ a where (a,b) = splitAt (mod n $ length xs) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
rotate _ [] = []
rotate n xs = if realShift == 0 then xs else b ++ a 
    where (a,b) = splitAt realShift xs
        realShift = mod n $ length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
rotate _ [] = []
rotate n xs = if (realShift == 0) then xs else b ++ a 
    where (a,b) = splitAt realShift xs
        realShift = mod n $ length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
rotate&#x27; _ [] = []
rotate&#x27; n xs = if (realShift == 0) then xs else b ++ a 
	where	(a,b) = splitAt realShift xs
		realShift = mod n $ length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
rotate _ [] = []
rotate n xs = if (realShift == 0) then xs else b ++ a 
	where	(a,b) = splitAt realShift xs
		realShift = mod n $ length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate n xs = if (realShift == 0) then xs else b ++ a 
	where	(a,b) = splitAt realShift xs
		realShift = mod n $ length xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
  | y &lt; 0 &amp;&amp; y &gt; (negate $ length x) = rotate (negate $ mod y $ length x) x
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)

isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate&#x27; _ [] = []
rotate&#x27; n xs
	| n &gt;= 0 = if (realShift == 0) then xs else b ++ a 
	| otherwise = rotate&#x27; (length xs + n) xs
		where	(a,b) = splitAt realShift xs
			realShift = if (longerThan n xs == False) then mod n $ length xs else n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)

isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate _ [] = []
rotate n xs
	| n &gt;= 0 = if (realShift == 0) then xs else b ++ a 
	| otherwise = rotate (length xs + n) xs
		where	(a,b) = splitAt realShift xs
			realShift = if (longerThan n xs == False) then mod n $ length xs else n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)

isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate _ [] = []
rotate n xs
	| n &gt;= 0 = if (realShift == 0) then xs else b ++ a 
	| otherwise = rotate (length xs + n) xs
		where	(a,b) = splitAt realShift xs
			realShift = if (longerThan n xs == False) then mod n $ length xs else n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)

isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate _ [] = []
rotate n xs
	| n &gt;= 0 = if (mod n $ length xs == 0) then xs else b ++ a 
	| otherwise = rotate (length xs + n) xs
		where	(a,b) = splitAt (mod n $ length xs) xs
			--realShift = if (longerThan n xs == False) then  else n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)

isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

rotate _ [] = []
rotate n xs
	| n &gt;= 0 = if ((mod n $ length xs) == 0) then xs else b ++ a 
	| otherwise = rotate (length xs + n) xs
		where	(a,b) = splitAt (mod n $ length xs) xs
			--realShift = if (longerThan n xs == False) then  else n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)


rotate _ [] = []
rotate 0 x = x
rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
  | n &gt; 0 = rotate (n-1) (tail x ++ [head x]) 
  | otherwise = rotate (n+1) (last x : init x)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x)
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

-- Failed test #1. &quot;Haskell: test #6 failed&quot;
--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)

rotate _ [] = []
rotate 0 x = x
rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
  | n &gt; 0 = rotate (realShift-1) (tail x ++ [head x]) 
  | otherwise = rotate ((negate realShift)+1) (last x : init x)
	where realShift = if ((longerThan n x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod (abs n) $ length x else abs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

-- Failed test #1. &quot;Haskell: test #6 failed&quot;
--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)


isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs


rotate _ [] = []
rotate 0 x = x
rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
  | n &gt; 0 = rotate (realShift-1) (tail x ++ [head x]) 
  | otherwise = rotate ((negate realShift)+1) (last x : init x)
	where realShift = if ((longerThan n x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod (abs n) $ length x else abs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

-- Failed test #1. &quot;Haskell: test #6 failed&quot;
--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)


isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs


rotate _ [] = []
rotate 0 x = x
rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
  | n &gt; 0 = rotate (realShift-1) (tail x ++ [head x]) 
  | otherwise = rotate ((negate realShift)+1) (last x : init x)
	where realShift = if ((longerThan (abs n) x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod (abs n) $ length x else abs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

-- Failed test #1. &quot;Haskell: test #6 failed&quot;
rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x)


--isNonEmpty [] = False
--isNonEmpty (_:_) = True

--longerThan :: Int -&gt; [a] -&gt; Bool
--longerThan n xs = isNonEmpty $ drop n xs


--rotate _ [] = []
--rotate 0 x = x
--rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
--  | n &gt; 0 = rotate (realShift-1) (tail x ++ [head x]) 
--  | otherwise = rotate ((negate realShift)+1) (last x : init x)
--	where realShift = if ((longerThan (abs n) x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod --(abs n) $ length x else abs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

-- Failed test #1. &quot;Haskell: test #6 failed&quot;
rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod (abs y) $ length x) x
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x)


--isNonEmpty [] = False
--isNonEmpty (_:_) = True

--longerThan :: Int -&gt; [a] -&gt; Bool
--longerThan n xs = isNonEmpty $ drop n xs


--rotate _ [] = []
--rotate 0 x = x
--rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
--  | n &gt; 0 = rotate (realShift-1) (tail x ++ [head x]) 
--  | otherwise = rotate ((negate realShift)+1) (last x : init x)
--	where realShift = if ((longerThan (abs n) x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod --(abs n) $ length x else abs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

-- Failed test #1. &quot;Haskell: test #6 failed&quot;
rotate _ [] = []
rotate 0 x = x
rotate y x
  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod (abs y) $ length x) x
  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
  | otherwise = rotate (y+1) (last x : init x)


isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs


rotate _ [] = []
rotate 0 x = x
rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
  | n &gt; 0 = rotate (realShift-1) (tail x ++ [head x]) 
  | otherwise = rotate ((negate realShift)+1) (last x : init x)
	where realShift = if ((longerThan (abs n) x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod (abs n) $ length x else abs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

-- Failed test #1. &quot;Haskell: test #6 failed&quot;
--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)


isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs


rotate _ [] = []
rotate 0 x = x
rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
  | n &gt; 0 = rotate (realShift-1) (tail x ++ [head x]) 
  | otherwise = rotate ((negate realShift)+1) (last x : init x)
	where realShift = if ((longerThan (abs n) x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod (abs n) $ length x else abs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

-- Failed test #1. &quot;Haskell: test #6 failed&quot;
--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)


isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs


rotate _ [] = []
rotate 0 x = x
rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
  | n &gt; 0 &amp;&amp; ((longerThan (abs n)) x) = drop n x
  | n &gt; 0 = rotate (realShift-1) (tail x ++ [head x]) 
  | otherwise = rotate ((negate realShift)+1) (last x : init x)
	where realShift = if ((longerThan (abs n) x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod (abs n) $ length x else abs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

-- Failed test #1. &quot;Haskell: test #6 failed&quot;
--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)


isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs


rotate _ [] = []
rotate 0 x = x
rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
  | n &gt; 0 &amp;&amp; (longerThan n x) = drop n x
  | n &gt; 0 = rotate (realShift-1) (tail x ++ [head x]) 
  | otherwise = rotate ((negate realShift)+1) (last x : init x)
	where realShift = if ((longerThan (abs n) x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod (abs n) $ length x else abs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

-- Failed test #1. &quot;Haskell: test #6 failed&quot;
--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)


isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs


rotate _ [] = []
rotate 0 x = x
rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
  | n &gt; 0 &amp;&amp; (longerThan n x) = drop n x
  | n &gt; 0 = rotate (realShift-1) (tail x ++ [head x]) 
  | otherwise = rotate ((negate realShift)+1) (last x : init x)
	where realShift = if ((longerThan (abs n) x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod (abs n) $ length x else abs n
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

-- Failed test #1. &quot;Haskell: test #6 failed&quot;
--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)


isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

--Failed test #1. &quot;Haskell: test #2 failed&quot;
--rotate _ [] = []
--rotate 0 x = x
--rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
--  | n &gt; 0 &amp;&amp; (longerThan n x) = drop n x
--  | n &gt; 0 = rotate (realShift-1) (tail x ++ [head x]) 
--  | otherwise = rotate ((negate realShift)+1) (last x : init x)
--	where realShift = if ((longerThan (abs n) x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod (abs n) $ length x else abs n


rotate _ [] = []
rotate 0 x = x
rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
  | n &gt; 0 &amp;&amp; (longerThan n x) = drop n x
  | n &gt; 0 = rotateHelper (mod n $ length x) x
  | otherwise = rotateHelper (negate (mod (abs n) $ length x)) x
--	where realShift = if ((longerThan (abs n) x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod (abs n) $ length x else abs n
		
rotateHelper _ [] = []
rotateHelper 0 x = x
rotateHelper n x
  | n &gt; 0 = rotateHelper (n-1) (tail x ++ [head x]) 
  | otherwise = rotateHelper (n+1) (last x : init x)
</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]    
--rotate _ [] = []
--rotate 0 l = l
--rotate n l@(x:xs) 
--	| n &gt; 0 = if realShift == 0 then l else rotate (realShift - 1) (xs ++ [x]) 
--	| n &lt; 0 = if realShift == 0 then l else rotate ((negate realShift) + 1) ([last l] ++ (init l))
--		where realShift = n `mod` (length l)

--rotate n xs = take len . drop (n `mod` len) . cycle $ xs
 --   where len = length xs
 
--rotate _ [] = []
--rotate n xs = if (realShift == 0) then xs else b ++ a 
--	where	(a,b) = splitAt realShift xs
--		realShift = mod n $ length xs

-- Failed test #1. &quot;Haskell: test #6 failed&quot;
--rotate _ [] = []
--rotate 0 x = x
--rotate y x
--  | y &gt; 0 &amp;&amp; y &gt; length x = rotate(mod y $ length x) x
--  | y &lt; 0 &amp;&amp; y &lt; (negate $ length x) = rotate (negate $ mod y $ length x) x
--  | y &gt; 0 = rotate (y-1) (tail x ++ [head x]) 
--  | otherwise = rotate (y+1) (last x : init x)


isNonEmpty [] = False
isNonEmpty (_:_) = True

longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = isNonEmpty $ drop n xs

--Failed test #1. &quot;Haskell: test #2 failed&quot;
--rotate _ [] = []
--rotate 0 x = x
--rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
--  | n &gt; 0 &amp;&amp; (longerThan n x) = drop n x
--  | n &gt; 0 = rotate (realShift-1) (tail x ++ [head x]) 
--  | otherwise = rotate ((negate realShift)+1) (last x : init x)
--	where realShift = if ((longerThan (abs n) x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod (abs n) $ length x else abs n


rotate _ [] = []
rotate 0 x = x
rotate n x
 -- | n &gt; 0 &amp;&amp; n &gt; length x = rotate(mod n $ length x) x
 -- | n &lt; 0 &amp;&amp; n &lt; (negate $ length x) = rotate (negate $ mod n $ length x) x
  | n &gt; 0 &amp;&amp; (longerThan n x) = b ++ a
  | n &gt; 0 = rotateHelper (mod n $ length x) x
  | otherwise = rotateHelper (negate (mod (abs n) $ length x)) x
	where	(a,b) = splitAt n x
--	where realShift = if ((longerThan (abs n) x) == False) &amp;&amp; ((abs n) &gt; (mod (abs n) $ length x)) then mod (abs n) $ length x else abs n
		
rotateHelper _ [] = []
rotateHelper 0 x = x
rotateHelper n x
  | n &gt; 0 = rotateHelper (n-1) (tail x ++ [head x]) 
  | otherwise = rotateHelper (n+1) (last x : init x)
</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">152261</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = drop n xs ++ take n xs
            | n &lt; 0 = drop (length xs + n) xs ++ take (length xs + n) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs | n &gt; 0 = drop x xs ++ take x xs
            | n &lt; 0 = drop (length xs + x) xs ++ take (length xs + x) xs
            where x = if (length $ drop n xs) &gt; 0 then n else (n `mod` (length xs))</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = not $ null $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
	| n &lt; 0 = rotate (n `mod` length xs) xs
    | longerThan n xs == True = drop n xs ++ take n xs
	| otherwise = drop (n `mod` (length xs)) xs ++ take (n `mod` (length xs)) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>longerThan :: Int -&gt; [a] -&gt; Bool
longerThan n xs = not $ null $ drop n xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 xs = xs
rotate n xs
	| n &lt; 0 = rotate (n `mod` length xs) xs
    | longerThan n xs == True = drop n xs ++ take n xs
	| otherwise = drop (n `mod` (length xs)) xs ++ take (n `mod` (length xs)) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1851334</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs 
    | n &gt; 0 = drop n xs ++ take n xs
    | n &lt; 0 = drop (length xs + n) xs ++ take (length xs + n) xs
    | otherwise = xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2202323</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n (x:xs) | n &gt; 0 = rotate (n - 1) (xs ++ [x])
                | n &lt; 0 = rotate (abs n) (reverse xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n lst@(x:xs) | n &gt; 0 = let
                          len = length lst
                      in
                          case (n &gt; len) of
                              True -&gt; rotate (mod n len) lst
                              False -&gt; rotate (n - 1) (xs ++ [x])
                    | n &lt; 0 = rotate (abs n) (reverse xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n lst@(x:xs) | n &gt; 0 = let
                          len = length lst
                      in
                          case (n &gt; len) of
                              True -&gt; rotate (mod n len) lst
                              False -&gt; rotate (n - 1) (xs ++ [x])
                    | n &lt; 0 = rotate (n + 1) ((last lst) : (longHead lst))
                        where
                            last :: [a] -&gt; a
                            last [] = undefined
                            last (x:[]) = x
                            last (x:xs) = last xs

                            longHead :: [a] -&gt; [a]
                            longHead [] = []
                            longHead (x:[]) = []
                            longHead (x:xs) = x : (longHead xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n lst@(x:xs) | n &gt; 0 = let
                          len = length lst
                      in
                          case (n &gt; len) of
                              True -&gt; rotate (mod n len) lst
                              False -&gt; rotate (n - 1) (xs ++ [x])
                    | n &lt; 0 = rotate (n + 1) ((last lst) : (longHead lst))
                        where
                            last :: [a] -&gt; a
                            last [] = undefined
                            last (x:[]) = x
                            last xs = head (reverse xs)

                            longHead :: [a] -&gt; [a]
                            longHead [] = []
                            longHead (x:[]) = []
                            longHead (x:xs) = x : (longHead xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n lst@(x:xs) | n &gt; 0 = let
                          len = length lst
                      in
                          case (n &gt; len) of
                              True -&gt; rotate (mod n len) lst
                              False -&gt; rotate (n - 1) (xs ++ [x])
                    | n &lt; 0 = rotate (n + 1) ((last lst) : (longHead lst))
                        where
                            last :: [a] -&gt; a
                            last [] = undefined
                            last (x:[]) = x
                            last xs = head (reverse xs)

                            longHead :: [a] -&gt; [a]
                            longHead [] = []
                            longHead (x:[]) = []
                            longHead xs = (reverse . tail . reverse) xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n lst@(x:xs) | n &gt; 0 = let
                          len = length lst
                      in
                          case (n &gt; len) of
                              True -&gt; rotate (mod n len) lst
                              False -&gt; rotate (n - 1) (xs ++ [x])
                    | n &lt; 0 = rotate (n + 1) ((last lst) : (longHead lst))
                        where
                            last :: [a] -&gt; a
                            last xs = (head . reverse) xs

                            longHead :: [a] -&gt; [a]
                            longHead xs = (reverse . tail . reverse) xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">2131932</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs |n &gt;= 0    = drop n xs ++ take n xs
            |otherwise = let len = length xs in
                         drop (len + n) xs ++ take (len + n) xs
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; :: Int -&gt; [a] -&gt; [a]
rotate&#x27; n xs = drop k xs ++ take k xs where
               k = n `mod` (length xs)

hasLengthMoreThan :: Int -&gt; [a] -&gt; Bool
hasLengthMoreThan 0 xs = xs == []
hasLengthMoreThan n [] = n &gt;= 0
hasLengthMoreThan n (x:xs) = hasLengthMoreThan (n - 1) xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 &amp;&amp; hasLengthMoreThan n xs = drop n xs ++ take n xs
            | otherwise = rotate&#x27; n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; :: Int -&gt; [a] -&gt; [a]
rotate&#x27; n xs = drop k xs ++ take k xs where
               k = n `mod` (length xs)

hasLengthMoreThan :: Int -&gt; [a] -&gt; Bool
hasLengthMoreThan 0 [] = True
hasLengthMoreThan 0 xs = False
hasLengthMoreThan n [] = n &gt;= 0
hasLengthMoreThan n (x:xs) = hasLengthMoreThan (n - 1) xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &gt;= 0 &amp;&amp; hasLengthMoreThan n xs = drop n xs ++ take n xs
            | otherwise = rotate&#x27; n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate&#x27; :: Int -&gt; [a] -&gt; [a]
rotate&#x27; n xs = drop k xs ++ take k xs where
               k = n `mod` (length xs)

hasLengthMoreThan :: Int -&gt; [a] -&gt; Bool
hasLengthMoreThan 0 [] = False
hasLengthMoreThan 0 xs = True
hasLengthMoreThan n [] = n &lt; 0
hasLengthMoreThan n (x:xs) = hasLengthMoreThan (n - 1) xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs | n &lt; 0 = rotate&#x27; n xs
            | hasLengthMoreThan n xs = drop n xs ++ take n xs
            | otherwise = rotate&#x27; n xs</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate&#x27; :: Int -&gt; [a] -&gt; [a]
rotate&#x27; n xs = drop k xs ++ take k xs where
               k = n `mod` (length xs)

hasLengthMoreThan :: Int -&gt; [a] -&gt; Bool
hasLengthMoreThan 0 [] = False
hasLengthMoreThan 0 xs = True
hasLengthMoreThan n [] = n &lt; 0
hasLengthMoreThan n (x:xs) = hasLengthMoreThan (n - 1) xs

rotate :: Int -&gt; [a] -&gt; [a]
rotate n [] = []
rotate n xs | n &lt; 0 = rotate&#x27; n xs
            | hasLengthMoreThan n xs = drop n xs ++ take n xs
            | otherwise = rotate&#x27; n xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1914351</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate r xs = take (length xs) $ drop (negate r `mod` length xs) $ cycle xs</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = []
rotate 0 list = list
rotate _ [a] = [a]
rotate r l@(x:xs) | r &gt; length l = rotate (r `mod` length l) l
                | r &gt; 0 = rotate (r-1) (xs ++ [x])
				| r &lt; 0 = rotate (r+1) ([last xs] ++ [x] ++ init xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs
    | n &gt; 0 = (reverse . take n . reverse $ xs) ++ (reverse . drop n . reverse $ xs)
    | n &lt;= 0 = (drop (negate n) xs) ++ (take (negate n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = take len . drop (n `mod` len) . cycle $ xs
    where len = length xs</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">151536</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if (isEmpty (drop n xs)) then rotate1 (rem n (length xs)) xs else rotate1 n xs

isEmpty [] = True
isEmpty _ = False

rotate1 n xs | n == 0 = xs
			 | n &gt; 0 = rightl n xs
			 | n &lt; 0 = rightr (-n) xs

			
rightl 0 xs = xs
rightl n (x:xs) = rightl (n-1) (xs ++ [x])

rightr 0 xs = xs
rightr n xs = rightr (n-1) (helper xs []) where
	helper [x] res = x : res
	helper (x:xs) res = helper xs (res ++ [x])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if (isEmpty (drop (abs n) xs)) then rotate1 (rem n (length xs)) xs else rotate1 n xs

isEmpty [] = True
isEmpty _ = False

rotate1 n xs | n == 0 = xs
			 | n &gt; 0 = rightl n xs
			 | n &lt; 0 = rightr (-n) xs

			
rightl 0 xs = xs
rightl n (x:xs) = rightl (n-1) (xs ++ [x])

rightr 0 xs = xs
rightr n xs = rightr (n-1) (helper xs []) where
	helper [x] res = x : res
	helper (x:xs) res = helper xs (res ++ [x])
</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = if (isEmpty (drop (abs n) xs)) then rotate1 (rem n (length xs)) xs else rotate1 n xs

isEmpty [] = True
isEmpty _ = False

rotate1 n xs | n == 0 = xs
			 | n &gt; 0 = rightl n xs
			 | n &lt; 0 = rightr (-n) xs

			
rightl n xs = (drop n xs) ++ (take n xs)

rightr n xs = (drop (length xs - n) xs) ++ (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate n xs = if (isEmpty (drop (abs n) xs)) then rotate1 (rem n (length xs)) xs else rotate1 n xs

isEmpty [] = True
isEmpty _ = False

rotate1 n xs | n == 0 = xs
			 | n &gt; 0 = rightl n xs
			 | n &lt; 0 = rightr (-n) xs

			
rightl n xs = (drop n xs) ++ (take n xs)

rightr n xs = (drop (length xs - n) xs) ++ (take (length xs - n) xs)</pre></code>">&nbsp;</li>
<li class="submission tooltip correct" title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 xs = xs
rotate _ [] = []
rotate n xs = if (isEmpty (drop (abs n) xs)) then rotate1 (rem n (length xs)) xs else rotate1 n xs

isEmpty [] = True
isEmpty _ = False

rotate1 n xs | n == 0 = xs
			 | n &gt; 0 = rightl n xs
			 | n &lt; 0 = rightr (-n) xs

			
rightl n xs = (drop n xs) ++ (take n xs)

rightr n xs = (drop (length xs - n) xs) ++ (take (length xs - n) xs)</pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">1943033</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 ss = ss
rotate n ss | mod n (length ss) == 0 = ss
	    | otherwise = rotate_ nn ss where nn = mod n (length ss) 	-- 			let nn = mod n (length ss) in rotate_ nn ss
-- mod -2 6 ==4 -- mod дает число &gt;=0
rotate_ :: Int -&gt; [a] -&gt; [a]
rotate_ 0 ss = ss
rotate_ nn ss | nn &gt; 0 = rotate_ (nn-1) (tail ss ++ [head ss])  -- rotate_ nn h:s | nn &gt; 0 = rotate_ (nn-1) (s ++ [h])</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>-- ВАР 2
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 ss = ss
rotate n ss 	| n == 0 		 = ss
		| n&gt;0 &amp;&amp; n&lt;(length ss)   = rotate_ n ss	 	
		| otherwise 		 = rotate (mod n (length ss)) ss   -- for n &gt;= (length ss) || n&lt;0  
-- mod -2 6 ==4 -- mod дает число &gt;=0
rotate_ :: Int -&gt; [a] -&gt; [a]
rotate_ 0 ss = ss
rotate_ nn ss   | nn==0  	= ss
		| nn&gt;0 		= rotate_ (nn-1) (tail ss ++ [head ss])  -- rotate_ nn h:s | nn &gt; 0 = rotate_ (nn-1) (s ++ [h])
		| otherwise 	= rotate_ (nn+length ss1) ss  -- nn&lt;0 -- в данном примере передается только положительное nn</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>-- ВАР 2
rotate :: Int -&gt; [a] -&gt; [a]
rotate 0 ss = ss
rotate n ss 	| n == 0 		 = ss
		| n&gt;0 &amp;&amp; n&lt;(length ss)   = rotate_ n ss	 	
		| otherwise 		 = rotate (mod n (length ss)) ss   -- for n &gt;= (length ss) || n&lt;0  
-- mod -2 6 ==4 -- mod дает число &gt;=0
rotate_ :: Int -&gt; [a] -&gt; [a]
rotate_ 0 ss = ss
rotate_ nn ss   | nn==0  	= ss
		| nn&gt;0 		= rotate_ (nn-1) (tail ss ++ [head ss])  -- rotate_ nn h:s | nn &gt; 0 = rotate_ (nn-1) (s ++ [h])
		| otherwise 	= rotate_ (nn+length ss) ss  -- nn&lt;0 -- в данном примере передается только положительное nn</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>-- ВАР 3
rotate :: Int -&gt; [a] -&gt; [a]
rotate n ss 	| n == 0 		 = ss
		| n&gt;0 &amp;&amp; n&lt;(length ss)   = rotate_ n ss	 	
		| otherwise 		 = rotate (mod n (length ss)) ss   -- for n &gt;= (length ss) || n&lt;0  
-- mod -2 6 ==4 -- mod дает число &gt;=0
rotate_ :: Int -&gt; [a] -&gt; [a]
rotate_ 0 ss = ss
rotate_ nn ss   | nn==0  	= ss
		| nn&gt;0 		= rotate_ (nn-1) (tail ss ++ [head ss])  -- rotate_ nn h:s | nn &gt; 0 = rotate_ (nn-1) (s ++ [h])
		| otherwise 	= rotate_ (nn+1) ( last ss : take (-1+length ss) ss )  -- nn&lt;0 -- в данном примере передается только положительное nn</pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>-- ВАР 4   -- реализ (через миньший сдвиг для n&gt;0 или n&lt;0) 
rotate :: Int -&gt; [a] -&gt; [a]
rotate n ss 	| n == 0 		 = ss
		| 0&lt;n &amp;&amp; 2*n&lt;=length ss   = rotate3_ n ss
		| length ss&lt;2*n &amp;&amp; n&lt;=length ss   = rotate3_ (n-length ss) ss	 -- 	n&lt;(length ss)
		| otherwise 		 = rotate (mod n (length ss)) ss   -- for n &gt;= (length ss) || n&lt;0  
        
rotate3_ :: Int -&gt; [a] -&gt; [a]
rotate3_ nn ss   | nn==0  	= ss
		| nn&gt;0 		= rotate3_ (nn-1) (tail ss ++ [head ss])  -- rotate_ nn h:s | nn &gt; 0 = rotate_ (nn-1) (s ++ [h])
		| otherwise 	= rotate3_ (nn+1) ( last ss : take (-1+length ss) ss )  -- nn&lt;0 </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>-- ВАР 4   -- реализ (через меньший сдвиг для n&gt;0 или n&lt;0) 
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate n ss 	| n == 0 		 = ss
		| 0&lt;n &amp;&amp; 2*n&lt;=length ss   = rotate3_ n ss
		| length ss&lt;2*n &amp;&amp; n&lt;=length ss   = rotate3_ (n-length ss) ss	 -- 	n&lt;(length ss)
		| otherwise 		 = rotate (mod n (length ss)) ss   -- for n &gt;= (length ss) || n&lt;0  
        
rotate3_ :: Int -&gt; [a] -&gt; [a]
rotate3_ nn ss   | nn==0  	= ss
		| nn&gt;0 		= rotate3_ (nn-1) (tail ss ++ [head ss])  -- rotate_ nn h:s | nn &gt; 0 = rotate_ (nn-1) (s ++ [h])
		| otherwise 	= rotate3_ (nn+1) ( last ss : take (-1+length ss) ss )  -- nn&lt;0 </pre></code>">&nbsp;</li>
<li class="submission tooltip " title="<code><pre>-- ВАР 4   -- реализ (через меньший сдвиг для n&gt;0 или n&lt;0) 
rotate :: Int -&gt; [a] -&gt; [a]
rotate _ [] = [] 
rotate n ss 	| n == 0 		 = ss
		| 0&lt;n &amp;&amp; 2*n&lt;=length ss   = rotate3_ n ss
		| length ss&lt;2*n &amp;&amp; n&lt;=length ss   = rotate3_ (n-length ss) ss	 -- 	n&lt;(length ss)
		| otherwise 		 = rotate (mod n (length ss)) ss   -- for n &gt;= (length ss) || n&lt;0  
        
rotate3_ :: Int -&gt; [a] -&gt; [a]
rotate3_ _ [] = [] 
rotate3_ nn ss   | nn==0  	= ss
		| nn&gt;0 		= rotate3_ (nn-1) (tail ss ++ [head ss])  -- rotate_ nn h:s | nn &gt; 0 = rotate_ (nn-1) (s ++ [h])
		| otherwise 	= rotate3_ (nn+1) ( last ss : take (-1+length ss) ss )  -- nn&lt;0 </pre></code>">&nbsp;</li>
</ul>


</li>

<li class="user">
<div class="uid">170493</div>
<ul class="submissions">
<li class="submission tooltip " title="<code><pre>rotate :: Int -&gt; [a] -&gt; [a]
rotate n xs = reverse (take k rev) ++ reverse (drop k rev)
    where l = length xs
          rev = reverse xs
          k = (l - n) `mod` l
</pre></code>">&nbsp;</li>
</ul>


</li>

</ul>



        <script src="js/vendor/jquery-1.11.2.min.js"></script>
        <script src="js/vendor/jquery.tooltipster.min.js"></script>
        <script src="js/main.js"></script>
    </body>
</html>

